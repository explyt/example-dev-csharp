<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Marten</name>
    </assembly>
    <members>
        <member name="T:Marten.AdvancedOperations">
            <summary>
                Access to advanced, rarely used features of IDocumentStore
            </summary>
        </member>
        <member name="P:Marten.AdvancedOperations.Clean">
            <summary>
                Used to remove document data and tables from the current Postgresql database
            </summary>
        </member>
        <member name="M:Marten.AdvancedOperations.AdvanceHighWaterMarkToLatestAsync(System.Threading.CancellationToken)">
            <summary>
            Advance the high water mark to the latest detected sequence. Use with caution!
            This is mostly meant for teams that retrofit asynchronous projections to a
            very large event store that has never before used projections. This will help
            the daemon start and function in its "catch up" mode
            </summary>
        </member>
        <member name="P:Marten.AdvancedOperations.InitialDataCollection">
            <summary>
                Mostly for testing support. Register a new IInitialData object
                that would be called from ResetAllData() later.
            </summary>
        </member>
        <member name="M:Marten.AdvancedOperations.ResetAllData(System.Threading.CancellationToken)">
            <summary>
                Deletes all current document and event data, then (re)applies the configured
                initial data
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Marten.AdvancedOperations.ResetHiloSequenceFloor``1(System.Int64)" -->
        <member name="M:Marten.AdvancedOperations.ResetHiloSequenceFloor``1(System.String,System.Int64)">
            <summary>
                Set the minimum sequence number for a Hilo sequence for a specific document type
                to the specified floor. Useful for migrating data between databases
            </summary>
            <typeparam name="T"></typeparam>
            <param name="floor"></param>
        </member>
        <member name="M:Marten.AdvancedOperations.FetchEventStoreStatistics(System.String,System.Threading.CancellationToken)">
            <summary>
                Fetch the current size of the event store tables, including the current value
                of the event sequence number
            </summary>
            <param name="tenantId">
                Specify the database containing this tenant id. If omitted, this method uses the default
                database
            </param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.AdvancedOperations.AllProjectionProgress(System.String,System.Threading.CancellationToken)">
            <summary>
                Check the current progress of all asynchronous projections
            </summary>
            <param name="token"></param>
            <param name="tenantId">
                Specify the database containing this tenant id. If omitted, this method uses the default
                database
            </param>
            <returns></returns>
        </member>
        <member name="M:Marten.AdvancedOperations.ProjectionProgressFor(Marten.Events.Daemon.ShardName,System.String,System.Threading.CancellationToken)">
            <summary>
                Check the current progress of a single projection or projection shard
            </summary>
            <param name="tenantId">
                Specify the database containing this tenant id. If omitted, this method uses the default
                database
            </param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.AdvancedOperations.EventProjectionScenario(System.Action{Marten.Events.TestSupport.ProjectionScenario},System.Threading.CancellationToken)">
            <summary>
                Marten's built in test support for event projections. Only use this in testing as
                it will delete existing event and projected aggregate data
            </summary>
            <param name="configuration"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.AdvancedOperations.AllAsyncProjectionShardNames">
            <summary>
            Convenience method to retrieve all valid "ShardName" identities of asynchronous projections
            </summary>
            <returns></returns>
        </member>
        <member name="F:Marten.BulkInsertMode.InsertsOnly">
            <summary>
                Default, fast mode. Will throw an exception if there are any duplicate id's with the existing data
            </summary>
        </member>
        <member name="F:Marten.BulkInsertMode.IgnoreDuplicates">
            <summary>
                Will ignore any documents that already exist in the underlying table storage
            </summary>
        </member>
        <member name="F:Marten.BulkInsertMode.OverwriteExisting">
            <summary>
                Will overwrite the values of any duplicate documents (last update wins)
            </summary>
        </member>
        <member name="T:Marten.ConnectionFactory">
            <summary>
                Default, simple implementation of IConnectionFactory
            </summary>
        </member>
        <member name="M:Marten.ConnectionFactory.#ctor(Weasel.Postgresql.Connections.INpgsqlDataSourceFactory,System.Func{System.String})">
            <summary>
                Supply a lambda that can resolve the connection string
                for a Postgresql database
            </summary>
            <param name="connectionSource"></param>
        </member>
        <member name="M:Marten.ConnectionFactory.#ctor(Weasel.Postgresql.Connections.INpgsqlDataSourceFactory,System.String)">
            <summary>
                Supply the connection string to the Postgresql database directly
            </summary>
            <param name="connectionString"></param>
        </member>
        <member name="T:Marten.DocumentStore">
            <summary>
                The main entry way to using Marten
            </summary>
        </member>
        <member name="M:Marten.DocumentStore.#ctor(Marten.StoreOptions)">
            <summary>
                Creates a new DocumentStore with the supplied StoreOptions
            </summary>
            <param name="options"></param>
        </member>
        <member name="M:Marten.DocumentStore.For(System.String)">
            <summary>
                Quick way to stand up a DocumentStore to the given database connection
                in the "development" mode for auto-creating schema objects as needed
                with the default behaviors
            </summary>
            <param name="connectionString"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.DocumentStore.For``1">
            <summary>
                Configures a DocumentStore for an existing StoreOptions type
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.DocumentStore.For(System.Action{Marten.StoreOptions})">
            <summary>
                Configures a DocumentStore by defining the StoreOptions settings first
            </summary>
            <param name="configure"></param>
            <returns></returns>
        </member>
        <member name="F:Marten.DocumentTracking.QueryOnly">
            <summary>
                Refers to a query only session type, invalid inside of OpenSession()
            </summary>
        </member>
        <member name="M:Marten.Events.AggregateToExtensions.AggregateTo``1(Marten.Linq.IMartenQueryable{Marten.Events.IEvent},``0)">
            <summary>
                Aggregate the events in this query to the type T
            </summary>
            <param name="queryable"></param>
            <param name="state"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.AggregateToExtensions.AggregateToAsync``1(Marten.Linq.IMartenQueryable{Marten.Events.IEvent},``0,System.Threading.CancellationToken)">
            <summary>
                Aggregate the events in this query to the type T
            </summary>
            <param name="queryable"></param>
            <param name="state"></param>
            <param name="token"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.AggregateToExtensions.AggregateTo``1(System.Linq.IQueryable{Marten.Events.IEvent},``0)">
            <summary>
                Aggregate the events in this query to the type T
            </summary>
            <param name="queryable"></param>
            <param name="state"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.AggregateToExtensions.AggregateToAsync``1(System.Linq.IQueryable{Marten.Events.IEvent},``0,System.Threading.CancellationToken)">
            <summary>
                Aggregate the events in this query to the type T
            </summary>
            <param name="queryable"></param>
            <param name="state"></param>
            <param name="token"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="F:Marten.Events.Aggregation.AggregationScope.SingleStream">
            <summary>
                This aggregation only applies to events from a single stream at a time
            </summary>
        </member>
        <member name="F:Marten.Events.Aggregation.AggregationScope.MultiStream">
            <summary>
                This aggregation applies events from multiple streams to a single aggregate
            </summary>
        </member>
        <member name="T:Marten.Events.Aggregation.AggregationRuntime`2">
            <summary>
                Internal base class for runtime event aggregation
            </summary>
            <typeparam name="TDoc"></typeparam>
            <typeparam name="TId"></typeparam>
        </member>
        <member name="T:Marten.Events.Aggregation.AsyncLiveAggregatorBase`1">
            <summary>
                Internal base type for live aggregators with at least one asynchronous method
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Marten.Events.Aggregation.ByStreamId`1">
            <summary>
                Slicer strategy by stream id (Guid identified streams)
            </summary>
            <typeparam name="TDoc"></typeparam>
        </member>
        <member name="T:Marten.Events.Aggregation.ByStreamKey`1">
            <summary>
                Slicer strategy by stream key (string identified streams)
            </summary>
            <typeparam name="TDoc"></typeparam>
        </member>
        <member name="T:Marten.Events.Aggregation.CustomProjection`2">
            <summary>
            Helpful as a base class for more custom aggregation projections that are not supported
            by the Single/MultipleStreamProjections
            </summary>
            <typeparam name="TDoc"></typeparam>
            <typeparam name="TId"></typeparam>
        </member>
        <member name="M:Marten.Events.Aggregation.CustomProjection`2.ApplyChangesAsync(Marten.Internal.Sessions.DocumentSessionBase,Marten.Events.Projections.EventSlice{`0,`1},System.Threading.CancellationToken,Marten.Events.Projections.ProjectionLifecycle)">
            <summary>
                Apply any document changes based on the incoming slice of events to the underlying aggregate document
            </summary>
            <param name="session"></param>
            <param name="slice"></param>
            <param name="cancellation"></param>
            <param name="lifecycle"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Aggregation.CustomProjection`2.IsNew(Marten.Events.Projections.EventSlice{`0,`1})">
            <summary>
                Override to give Marten "hints" about whether the aggregate is all new based on the incoming
                event slice. The default implementation is always false.
            </summary>
            <param name="slice"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Aggregation.CustomProjection`2.GroupEventRange(Marten.DocumentStore,Marten.Storage.IMartenDatabase,Marten.Events.Daemon.Internals.EventRange,System.Threading.CancellationToken)">
            <summary>
                Must be overridden to use as an async projection. Takes a range of events, and sorts them
                into an EventSlice for each detected aggregate document
            </summary>
            <param name="store"></param>
            <param name="database"></param>
            <param name="range"></param>
            <param name="cancellation"></param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:Marten.Events.Aggregation.CustomProjection`2.AggregateEvents(System.Action{Marten.Events.Aggregation.EventSlicer{`0,`1}})">
            <summary>
                Configure event aggregation "slicing" using Marten's default, configurable event
                slicer
            </summary>
            <param name="configure"></param>
        </member>
        <member name="M:Marten.Events.Aggregation.CustomProjection`2.AggregateByStream">
            <summary>
                Aggregate events by the containing stream identity
            </summary>
        </member>
        <member name="M:Marten.Events.Aggregation.EventSlicer`2.CustomGrouping(Marten.Events.Projections.IAggregateGrouper{`1})">
            <summary>
                Apply a custom event grouping strategy for events. This is additive to Identity() or Identities()
            </summary>
            <param name="grouper"></param>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Marten.Events.Aggregation.EventSlicer`2.FanOut``2(System.Func{``0,System.Collections.Generic.IEnumerable{``1}},Marten.Events.Projections.FanoutMode)">
            <summary>
                Apply "fan out" operations to the given TEvent type that inserts an enumerable of TChild events right behind the
                parent
                event in the event stream
            </summary>
            <param name="fanOutFunc"></param>
            <param name="mode">Should the fan out operation happen after grouping, or before? Default is after</param>
            <typeparam name="TEvent"></typeparam>
            <typeparam name="TChild"></typeparam>
        </member>
        <member name="M:Marten.Events.Aggregation.EventSlicer`2.FanOut``2(System.Func{Marten.Events.IEvent{``0},System.Collections.Generic.IEnumerable{``1}},Marten.Events.Projections.FanoutMode)">
            <summary>
                Apply "fan out" operations to the given TEvent type that inserts an enumerable of TChild events right behind the
                parent
                event in the event stream
            </summary>
            <param name="fanOutFunc"></param>
            <param name="mode">Should the fan out operation happen after grouping, or before? Default is after</param>
            <typeparam name="TEvent"></typeparam>
            <typeparam name="TChild"></typeparam>
        </member>
        <member name="M:Marten.Events.Aggregation.GeneratedAggregateProjectionBase`1.ApplyMetadata(`0,Marten.Events.IEvent)">
            <summary>
            Template method that is called on the last event in a slice of events that
            are updating an aggregate. This was added specifically to add metadata like "LastModifiedBy"
            from the last event to an aggregate with user-defined logic. Override this for your own specific logic
            </summary>
            <param name="aggregate"></param>
            <param name="lastEvent"></param>
        </member>
        <member name="M:Marten.Events.Aggregation.GeneratedAggregateProjectionBase`1.VersionIdentity(System.Linq.Expressions.Expression{System.Func{`0,System.Int32}})">
            <summary>
                Designate or override the aggregate version member for this aggregate type
            </summary>
            <param name="expression"></param>
        </member>
        <member name="M:Marten.Events.Aggregation.GeneratedAggregateProjectionBase`1.VersionIdentity(System.Linq.Expressions.Expression{System.Func{`0,System.Int64}})">
            <summary>
                Designate or override the aggregate version member for this aggregate type
            </summary>
            <param name="expression"></param>
        </member>
        <member name="M:Marten.Events.Aggregation.GeneratedAggregateProjectionBase`1.FilterIncomingEventsOnStreamType">
            <summary>
                When used as an asynchronous projection, this opts into
                only taking in events from streams explicitly marked as being
                the aggregate type for this projection. Only use this if you are explicitly
                marking streams with the aggregate type on StartStream()
            </summary>
        </member>
        <member name="T:Marten.Events.Aggregation.IAggregateProjection">
            <summary>
                Internal service within aggregating projections
            </summary>
        </member>
        <member name="P:Marten.Events.Aggregation.IAggregateProjection.ProjectionVersion">
            <summary>
            Specify that this projection is a non 1 version of the original projection definition to opt
            into Marten's parallel blue/green deployment of this projection.
            </summary>
        </member>
        <member name="T:Marten.Events.Aggregation.IAggregationRuntime">
            <summary>
                Internal interface for runtime event aggregation
            </summary>
        </member>
        <member name="T:Marten.Events.Aggregation.IAggregationSteps`1">
            <summary>
                Fluent interface option for expressing aggregation projections
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Marten.Events.Aggregation.IAggregationSteps`1.CreateEvent``1(System.Func{``0,`0})">
            <summary>
                Create a new instance of the aggregate T when the event TEvent is encountered -- if the aggregate does
                not already exist
            </summary>
            <param name="creator"></param>
            <typeparam name="TEvent"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Aggregation.IAggregationSteps`1.CreateEvent``1(System.Func{``0,Marten.IQuerySession,System.Threading.Tasks.Task{`0}})">
            <summary>
                Create a new instance of the aggregate T when the event TEvent is encountered -- if the aggregate does
                not already exist
            </summary>
            <param name="creator"></param>
            <typeparam name="TEvent"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Aggregation.IAggregationSteps`1.DeleteEvent``1">
            <summary>
                Delete the aggregate document when event of type TEvent is encountered
            </summary>
            <typeparam name="TEvent"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Aggregation.IAggregationSteps`1.DeleteEvent``1(System.Func{``0,System.Boolean})">
            <summary>
                Conditionally delete the aggregate document when event of type TEvent is encountered based on the supplied
                shouldDelete test
            </summary>
            <param name="shouldDelete"></param>
            <typeparam name="TEvent"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Aggregation.IAggregationSteps`1.DeleteEvent``1(System.Func{`0,``0,System.Boolean})">
            <summary>
                Conditionally delete the aggregate document when event of type TEvent is encountered based on the supplied
                shouldDelete test
            </summary>
            <param name="shouldDelete"></param>
            <typeparam name="TEvent"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Aggregation.IAggregationSteps`1.DeleteEventAsync``1(System.Func{Marten.IQuerySession,`0,``0,System.Threading.Tasks.Task{System.Boolean}})">
            <summary>
                Conditionally delete the aggregate document when event of type TEvent is encountered based on the supplied
                shouldDelete test
            </summary>
            <param name="shouldDelete"></param>
            <typeparam name="TEvent"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Aggregation.IAggregationSteps`1.ProjectEvent``1(System.Action{`0})">
            <summary>
                Apply changes to the existing aggregate based on the event type TEvent
            </summary>
            <param name="handler"></param>
            <typeparam name="TEvent"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Aggregation.IAggregationSteps`1.ProjectEvent``1(System.Action{`0,``0})">
            <summary>
                Apply changes to the existing aggregate based on the event type TEvent
            </summary>
            <param name="handler"></param>
            <typeparam name="TEvent"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Aggregation.IAggregationSteps`1.ProjectEvent``1(System.Func{`0,``0,`0})">
            <summary>
                Apply changes to the existing aggregate based on the event type TEvent and return
                a new aggregate. This is appropriate for immutable aggregate documents
            </summary>
            <param name="handler"></param>
            <typeparam name="TEvent"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Aggregation.IAggregationSteps`1.ProjectEvent``1(System.Func{`0,`0})">
            <summary>
                Apply changes to the existing aggregate based on the event type TEvent and return
                a new aggregate. This is appropriate for immutable aggregate documents
            </summary>
            <param name="handler"></param>
            <typeparam name="TEvent"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Aggregation.IAggregationSteps`1.ProjectEvent``1(System.Action{Marten.IQuerySession,`0,``0})">
            <summary>
                Apply changes to the existing aggregate based on the event type TEvent
            </summary>
            <param name="handler"></param>
            <typeparam name="TEvent"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Aggregation.IAggregationSteps`1.ProjectEventAsync``1(System.Func{Marten.IQuerySession,`0,``0,System.Threading.Tasks.Task})">
            <summary>
                Apply changes to the existing aggregate based on the event type TEvent.
            </summary>
            <param name="handler"></param>
            <typeparam name="TEvent"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Aggregation.IAggregationSteps`1.ProjectEventAsync``1(System.Func{Marten.IQuerySession,`0,``0,System.Threading.Tasks.Task{`0}})">
            <summary>
                Apply changes to the existing aggregate based on the event type TEvent and return
                a new aggregate. This is appropriate for immutable aggregate documents
            </summary>
            <param name="handler"></param>
            <typeparam name="TEvent"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Aggregation.IAggregationSteps`1.TransformsEvent``1">
            <summary>
                Register a source event that is transformed within this aggregation. This is important for
                asynchronous projections to enable the projection to subscribe to the source event type
                event though there are no direct handlers for the source event type
            </summary>
            <typeparam name="TEvent"></typeparam>
            <returns></returns>
        </member>
        <member name="T:Marten.Events.Aggregation.IEventGrouping`1">
            <summary>
                Represents a grouping of a range of events by aggregate id. Used in aggregation projections
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Marten.Events.Aggregation.IEventGrouping`1.AddEvent(`0,Marten.Events.IEvent)">
            <summary>
                Add a single event to a single event slice by id
            </summary>
            <param name="id">The aggregate id</param>
            <param name="event"></param>
        </member>
        <member name="M:Marten.Events.Aggregation.IEventGrouping`1.AddEvents(`0,System.Collections.Generic.IEnumerable{Marten.Events.IEvent})">
            <summary>
                Add many events to a single event slice by aggregate id
            </summary>
            <param name="id">The aggregate id</param>
            <param name="events"></param>
        </member>
        <member name="M:Marten.Events.Aggregation.IEventGrouping`1.AddEvents``1(System.Func{``0,`0},System.Collections.Generic.IEnumerable{Marten.Events.IEvent})">
            <summary>
                Add events to streams where each event of type TEvent applies to only
                one stream
            </summary>
            <param name="singleIdSource"></param>
            <param name="events"></param>
            <typeparam name="TEvent"></typeparam>
        </member>
        <member name="M:Marten.Events.Aggregation.IEventGrouping`1.AddEvents``1(System.Func{``0,System.Collections.Generic.IEnumerable{`0}},System.Collections.Generic.IEnumerable{Marten.Events.IEvent})">
            <summary>
                Add events to streams where each event of type TEvent may be related to many
                different aggregates
            </summary>
            <param name="multipleIdSource"></param>
            <param name="events"></param>
            <typeparam name="TEvent"></typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Marten.Events.Aggregation.IEventGrouping`1.AddEventsWithMetadata``1(System.Func{Marten.Events.IEvent{``0},`0},System.Collections.Generic.IEnumerable{Marten.Events.IEvent})" -->
        <member name="M:Marten.Events.Aggregation.IEventGrouping`1.FanOutOnEach``2(System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
                Apply "fan out" operations to the given TSource type that inserts an enumerable of TChild events right behind the
                parent
                event in the event stream just after any instance of the parent
            </summary>
            <param name="fanOutFunc"></param>
            <typeparam name="TSource"></typeparam>
            <typeparam name="TChild"></typeparam>
        </member>
        <member name="M:Marten.Events.Aggregation.IEventSlicer`2.SliceInlineActions(Marten.IQuerySession,System.Collections.Generic.IEnumerable{Marten.Events.StreamAction})">
            <summary>
                This is called by inline projections
            </summary>
            <param name="querySession"></param>
            <param name="streams"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Aggregation.IEventSlicer`2.SliceAsyncEvents(Marten.IQuerySession,System.Collections.Generic.List{Marten.Events.IEvent})">
            <summary>
                This is called by the asynchronous projection runner
            </summary>
            <param name="querySession"></param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="T:Marten.Events.Aggregation.SingleStreamProjection`1">
            <summary>
                Base class for aggregating events by a stream using Marten-generated pattern matching
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Marten.Events.Aggregation.SyncLiveAggregatorBase`1">
            <summary>
                Internal base class for purely synchronous live aggregators
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Marten.Events.Aggregation.TenantSliceGroup`2">
            <summary>
                Intermediate grouping of events by tenant within the asynchronous projection support. Really for aggregations
            </summary>
            <typeparam name="TDoc"></typeparam>
            <typeparam name="TId"></typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Marten.Events.Aggregation.TenantSliceGroup`2.AddEventsWithMetadata``1(System.Func{Marten.Events.IEvent{``0},`1},System.Collections.Generic.IEnumerable{Marten.Events.IEvent})" -->
        <member name="T:Marten.Events.Projections.EventSlice`2">
            <summary>
                A grouping of events that will be applied to an aggregate of type TDoc
                with the identity TId
            </summary>
            <typeparam name="TDoc"></typeparam>
            <typeparam name="TId"></typeparam>
        </member>
        <member name="P:Marten.Events.Projections.EventSlice`2.ActionType">
            <summary>
                Is this action the start of a new stream or appending
                to an existing stream?
            </summary>
        </member>
        <member name="P:Marten.Events.Projections.EventSlice`2.Id">
            <summary>
                The aggregate identity
            </summary>
        </member>
        <member name="P:Marten.Events.Projections.EventSlice`2.Tenant">
            <summary>
                The current tenant
            </summary>
        </member>
        <member name="P:Marten.Events.Projections.EventSlice`2.Aggregate">
            <summary>
                The related aggregate document
            </summary>
        </member>
        <member name="M:Marten.Events.Projections.EventSlice`2.Events">
            <summary>
                All the events in this slice
            </summary>
        </member>
        <member name="M:Marten.Events.Projections.EventSlice`2.AddEvent(Marten.Events.IEvent)">
            <summary>
                Add a single event to this slice
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Marten.Events.Projections.EventSlice`2.AddEvents(System.Collections.Generic.IEnumerable{Marten.Events.IEvent})">
            <summary>
                Add a grouping of events to this slice
            </summary>
            <param name="events"></param>
        </member>
        <member name="M:Marten.Events.Projections.EventSlice`2.AllData">
            <summary>
                Iterate through just the event data
            </summary>
            <returns></returns>
        </member>
        <member name="T:Marten.Events.Projections.EventProjection">
            <summary>
                This is the "do anything" projection type
            </summary>
        </member>
        <member name="T:Marten.Events.Projections.EventProjection.ProjectMethodCollection">
            <summary>
                This would be a helper for the open ended EventProjection
            </summary>
        </member>
        <member name="T:Marten.Events.Projections.EventProjection.CreateMethodCollection">
            <summary>
                This would be a helper for the open ended EventProjection
            </summary>
        </member>
        <member name="P:Marten.Events.Projections.EventProjection.SchemaObjects">
            <summary>
                Use to register additional or custom schema objects like database tables that
                will be used by this projection. Originally meant to support projecting to flat
                tables
            </summary>
        </member>
        <member name="T:Marten.Events.Projections.ExperimentalMultiStreamProjection`2">
            <summary>
                Experimental option for doing multi-stream aggregations using more explicit code
                for slicing
            </summary>
            <typeparam name="TDoc"></typeparam>
            <typeparam name="TId"></typeparam>
        </member>
        <member name="T:Marten.Events.Projections.Flattened.FlatTableProjection">
            <summary>
                Projection type that will write event data to a single database table
            </summary>
        </member>
        <member name="P:Marten.Events.Projections.Flattened.FlatTableProjection.Table">
            <summary>
                The definition of the table being written to. You can use this to
                modify the table structure or even add indexes
            </summary>
        </member>
        <member name="M:Marten.Events.Projections.Flattened.FlatTableProjection.Project``1(System.Action{Marten.Events.Projections.Flattened.StatementMap{``0}},System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
                Write values for the designated event type to the table columns
            </summary>
            <param name="configure"></param>
            <param name="tablePrimaryKeySource">
                If specified, tells the projection how to find the primary key value for the table
                from the event data. If missing, the projection uses the event's stream identity by default
            </param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Marten.Events.Projections.Flattened.FlatTableProjection.Delete``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
                Direct the projection to delete a row when this event type is encountered
            </summary>
            <param name="tablePrimaryKeySource">
                If specified, tells the projection how to find the primary key value for the table
                from the event data. If missing, the projection uses the event's stream identity by default
            </param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Marten.Events.Projections.Flattened.FlatTableUpsertFunction">
            <summary>
                Recipe for creating a simple upsert function based on a table structure
            </summary>
        </member>
        <member name="F:Marten.Events.Projections.Flattened.SchemaNameSource.Explicit">
            <summary>
                The user will supply the schema name explicitly
            </summary>
        </member>
        <member name="F:Marten.Events.Projections.Flattened.SchemaNameSource.DocumentSchema">
            <summary>
                The table should be placed in the main document schema as this IDocumentStore. (StoreOptions.DatabaseSchemaName)
            </summary>
        </member>
        <member name="F:Marten.Events.Projections.Flattened.SchemaNameSource.EventSchema">
            <summary>
                The table should be placed in the designated schema for the events (StoreOptions.Events.DatabaseSchemaName)
            </summary>
        </member>
        <member name="M:Marten.Events.Projections.Flattened.StatementMap`1.Map``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.String)">
            <summary>
                Map a single value in the event data to a column in the table
            </summary>
            <param name="members"></param>
            <param name="columnName">Explicitly define the column name, otherwise this will be derived from the members</param>
            <typeparam name="TValue"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Projections.Flattened.StatementMap`1.Increment``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.String)">
            <summary>
                Directs the projection to increment the designated column by the value of the event data values
            </summary>
            <param name="members"></param>
            <param name="columnName"></param>
            <typeparam name="TValue"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Projections.Flattened.StatementMap`1.Increment(System.String)">
            <summary>
                Directs the projection to increment by one the value of the designated column
            </summary>
            <param name="columnName"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Projections.Flattened.StatementMap`1.Decrement``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.String)">
            <summary>
                Directs the projection to decrement the designated column by the value of the event data values
            </summary>
            <param name="columnName"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Projections.Flattened.StatementMap`1.Decrement(System.String)">
            <summary>
                Directs the projection to decrement by one the value of the designated column
            </summary>
            <param name="columnName"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Projections.Flattened.StatementMap`1.SetValue(System.String,System.String)">
            <summary>
                Set the designated column value to the explicit string value when this event type is encountered
            </summary>
            <param name="columnName"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Projections.Flattened.StatementMap`1.SetValue(System.String,System.Int32)">
            <summary>
                Set the designated column value to the explicit integer value when this event type is encountered
            </summary>
            <param name="columnName"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:Marten.Events.Projections.GeneratedProjection">
            <summary>
                Base type for projection types that operate by code generation
            </summary>
        </member>
        <member name="F:Marten.Events.Projections.GeneratedProjection._assembleLocker">
            <summary>
            Prevent code generation bugs when multiple aggregates are code generated in parallel
            Happens more often on dynamic code generation
            </summary>
        </member>
        <member name="T:Marten.Events.Projections.IAggregateGrouper`1">
            <summary>
                Plugin point to create custom event to aggregate grouping that requires database lookup
                as part of the sorting of events into aggregate slices
            </summary>
            <typeparam name="TId"></typeparam>
        </member>
        <member name="M:Marten.Events.Projections.IAggregateGrouper`1.Group(Marten.IQuerySession,System.Collections.Generic.IEnumerable{Marten.Events.IEvent},Marten.Events.Aggregation.ITenantSliceGroup{`0})">
            <summary>
                Apply custom grouping rules to apply events to one or many aggregates
            </summary>
            <param name="session"></param>
            <param name="events"></param>
            <param name="grouping"></param>
            <returns></returns>
        </member>
        <member name="T:Marten.Events.Projections.FanoutMode">
            <summary>
                When does the fanout rule apply?
            </summary>
        </member>
        <member name="F:Marten.Events.Projections.FanoutMode.BeforeGrouping">
            <summary>
                Do the "fan out" of events *before* doing any grouping
            </summary>
        </member>
        <member name="F:Marten.Events.Projections.FanoutMode.AfterGrouping">
            <summary>
                Do the "fan out" of events *after* grouping
            </summary>
        </member>
        <member name="T:Marten.Events.Projections.IProjection">
            <summary>
                Interface for all event projections
                IProjection implementations define the projection type and handle its projection document lifecycle
                Optimized for inline usage
            </summary>
        </member>
        <member name="M:Marten.Events.Projections.IProjection.Apply(Marten.IDocumentOperations,System.Collections.Generic.IReadOnlyList{Marten.Events.StreamAction})">
            <summary>
                Apply inline projections during synchronous operations
            </summary>
            <param name="operations"></param>
            <param name="streams"></param>
        </member>
        <member name="M:Marten.Events.Projections.IProjection.ApplyAsync(Marten.IDocumentOperations,System.Collections.Generic.IReadOnlyList{Marten.Events.StreamAction},System.Threading.CancellationToken)">
            <summary>
                Apply inline projections during asynchronous operations
            </summary>
            <param name="operations"></param>
            <param name="streams"></param>
            <param name="cancellation"></param>
            <returns></returns>
        </member>
        <member name="T:Marten.Events.Projections.IProjectionSource">
            <summary>
            Interface for sources of projections
            Sources of projections are used to define the behavior how a projection is built for a given projection type
            Optimized for async usage
            </summary>
        </member>
        <member name="M:Marten.Events.Projections.IProjectionSource.PublishedTypes">
            <summary>
                This is *only* a hint to Marten about what projected document types
                are published by this projection to aid the "generate ahead" model
            </summary>
            <returns></returns>
        </member>
        <member name="P:Marten.Events.Projections.IProjectionSource.ProjectionVersion">
            <summary>
            Specify that this projection is a non 1 version of the original projection definition to opt
            into Marten's parallel blue/green deployment of this projection.
            </summary>
        </member>
        <member name="T:Marten.Events.Projections.IProjectionSchemaSource">
            <summary>
                Optional interface to expose additional schema objects to be
                built as part of the event store
            </summary>
        </member>
        <member name="T:Marten.Events.Projections.IReadOnlyProjectionData">
            <summary>
                Read-only diagnostic view of a registered projection
            </summary>
        </member>
        <member name="P:Marten.Events.Projections.IReadOnlyProjectionData.ProjectionName">
            <summary>
                The configured projection name used within the Async Daemon
                progress tracking
            </summary>
        </member>
        <member name="P:Marten.Events.Projections.IReadOnlyProjectionData.Lifecycle">
            <summary>
                When is this projection executed?
            </summary>
        </member>
        <member name="P:Marten.Events.Projections.IReadOnlyProjectionData.ProjectionType">
            <summary>
                The concrete .Net type implementing this projection
            </summary>
        </member>
        <member name="T:Marten.Events.Projections.MultiStreamGrouper`2">
            <summary>
                This type of grouper potentially sorts one event into multiple aggregates
            </summary>
            <typeparam name="TId"></typeparam>
            <typeparam name="TEvent"></typeparam>
        </member>
        <member name="T:Marten.Events.Projections.MultiStreamProjection`2">
            <summary>
                Project a single document view across events that may span across
                event streams in a user-defined grouping
            </summary>
            <typeparam name="TDoc"></typeparam>
            <typeparam name="TId"></typeparam>
        </member>
        <member name="M:Marten.Events.Projections.MultiStreamProjection`2.RollUpByTenant">
            <summary>
            Group events by the tenant id. Use this option if you need to do roll up summaries by
            tenant id within a conjoined multi-tenanted event store.
            </summary>
        </member>
        <member name="M:Marten.Events.Projections.MultiStreamProjection`2.CustomGrouping(Marten.Events.Projections.IAggregateGrouper{`1})">
            <summary>
                Apply a custom event grouping strategy for events. This is additive to Identity() or Identities()
            </summary>
            <param name="grouper"></param>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Marten.Events.Projections.MultiStreamProjection`2.CustomGrouping(Marten.Events.Aggregation.IEventSlicer{`0,`1})">
            <summary>
                If your grouping of events to aggregates doesn't fall into any simple pattern supported
                directly by ViewProjection, supply your own "let me do whatever I want" event slicer
            </summary>
            <param name="slicer"></param>
        </member>
        <member name="M:Marten.Events.Projections.MultiStreamProjection`2.FanOut``2(System.Func{``0,System.Collections.Generic.IEnumerable{``1}},Marten.Events.Projections.FanoutMode)">
            <summary>
                Apply "fan out" operations to the given TEvent type that inserts an enumerable of TChild events right behind the
                parent
                event in the event stream
            </summary>
            <param name="fanOutFunc"></param>
            <param name="mode">Should the fan out operation happen after grouping, or before? Default is after</param>
            <typeparam name="TEvent"></typeparam>
            <typeparam name="TChild"></typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Marten.Events.Projections.MultiStreamProjection`2.FanOut``2(System.Func{Marten.Events.IEvent{``0},System.Collections.Generic.IEnumerable{``1}},Marten.Events.Projections.FanoutMode)" -->
        <member name="M:Marten.Events.Projections.IEventFilterable.IncludeType``1">
            <summary>
                Short hand syntax to tell Marten that this projection takes in the event type T
                This is not mandatory, but can be used to optimize the asynchronous projections
                to create an "allow list" in the IncludedEventTypes collection
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Marten.Events.Projections.IEventFilterable.IncludeType(System.Type)">
            <summary>
                Short hand syntax to tell Marten that this projection takes in the event type T
                This is not mandatory, but can be used to optimize the asynchronous projections
                to create an "allow list" in the IncludedEventTypes collection
            </summary>
        </member>
        <member name="M:Marten.Events.Projections.IEventFilterable.FilterIncomingEventsOnStreamType(System.Type)">
            <summary>
                Limit the events processed by this projection to only streams
                marked with the given streamType.
                ONLY APPLIED TO ASYNCHRONOUS PROJECTIONS OR SUBSCRIPTIONS
            </summary>
            <param name="streamType"></param>
        </member>
        <member name="P:Marten.Events.Projections.IEventFilterable.IncludeArchivedEvents">
            <summary>
            Should archived events be considered for this filtered set? Default is false.
            </summary>
        </member>
        <member name="P:Marten.Events.Projections.EventFilterable.IncludedEventTypes">
            <summary>
                Optimize this projection within the Async Daemon by
                limiting the event types processed through this projection
                to include type "T". This is inclusive.
                If this list is empty, the async daemon will fetch every possible
                type of event at runtime
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Marten.Events.Projections.EventFilterable.StreamType">
            <summary>
                Limit the events processed by this projection to only streams
                marked with this stream type
            </summary>
        </member>
        <member name="M:Marten.Events.Projections.EventFilterable.IncludeType``1">
            <summary>
                Short hand syntax to tell Marten that this projection takes in the event type T
                This is not mandatory, but can be used to optimize the asynchronous projections
                to create an "allow list" in the IncludedEventTypes collection
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Marten.Events.Projections.EventFilterable.IncludeType(System.Type)">
            <summary>
                Short hand syntax to tell Marten that this projection takes in the event type T
                This is not mandatory, but can be used to optimize the asynchronous projections
                to create an "allow list" in the IncludedEventTypes collection
            </summary>
        </member>
        <member name="M:Marten.Events.Projections.EventFilterable.FilterIncomingEventsOnStreamType(System.Type)">
            <summary>
                Limit the events processed by this projection to only streams
                marked with the given streamType.
                ONLY APPLIED TO ASYNCHRONOUS PROJECTIONS OR SUBSCRIPTIONS
            </summary>
            <param name="streamType"></param>
        </member>
        <member name="P:Marten.Events.Projections.EventFilterable.IncludeArchivedEvents">
            <summary>
            Should archived events be considered for this filtered set? Default is false.
            </summary>
        </member>
        <member name="P:Marten.Events.Projections.ProjectionBase.ProjectionName">
            <summary>
                Descriptive name for this projection in the async daemon. The default is the type name of the projection
            </summary>
        </member>
        <member name="P:Marten.Events.Projections.ProjectionBase.ProjectionVersion">
            <summary>
            Specify that this projection is a non 1 version of the original projection definition to opt
            into Marten's parallel blue/green deployment of this projection.
            </summary>
        </member>
        <member name="P:Marten.Events.Projections.ProjectionBase.Lifecycle">
            <summary>
                The projection lifecycle that governs when this projection is executed
            </summary>
        </member>
        <member name="P:Marten.Events.Projections.ProjectionBase.TeardownDataOnRebuild">
            <summary>
                Direct Marten to delete data published by this projection as the first
                step to rebuilding the projection data. The default is false.
            </summary>
        </member>
        <member name="M:Marten.Events.Projections.ProjectionBase.RegisterPublishedType(System.Type)">
            <summary>
                Just recording which document types are published by this projection
            </summary>
            <param name="publishedType"></param>
        </member>
        <member name="T:Marten.Events.Projections.ProjectionDocumentPolicy">
            <summary>
            Makes several modifications to the documents of projections
            </summary>
        </member>
        <member name="F:Marten.Events.Projections.ProjectionLifecycle.Inline">
            <summary>
                The projection will be updated in the same transaction as
                the events being captured
            </summary>
        </member>
        <member name="F:Marten.Events.Projections.ProjectionLifecycle.Async">
            <summary>
                The projection will only execute within the Async Daemon
            </summary>
        </member>
        <member name="F:Marten.Events.Projections.ProjectionLifecycle.Live">
            <summary>
                The projection is only executed on demand
            </summary>
        </member>
        <member name="F:Marten.Events.Projections.SnapshotLifecycle.Inline">
            <summary>
                The snapshot will be updated in the same transaction as
                the events being captured
            </summary>
        </member>
        <member name="F:Marten.Events.Projections.SnapshotLifecycle.Async">
            <summary>
                The snapshot will be made asynchronously within the Async Daemon
            </summary>
        </member>
        <member name="P:Marten.Events.Projections.ErrorHandlingOptions.SkipApplyErrors">
            <summary>
            Should the daemon skip any "poison pill" events that fail in user projection code?
            </summary>
        </member>
        <member name="P:Marten.Events.Projections.ErrorHandlingOptions.SkipUnknownEvents">
            <summary>
            Should the daemon skip any unknown event types encountered when trying to
            fetch events?
            </summary>
        </member>
        <member name="P:Marten.Events.Projections.ErrorHandlingOptions.SkipSerializationErrors">
            <summary>
            Should the daemon skip any events that experience serialization errors?
            </summary>
        </member>
        <member name="T:Marten.Events.Projections.ProjectionOptions">
            <summary>
                Used to register projections with Marten
            </summary>
        </member>
        <member name="P:Marten.Events.Projections.ProjectionOptions.RebuildErrors">
            <summary>
            Async daemon error handling policies while running in a rebuild mode. The defaults
            are to *not* skip any errors
            </summary>
        </member>
        <member name="P:Marten.Events.Projections.ProjectionOptions.Errors">
            <summary>
            Async daemon error handling polices while running continuously. The defaults
            are to skip serialization errors, unknown events, and apply errors
            </summary>
        </member>
        <member name="P:Marten.Events.Projections.ProjectionOptions.FetchPlanners">
            <summary>
            Any custom or extended IFetchPlanner strategies for customizing FetchForWriting() behavior
            </summary>
        </member>
        <member name="M:Marten.Events.Projections.ProjectionOptions.Add(Marten.Events.Projections.IProjection,Marten.Events.Projections.ProjectionLifecycle,System.String,System.Action{Marten.Events.Daemon.AsyncOptions})">
            <summary>
            Register a projection to the Marten configuration
            </summary>
            <param name="projection">Value values are Inline/Async, The default is Inline</param>
            <param name="lifecycle"></param>
            <param name="projectionName">
                Overwrite the named identity of this projection. This is valuable if using the projection
                asynchronously
            </param>
            <param name="asyncConfiguration">
                Optional configuration including teardown instructions for the usage of this
                projection within the async projection daempon
            </param>
        </member>
        <member name="M:Marten.Events.Projections.ProjectionOptions.Register(Marten.Events.Projections.IProjectionSource,Marten.Events.Projections.ProjectionLifecycle,System.Action{Marten.Events.Daemon.AsyncOptions})">
            <summary>
            Register a projection to the Marten configuration
            </summary>
            <param name="projection">Value values are Inline/Async, The default is Inline</param>
            <param name="lifecycle"></param>
            <param name="projectionName">
                Overwrite the named identity of this projection. This is valuable if using the projection
                asynchronously
            </param>
            <param name="asyncConfiguration">
                Optional configuration including teardown instructions for the usage of this
                projection within the async projection daempon
            </param>
        </member>
        <member name="M:Marten.Events.Projections.ProjectionOptions.Add(Marten.Events.Projections.EventProjection,Marten.Events.Projections.ProjectionLifecycle,System.Action{Marten.Events.Daemon.AsyncOptions})">
            <summary>
            Add a projection that will be executed inline
            </summary>
            <param name="projection"></param>
            <param name="lifecycle">Optionally override the lifecycle of this projection. The default is Inline</param>
            <param name="asyncConfiguration">Use it to define behaviour during projection rebuilds</param>
        </member>
        <member name="M:Marten.Events.Projections.ProjectionOptions.LiveStreamAggregation``1(System.Action{Marten.Events.Daemon.AsyncOptions})">
            <summary>
            Register live stream aggregation. It's needed for pre-building generated types
            (Read more in https://martendb.io/configuration/prebuilding.html).
            You don't need to call this method if you registered Snapshot for this entity type.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="asyncConfiguration">Use it to define behaviour during projection rebuilds</param>
            <returns>The extended storage configuration for entity T</returns>
        </member>
        <member name="M:Marten.Events.Projections.ProjectionOptions.Snapshot``1(Marten.Events.Projections.SnapshotLifecycle,System.Action{Marten.Events.Daemon.AsyncOptions})">
            <summary>
            Perform automated snapshot on each event for selected entity type
            </summary>
            <typeparam name="T"></typeparam>
            <param name="lifecycle">Override the snapshot lifecycle. The default is Inline</param>
            <param name="asyncConfiguration">
                Optional configuration including teardown instructions for the usage of this
                projection within the async projection daemon
            </param>
            <returns>The extended storage configuration for document T</returns>
        </member>
        <member name="M:Marten.Events.Projections.ProjectionOptions.Snapshot``1(Marten.Events.Projections.SnapshotLifecycle,System.Action{Marten.Events.Aggregation.SingleStreamProjection{``0}},System.Action{Marten.Events.Daemon.AsyncOptions})">
            <summary>
            Perform automated snapshot on each event for selected entity type
            </summary>
            <typeparam name="T"></typeparam>
            <param name="lifecycle">Override the snapshot lifecycle. The default is Inline</param>
            <param name="configureProjection">Use it to further customize the projection.</param>
            <param name="asyncConfiguration">
                Optional configuration including teardown instructions for the usage of this
                projection within the async projection daemon
            </param>
            <returns>The extended storage configuration for document T</returns>
        </member>
        <member name="M:Marten.Events.Projections.ProjectionOptions.Add``1(Marten.Events.Projections.ProjectionLifecycle,System.Action{Marten.Events.Daemon.AsyncOptions})">
            <summary>
            Register an aggregate projection that should be evaluated inline
            </summary>
            <typeparam name="TProjection">Projection type</typeparam>
            <param name="lifecycle">Optionally override the ProjectionLifecycle</param>
            <param name="asyncConfiguration">Use it to define behaviour during projection rebuilds</param>
        </member>
        <member name="M:Marten.Events.Projections.ProjectionOptions.Add``1(Marten.Events.Aggregation.GeneratedAggregateProjectionBase{``0},Marten.Events.Projections.ProjectionLifecycle,System.Action{Marten.Events.Daemon.AsyncOptions})">
            <summary>
            Register an aggregate projection
            </summary>
            <param name="projection"></param>
            <typeparam name="T"></typeparam>
            <param name="lifecycle">Optionally override the ProjectionLifecycle</param>
            <param name="asyncConfiguration">Use it to define behaviour during projection rebuilds</param>
        </member>
        <member name="M:Marten.Events.Projections.ProjectionOptions.Subscribe(Marten.Subscriptions.ISubscriptionSource)">
            <summary>
            Add a new event subscription to this store
            </summary>
            <param name="subscription"></param>
        </member>
        <member name="M:Marten.Events.Projections.ProjectionOptions.Subscribe(Marten.Subscriptions.ISubscription,System.Action{Marten.Subscriptions.ISubscriptionOptions})">
            <summary>
            Add a new event subscription to this store with the option to configure the filtering
            and async daemon behavior
            </summary>
            <param name="subscription"></param>
            <param name="configure"></param>
        </member>
        <member name="P:Marten.Events.Projections.ProjectionWrapper.ProjectionVersion">
            <summary>
            Specify that this projection is a non 1 version of the original projection definition to opt
            into Marten's parallel blue/green deployment of this projection.
            </summary>
        </member>
        <member name="T:Marten.Events.Projections.ScopedProjectionWrapper`1">
            <summary>
            This is used to create projections that utilize scoped or transient
            IoC services during execution
            </summary>
            <typeparam name="TProjection"></typeparam>
        </member>
        <member name="T:Marten.Events.Projections.SingleStreamEventGrouper`2">
            <summary>
                Assigns an event to only one stream
            </summary>
            <typeparam name="TId"></typeparam>
            <typeparam name="TEvent"></typeparam>
        </member>
        <member name="T:Marten.Events.Projections.SingleStreamGrouper`2">
            <summary>
                Assigns an event to only one stream
            </summary>
            <typeparam name="TId"></typeparam>
            <typeparam name="TEvent"></typeparam>
        </member>
        <member name="T:Marten.Events.Projections.SyncEventProjectionBase">
            <summary>
                Base class for event projections that are strictly synchronous
            </summary>
        </member>
        <member name="T:Marten.Events.Projections.SyncProjectionBase">
            <summary>
                Base class for projections that are strictly synchronous
            </summary>
        </member>
        <member name="M:Marten.Events.Archiving.ArchivedEventExtensions.MaybeArchived(Marten.Events.IEvent)">
            <summary>
                Query for events regardless of whether they are marked
                as archived or not
            </summary>
            <param name="event"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.TestingExtensions.WaitForNonStaleProjectionDataAsync(Microsoft.Extensions.Hosting.IHost,System.TimeSpan)">
            <summary>
                Use with caution! This will try to wait for all projections to "catch up" to the currently
                known farthest known sequence of the event store
            </summary>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.TestingExtensions.WaitForNonStaleProjectionDataAsync(Microsoft.Extensions.Hosting.IHost,System.String,System.TimeSpan)">
            <summary>
                Wait for any running async daemon for a specific tenant id or database name to catch up to the latest event
                sequence at the time
                this method is invoked for all projections. This method is meant to aid in automated testing
            </summary>
            <param name="tenantIdOrDatabaseName">Either a tenant id or the name of a database within the system</param>
        </member>
        <member name="M:Marten.Events.TestingExtensions.WaitForNonStaleProjectionDataAsync(Marten.IDocumentStore,System.TimeSpan)">
            <summary>
                Wait for any running async daemons to catch up to the latest event sequence at the time
                this method is invoked for all projections. This method is meant to aid in automated testing
            </summary>
            <param name="store"></param>
            <param name="timeout"></param>
        </member>
        <member name="M:Marten.Events.TestingExtensions.WaitForNonStaleProjectionDataAsync(Marten.IDocumentStore,System.String,System.TimeSpan)">
            <summary>
                Wait for any running async daemon for a specific tenant id or database name to catch up to the latest event
                sequence at the time
                this method is invoked for all projections. This method is meant to aid in automated testing
            </summary>
            <param name="tenantIdOrDatabaseName">Either a tenant id or the name of a database within the system</param>
        </member>
        <member name="M:Marten.Events.TestingExtensions.WaitForNonStaleProjectionDataAsync(Marten.Storage.IMartenDatabase,System.TimeSpan)">
            <summary>
                Wait for any running async daemon to catch up to the latest event sequence at the time
            </summary>
            <param name="projectionsCount">
                Will be awaited till all shards have been started before checking if they've caught up
                with the sequence number
            </param>
            <exception cref="T:System.TimeoutException"></exception>
        </member>
        <member name="T:Marten.Events.CodeGeneration.AggregateConstructorFrame">
            <summary>
                Calls the aggregate's single argument constructor for a specific
                event type
            </summary>
        </member>
        <member name="T:Marten.Events.CodeGeneration.CreateAggregateFrame">
            <summary>
                Calls an AggregatedProjection.Create() method
            </summary>
        </member>
        <member name="M:Marten.Events.CodeGeneration.EventDocumentStorageGenerator.GenerateStorage(Marten.StoreOptions)">
            <summary>
                Only for testing support
            </summary>
            <param name="options"></param>
            <returns></returns>
        </member>
        <member name="T:Marten.Events.CodeGeneration.EventProcessingFrame">
            <summary>
                Organizes a single Event type within a pattern
                matching switch statement
            </summary>
        </member>
        <member name="M:Marten.Events.CodeGeneration.EventTypePatternMatchFrame.SortByEventTypeHierarchy(System.Collections.Generic.IEnumerable{Marten.Events.CodeGeneration.EventProcessingFrame})">
            <summary>
            Sort event processing frames by event type hierarchy
            </summary>
            <param name="frames"></param>
            <returns></returns>
        </member>
        <member name="F:Marten.Events.Daemon.AgentStatus.Running">
            <summary>
                The projection shard is successfully processing new
                events
            </summary>
        </member>
        <member name="F:Marten.Events.Daemon.AgentStatus.Stopped">
            <summary>
                The projection shard has been completely stopped
            </summary>
        </member>
        <member name="F:Marten.Events.Daemon.AgentStatus.Paused">
            <summary>
                The projection shard has been temporarily paused due
                to failures and will be re-started after a set amount
                of time
            </summary>
        </member>
        <member name="T:Marten.Events.Daemon.AsyncOptions">
            <summary>
                Governs the advanced behavior of a projection shard running
                in the projection daemon
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.AsyncOptions.BatchSize">
            <summary>
                The maximum range of events fetched at one time
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.AsyncOptions.MaximumHopperSize">
            <summary>
                The maximum number of events to be held in memory in preparation
                for determining projection updates.
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.AsyncOptions.StorageTypes">
            <summary>
                Optional list of stored document or feature types that this projection
                writes. This is used by Marten to help build out schema objects if the
                async daemon is started before the rest of the application.
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.AsyncOptions.EnableDocumentTrackingByIdentity">
            <summary>
            Enable the identity map mechanics to reuse documents within the session by their identity
            if a projection needs to make subsequent changes to the same document at one time. Default is no tracking
            </summary>
        </member>
        <member name="M:Marten.Events.Daemon.AsyncOptions.DeleteViewTypeOnTeardown``1">
            <summary>
                Add explicit teardown rule to delete all documents of type T
                when this projection shard is rebuilt
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Marten.Events.Daemon.AsyncOptions.DeleteViewTypeOnTeardown(System.Type)">
            <summary>
                Add explicit teardown rule to delete all documents of type T
                when this projection shard is rebuilt
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:Marten.Events.Daemon.AsyncOptions.DeleteDataInTableOnTeardown(Weasel.Core.DbObjectName)">
            <summary>
                Add an explicit teardown rule to wipe data in the named table
                when this projection shard is rebuilt
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Marten.Events.Daemon.AsyncOptions.DeleteDataInTableOnTeardown(System.String)">
            <summary>
                Add an explicit teardown rule to wipe data in the named table
                when this projection shard is rebuilt
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Marten.Events.Daemon.AsyncOptions.SubscribeFromPresent(System.String)">
            <summary>
            Direct that this subscription or projection should only start from events that are appended
            after the subscription is started
            </summary>
            <param name="databaseIdentifier">Optionally applies this rule to *only* the named database in the case of
            using a multi-tenancy per multiple databases strategy</param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.AsyncOptions.SubscribeFromTime(System.DateTimeOffset,System.String)">
            <summary>
            Direct that this subscription or projection should only start from events that have a timestamp
            greater than the supplied eventTimestampFloor
            </summary>
            <param name="eventTimestampFloor">The floor time of the events where this subscription should be started</param>
            <param name="databaseIdentifier">Optionally applies this rule to *only* the named database in the case of
            using a multi-tenancy per multiple databases strategy</param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.AsyncOptions.SubscribeFromSequence(System.Int64,System.String)">
            <summary>
            Direct that this subscription or projection should only start from events that have a sequence
            greater than the supplied sequenceFloor
            </summary>
            <param name="sequenceFloor"></param>
            <param name="databaseIdentifier">Optionally applies this rule to *only* the named database in the case of
            using a multi-tenancy per multiple databases strategy</param>
            <returns></returns>
        </member>
        <member name="T:Marten.Events.Daemon.AsyncProjectionShard">
            <summary>
                Definition of a single projection shard to be executed asynchronously
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.AsyncProjectionShard.Name">
            <summary>
                The identity of this projection shard
            </summary>
        </member>
        <member name="M:Marten.Events.Daemon.Coordination.IProjectionCoordinator.PauseAsync">
            <summary>
            Stops the projection coordinator's automatic restart logic and stops all running agents across all daemons. Does not release any held locks.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.Coordination.IProjectionCoordinator.ResumeAsync">
            <summary>
            Resumes the projection coordinators automatic restart logic and starts all running agents across all daemons. Intended to be used after <see cref="M:Marten.Events.Daemon.Coordination.IProjectionCoordinator.PauseAsync"/>
            </summary>
            <returns></returns>
        </member>
        <member name="P:Marten.Events.Daemon.IReadOnlyDaemonSettings.StaleSequenceThreshold">
            <summary>
                If the projection daemon detects a "stale" event sequence that is probably cause
                by sequence numbers being reserved, but never committed, this is the threshold to say
                "just look for the highest contiguous sequence number newer than X amount of time" to trigger
                the daemon to continue advancing. The default is 3 seconds.
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.IReadOnlyDaemonSettings.SlowPollingTime">
            <summary>
                Polling time between looking for a new high water sequence mark
                if the daemon detects low activity. The default is 1 second.
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.IReadOnlyDaemonSettings.FastPollingTime">
            <summary>
                Polling time between looking for a new high water sequence mark
                if the daemon detects high activity. The default is 250ms
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.IReadOnlyDaemonSettings.HealthCheckPollingTime">
            <summary>
                Polling time for the running projection daemon to determine the health
                of its activities and try to restart anything that is not currently running
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.IReadOnlyDaemonSettings.AsyncMode">
            <summary>
                Projection Daemon mode. The default is Disabled
            </summary>
        </member>
        <member name="F:Marten.Events.Daemon.DaemonSettings.AsyncListeners">
            <summary>
                Register session listeners that will ONLY be applied within the asynchronous daemon updates.
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.DaemonSettings.DaemonLockId">
            <summary>
                This is used to establish a global lock id for the async daemon and should
                be unique for any applications that target the same database.
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.DaemonSettings.LeadershipPollingTime">
            <summary>
                Time in milliseconds to poll for leadership election in the async projection daemon
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.DaemonSettings.StaleSequenceThreshold">
            <summary>
                If the projection daemon detects a "stale" event sequence that is probably cause
                by sequence numbers being reserved, but never committed, this is the threshold to say
                "just look for the highest contiguous sequence number newer than X amount of time" to trigger
                the daemon to continue advancing. The default is 3 seconds.
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.DaemonSettings.SlowPollingTime">
            <summary>
                Polling time between looking for a new high water sequence mark
                if the daemon detects low activity. The default is 1 second.
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.DaemonSettings.FastPollingTime">
            <summary>
                Polling time between looking for a new high water sequence mark
                if the daemon detects high activity. The default is 250ms
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.DaemonSettings.HealthCheckPollingTime">
            <summary>
                Polling time for the running projection daemon to determine the health
                of its activities and try to restart anything that is not currently running
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.DaemonSettings.AgentPauseTime">
            <summary>
            If a subscription has been paused for any reason
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.DaemonSettings.AsyncMode">
            <summary>
                Projection Daemon mode. The default is Disabled. As of V5, the async daemon needs to be
                explicitly added to the system with AddMarten().AddAsyncDaemon();
            </summary>
        </member>
        <member name="M:Marten.Events.Daemon.EventRangeGroup.Reset">
            <summary>
                Teardown any existing state. Used to clean off existing work
                before doing retries
            </summary>
        </member>
        <member name="M:Marten.Events.Daemon.HighWater.HighWaterDetector.AdvanceHighWaterMarkToLatest(System.Threading.CancellationToken)">
            <summary>
            Advance the high water mark to the latest detected sequence
            </summary>
            <param name="token"></param>
        </member>
        <member name="T:Marten.Events.Daemon.Internals.AggregateTypeFilter">
            <summary>
                Filter on a single aggregate type
            </summary>
        </member>
        <member name="T:Marten.Events.Daemon.Internals.EventLoaderException">
            <summary>
                Marten failed to load events for a projection shard
            </summary>
        </member>
        <member name="T:Marten.Events.Daemon.Internals.EventRange">
            <summary>
                Used to specify then track a range of events by sequence number
                within the asynchronous projections
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.Internals.EventRange.ShardName">
            <summary>
                Identifies the projection shard consuming this event range
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.Internals.EventRange.SequenceFloor">
            <summary>
                The non-inclusive lower bound of the event sequence numbers
                in this range
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.Internals.EventRange.SequenceCeiling">
            <summary>
                The inclusive upper bound of the event sequence numbers in this range
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.Internals.EventRange.Events">
            <summary>
                The actual events fetched for this range and the base filters of the projection
                shard
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.Internals.EventRange.Size">
            <summary>
                The actual number of events in this range
            </summary>
        </member>
        <member name="T:Marten.Events.Daemon.Internals.EventTypeFilter">
            <summary>
                WHERE clause filter to limit event fetching to only the event types specified
            </summary>
        </member>
        <member name="T:Marten.Events.Daemon.Internals.ProjectionDocumentSession">
            <summary>
                Lightweight session specifically used to capture operations for a specific tenant
                in the asynchronous projections
            </summary>
        </member>
        <member name="T:Marten.Events.Daemon.Internals.ProjectionUpdateBatch">
            <summary>
                Incrementally built batch command for projection updates
            </summary>
        </member>
        <member name="T:Marten.Events.Daemon.IProjectionDaemon">
            <summary>
                Starts, stops, and manages any running asynchronous projections
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.IProjectionDaemon.Tracker">
            <summary>
                Observable tracking of projection shard events
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.IProjectionDaemon.IsRunning">
            <summary>
            Indicates if this daemon is currently running any subscriptions
            </summary>
        </member>
        <member name="M:Marten.Events.Daemon.IProjectionDaemon.RebuildProjectionAsync(System.String,System.Threading.CancellationToken)">
            <summary>
                Rebuilds a single projection by projection name inline.
                Will timeout if a shard takes longer than 5 minutes.
            </summary>
            <param name="projectionName"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.IProjectionDaemon.RebuildProjectionAsync``1(System.Threading.CancellationToken)">
            <summary>
                Rebuilds a single projection by projection type inline.
                Will timeout if a shard takes longer than 5 minutes.
            </summary>
            <typeparam name="TView">Projection view type</typeparam>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.IProjectionDaemon.RebuildProjectionAsync(System.Type,System.Threading.CancellationToken)">
            <summary>
                Rebuilds a single projection by projection type inline.
                Will timeout if a shard takes longer than 5 minutes.
            </summary>
            <param name="projectionType">The projection type</param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.IProjectionDaemon.RebuildProjectionAsync(System.Type,System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
                Rebuilds a single projection by projection name inline
            </summary>
            <param name="projectionType">The projection type</param>
            <param name="shardTimeout"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.IProjectionDaemon.RebuildProjectionAsync(System.String,System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
                Rebuilds a single projection by projection name inline
            </summary>
            <param name="projectionName"></param>
            <param name="shardTimeout"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.IProjectionDaemon.RebuildProjectionAsync``1(System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
                Rebuilds a single projection by projection type inline
            </summary>
            <typeparam name="TView">Projection view type</typeparam>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.IProjectionDaemon.StartAgentAsync(System.String,System.Threading.CancellationToken)">
            <summary>
                Starts a single projection shard by name
            </summary>
            <param name="shardName">The full identity of the desired shard. Example 'Trip:All'</param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.IProjectionDaemon.StopAgentAsync(System.String,System.Exception)">
            <summary>
                Stops a single projection shard by name
            </summary>
            <param name="shardName">The full identity of the desired shard. Example 'Trip:All'</param>
            <param name="ex"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.IProjectionDaemon.StartAllAsync">
            <summary>
                Starts all known projections shards
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.IProjectionDaemon.StopAllAsync">
            <summary>
                Stops all known projection shards
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.IProjectionDaemon.WaitForNonStaleData(System.TimeSpan)">
            <summary>
                Use with caution! This will try to wait for all projections to "catch up" to the currently
                known farthest known sequence of the event store
            </summary>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.IProjectionDaemon.CurrentAgents">
            <summary>
            List of agents that are currently running or paused
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.IProjectionDaemon.HasAnyPaused">
            <summary>
            Are there any paused agents?
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.IProjectionDaemon.EjectPausedShard(System.String)">
            <summary>
            Will eject a Paused
            </summary>
            <param name="shardName"></param>
        </member>
        <member name="M:Marten.Events.Daemon.IProjectionDaemon.RebuildProjection(System.String,System.Threading.CancellationToken)">
            <summary>
                Rebuilds a single projection by projection name inline.
                Will timeout if a shard takes longer than 5 minutes.
            </summary>
            <param name="projectionName"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.IProjectionDaemon.RebuildProjection``1(System.Threading.CancellationToken)">
            <summary>
                Rebuilds a single projection by projection type inline.
                Will timeout if a shard takes longer than 5 minutes.
            </summary>
            <typeparam name="TView">Projection view type</typeparam>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.IProjectionDaemon.RebuildProjection(System.Type,System.Threading.CancellationToken)">
            <summary>
                Rebuilds a single projection by projection type inline.
                Will timeout if a shard takes longer than 5 minutes.
            </summary>
            <param name="projectionType">The projection type</param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.IProjectionDaemon.RebuildProjection(System.Type,System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
                Rebuilds a single projection by projection name inline
            </summary>
            <param name="projectionType">The projection type</param>
            <param name="shardTimeout"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.IProjectionDaemon.RebuildProjection(System.String,System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
                Rebuilds a single projection by projection name inline
            </summary>
            <param name="projectionName"></param>
            <param name="shardTimeout"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.IProjectionDaemon.RebuildProjection``1(System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
                Rebuilds a single projection by projection type inline
            </summary>
            <typeparam name="TView">Projection view type</typeparam>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.IProjectionDaemon.StartShard(System.String,System.Threading.CancellationToken)">
            <summary>
                Starts a single projection shard by name
            </summary>
            <param name="shardName"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.IProjectionDaemon.StopShard(System.String,System.Exception)">
            <summary>
                Stops a single projection shard by name
            </summary>
            <param name="shardName"></param>
            <param name="ex"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.IProjectionDaemon.StartAllShards">
            <summary>
                Starts all known projections shards
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.IProjectionDaemon.StopAll">
            <summary>
                Stops all known projection shards
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.IProjectionDaemon.StartDaemon">
            <summary>
                Starts the daemon high water detection. This is called
                automatically by any of the Start***() or Rebuild****()
                methods
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.IProjectionDaemon.StartHighWaterDetectionAsync">
            <summary>
            Starts the underlying "high water agent" running if it is not already running. This is an advanced usage
            that's handled automatically for the most part by Marten
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.IProjectionDaemon.PauseHighWaterAgentAsync">
            <summary>
            Manually stop the "high water agent" inside of this daemon. This is an advanced usage
            that's handled automatically for the most part by Marten
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.IProjectionDaemon.WaitForShardToBeRunning(System.String,System.TimeSpan)">
            <summary>
            Wait until the named shard has been started
            </summary>
            <param name="shardName"></param>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.IProjectionDaemon.RewindSubscriptionAsync(System.String,System.Threading.CancellationToken,System.Nullable{System.Int64},System.Nullable{System.DateTimeOffset})">
            <summary>
            Rewinds a subscription (or projection, so be careful with this usage) to a certain point
            and allows it to restart at that point
            </summary>
            <param name="subscriptionName">Name of the subscription</param>
            <param name="token"></param>
            <param name="sequenceFloor">The point at which to rewind the subscription. The default is zero</param>
            <param name="timestamp">Optional parameter to rewind the subscription to rerun any events that were posted on or after this time. If Marten cannot determine the sequence, it will do nothing</param>
            <returns></returns>
        </member>
        <member name="P:Marten.Events.Daemon.ISubscriptionController.ErrorOptions">
            <summary>
            The current error handling configuration for this projection or subscription
            </summary>
        </member>
        <member name="M:Marten.Events.Daemon.ISubscriptionController.ReportCriticalFailureAsync(System.Exception)">
            <summary>
            Tell the governing subscription agent that there was a critical error that
            should pause the subscription or projection
            </summary>
            <param name="ex"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.ISubscriptionController.ReportCriticalFailureAsync(System.Exception,System.Int64)">
            <summary>
            Tell the governing subscription agent that there was a critical error that
            should pause the subscription or projection
            </summary>
            <param name="ex"></param>
            <param name="lastProcessed">This allows a subscription to stop at a point within a batch of events</param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.ISubscriptionController.RecordDeadLetterEventAsync(Marten.Events.IEvent,System.Exception)">
            <summary>
            Record a dead letter event for the failure to process the current event
            </summary>
            <param name="event"></param>
            <param name="ex"></param>
            <returns></returns>
        </member>
        <member name="T:Marten.Events.Daemon.ISubscriptionAgent">
            <summary>
                Used internally by asynchronous projections.
            </summary>
        </member>
        <member name="M:Marten.Events.Daemon.ISubscriptionAgent.RecordDeadLetterEventAsync(Marten.Events.Daemon.DeadLetterEvent)">
            <summary>
            Record a dead letter event for the failure to process the current
            event
            </summary>
            <param name="event"></param>
            <returns></returns>
        </member>
        <member name="F:Marten.Events.Daemon.Resiliency.DaemonMode.Disabled">
            <summary>
                The projection daemon is disabled in this Marten application and
                will not be started as part of the application
            </summary>
        </member>
        <member name="F:Marten.Events.Daemon.Resiliency.DaemonMode.Solo">
            <summary>
                Marten will start up the complete projection daemon with the assumption
                that this node is the only execution node. This is appropriate for single
                node deployments and local development usage
            </summary>
        </member>
        <member name="F:Marten.Events.Daemon.Resiliency.DaemonMode.HotCold">
            <summary>
                Marten will ensure that the full async projection daemon will only execute on
                one node at a time, with fail over to other nodes.
            </summary>
        </member>
        <member name="F:Marten.Events.Daemon.ShardAction.Updated">
            <summary>
                The projection shard updated successfully
            </summary>
        </member>
        <member name="F:Marten.Events.Daemon.ShardAction.Started">
            <summary>
                The projection shard was successfully started
            </summary>
        </member>
        <member name="F:Marten.Events.Daemon.ShardAction.Stopped">
            <summary>
                The projection shard was stopped
            </summary>
        </member>
        <member name="F:Marten.Events.Daemon.ShardAction.Paused">
            <summary>
                The projection shard was paused and will be restarted
                after a set amount of time based on error handling policies
            </summary>
        </member>
        <member name="T:Marten.Events.Daemon.ShardName">
            <summary>
                Identity for a single async shard
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.ShardName.ProjectionName">
            <summary>
                Parent projection name
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.ShardName.Key">
            <summary>
                The identity of the shard within the projection. If there is only
                one shard for a projection, this will be "All"
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.ShardName.Identity">
            <summary>
                {ProjectionName}:{Key}. Single identity string that should be unique within this Marten application
            </summary>
        </member>
        <member name="T:Marten.Events.Daemon.ShardStartException">
            <summary>
                A projection shard failed to start
            </summary>
        </member>
        <member name="T:Marten.Events.Daemon.ShardState">
            <summary>
                Point in time state of a single projection shard or the high water mark
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.ShardState.Timestamp">
            <summary>
                Time this state was recorded
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.ShardState.ShardName">
            <summary>
                Name of the projection shard
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.ShardState.Sequence">
            <summary>
                Furthest event sequence number processed by this projection shard
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.ShardState.Exception">
            <summary>
                If not null, this is the exception that caused this state to be published
            </summary>
        </member>
        <member name="T:Marten.Events.Daemon.ShardStateTracker">
            <summary>
                Observable for progress and action updates for all running asynchronous projection shards
            </summary>
        </member>
        <member name="P:Marten.Events.Daemon.ShardStateTracker.HighWaterMark">
            <summary>
                Currently known "high water mark" denoting the highest complete sequence
                of the event storage
            </summary>
        </member>
        <member name="M:Marten.Events.Daemon.ShardStateTracker.Subscribe(System.IObserver{Marten.Events.Daemon.ShardState})">
            <summary>
                Register a new observer of projection shard events. The return disposable
                can be used to unsubscribe the observer from the tracker
            </summary>
            <param name="observer"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.ShardStateTracker.WaitForShardState(Marten.Events.Daemon.ShardState,System.Nullable{System.TimeSpan})">
            <summary>
                Use to "wait" for an expected projection shard state
            </summary>
            <param name="expected"></param>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.ShardStateTracker.WaitForShardState(System.String,System.Int64,System.Nullable{System.TimeSpan})">
            <summary>
                Use to "wait" for an expected projection shard state
            </summary>
            <param name="shardName"></param>
            <param name="sequence"></param>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.ShardStateTracker.WaitForShardState(Marten.Events.Daemon.ShardName,System.Int64,System.Nullable{System.TimeSpan})">
            <summary>
                Use to "wait" for an expected projection shard state
            </summary>
            <param name="name"></param>
            <param name="sequence"></param>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.ShardStateTracker.WaitForShardCondition(System.Func{Marten.Events.Daemon.ShardState,System.Boolean},System.String,System.Nullable{System.TimeSpan})">
            <summary>
                Use to "wait" for an expected projection shard condition
            </summary>
            <param name="condition"></param>
            <param name="description"></param>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.Daemon.ShardStateTracker.WaitForHighWaterMark(System.Int64,System.Nullable{System.TimeSpan})">
            <summary>
                Wait for the high water mark to attain the given sequence number
            </summary>
            <param name="sequence"></param>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="T:Marten.Events.Daemon.ShardStatusWatcher">
            <summary>
                Used mostly by tests to listen for expected shard events or progress
            </summary>
        </member>
        <member name="T:Marten.Events.Daemon.ShardStopException">
            <summary>
                A projection shard failed to stop in a timely manner
            </summary>
        </member>
        <member name="T:Marten.Events.Daemon.TenantedEventRangeGroup">
            <summary>
                Used within the async daemon as a buffer for custom projections
                to run events by tenant
            </summary>
        </member>
        <member name="P:Marten.Events.IEvent.Id">
            <summary>
                Unique identifier for the event. Uses a sequential Guid
            </summary>
        </member>
        <member name="P:Marten.Events.IEvent.Version">
            <summary>
                The version of the stream this event reflects. The place in the stream.
            </summary>
        </member>
        <member name="P:Marten.Events.IEvent.Sequence">
            <summary>
                The sequential order of this event in the entire event store
            </summary>
        </member>
        <member name="P:Marten.Events.IEvent.Data">
            <summary>
                The actual event data body
            </summary>
        </member>
        <member name="P:Marten.Events.IEvent.StreamId">
            <summary>
                If using Guid's for the stream identity, this will
                refer to the Stream's Id, otherwise it will always be Guid.Empty
            </summary>
        </member>
        <member name="P:Marten.Events.IEvent.StreamKey">
            <summary>
                If using strings as the stream identifier, this will refer
                to the containing Stream's Id
            </summary>
        </member>
        <member name="P:Marten.Events.IEvent.Timestamp">
            <summary>
                The UTC time that this event was originally captured
            </summary>
        </member>
        <member name="P:Marten.Events.IEvent.TenantId">
            <summary>
                If using multi-tenancy by tenant id
            </summary>
        </member>
        <member name="P:Marten.Events.IEvent.EventType">
            <summary>
                The .Net type of the event body
            </summary>
        </member>
        <member name="P:Marten.Events.IEvent.EventTypeName">
            <summary>
                Marten's type alias string for the Event type
            </summary>
        </member>
        <member name="P:Marten.Events.IEvent.DotNetTypeName">
            <summary>
                Marten's string representation of the event type
                in assembly qualified name
            </summary>
        </member>
        <member name="P:Marten.Events.IEvent.CausationId">
            <summary>
                Optional metadata describing the causation id
            </summary>
        </member>
        <member name="P:Marten.Events.IEvent.CorrelationId">
            <summary>
                Optional metadata describing the correlation id
            </summary>
        </member>
        <member name="P:Marten.Events.IEvent.Headers">
            <summary>
                Optional user defined metadata values. This may be null.
            </summary>
        </member>
        <member name="P:Marten.Events.IEvent.IsArchived">
            <summary>
                Has this event been archived and no longer applicable
                to projected views
            </summary>
        </member>
        <member name="P:Marten.Events.IEvent.AggregateTypeName">
            <summary>
                Marten's name for the aggregate type that will be persisted
                to the streams table. This will only be available when running
                within the Async Daemon
            </summary>
        </member>
        <member name="M:Marten.Events.IEvent.SetHeader(System.String,System.Object)">
            <summary>
                Set an optional user defined metadata value by key
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:Marten.Events.IEvent.GetHeader(System.String)">
            <summary>
                Get an optional user defined metadata value by key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:Marten.Events.Event`1.Data">
            <summary>
                The actual event data
            </summary>
        </member>
        <member name="P:Marten.Events.Event`1.StreamId">
            <summary>
                A reference to the stream that contains
                this event
            </summary>
        </member>
        <member name="P:Marten.Events.Event`1.StreamKey">
            <summary>
                A reference to the stream if the stream
                identifier mode is AsString
            </summary>
        </member>
        <member name="P:Marten.Events.Event`1.Id">
            <summary>
                An alternative Guid identifier to identify
                events across databases
            </summary>
        </member>
        <member name="P:Marten.Events.Event`1.Version">
            <summary>
                An event's version position within its event stream
            </summary>
        </member>
        <member name="P:Marten.Events.Event`1.Sequence">
            <summary>
                A global sequential number identifying the Event
            </summary>
        </member>
        <member name="P:Marten.Events.Event`1.Timestamp">
            <summary>
                The UTC time that this event was originally captured
            </summary>
        </member>
        <member name="P:Marten.Events.Event`1.CausationId">
            <summary>
                Optional metadata describing the causation id
            </summary>
        </member>
        <member name="P:Marten.Events.Event`1.CorrelationId">
            <summary>
                Optional metadata describing the correlation id
            </summary>
        </member>
        <member name="P:Marten.Events.Event`1.Headers">
            <summary>
                This is meant to be lazy created, and can be null
            </summary>
        </member>
        <member name="T:Marten.Events.EventDocumentStorage">
            <summary>
                Base type for the IEventStorage type that provides all the read/write operation
                mapping for the event store in a running system. The actual implementation of this
                base type is generated and compiled at runtime by Marten
            </summary>
        </member>
        <member name="P:Marten.Events.EventGraph.TimeProvider">
            <summary>
            TimeProvider used for event timestamping metadata. Replace for controlling the timestamps
            in testing
            </summary>
        </member>
        <member name="P:Marten.Events.EventGraph.EnableUniqueIndexOnEventId">
            <summary>
            Opt into having Marten create a unique index on Event.Id. The default is false. This may
            be helpful if you need to create an external reference id to another system, or need to
            load events by their Id
            </summary>
        </member>
        <member name="P:Marten.Events.EventGraph.StreamIdentity">
            <summary>
                Configure whether event streams are identified with Guid or strings
            </summary>
        </member>
        <member name="P:Marten.Events.EventGraph.TenancyStyle">
            <summary>
                Configure the event sourcing storage for multi-tenancy
            </summary>
        </member>
        <member name="P:Marten.Events.EventGraph.MetadataConfig">
            <summary>
                Configure the meta data required to be stored for events. By default meta data fields are disabled
            </summary>
        </member>
        <member name="M:Marten.Events.EventGraph.AddEventType``1">
            <summary>
                Register an event type with Marten. This isn't strictly necessary for normal usage,
                but can help Marten with asynchronous projections where Marten hasn't yet encountered
                the event type. It can also be used for the event namespace migration.
            </summary>
            <typeparam name="TEvent"></typeparam>
            <returns>Event store options, to allow fluent definition</returns>
        </member>
        <member name="M:Marten.Events.EventGraph.AddEventType(System.Type)">
            <summary>
                Register an event type with Marten. This isn't strictly necessary for normal usage,
                but can help Marten with asynchronous projections where Marten hasn't yet encountered
                the event type
            </summary>
            <param name="eventType"></param>
        </member>
        <member name="M:Marten.Events.EventGraph.AddEventTypes(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
                Register an event type with Marten. This isn't strictly necessary for normal usage,
                but can help Marten with asynchronous projections where Marten hasn't yet encountered
                the event type
            </summary>
            <param name="types"></param>
        </member>
        <member name="P:Marten.Events.EventGraph.DatabaseSchemaName">
            <summary>
                Override the database schema name for event related tables. By default this
                is the same schema as the document storage
            </summary>
        </member>
        <member name="M:Marten.Events.EventMapping.JsonTransformation(Marten.Services.Json.Transformations.JsonTransformation)">
            <summary>
                <para>
                    Defines the event JSON payload transformation. It transforms one event schema into another.
                    You can use it to handle the event schema versioning/migration.
                </para>
                <para>
                    By calling it, you tell that instead of the old CLR type, for the specific event type name,
                    you'd like to get the new CLR event type.
                    Provided functions take the deserialized object of the old event type and returns the new, mapped one.
                </para>
            </summary>
            <param name="jsonTransformation">Json transfromation</param>
        </member>
        <member name="T:Marten.Events.EventMappingExtensions">
            <summary>
                Class <c>EventMappingExtensions</c> exposes extensions and helpers to handle event type mapping.
            </summary>
        </member>
        <member name="M:Marten.Events.EventMappingExtensions.GetEventTypeName(System.Type)">
            <summary>
                Translates by convention the CLR type name into string event type name.
                It can handle both regular and generic types.
            </summary>
            <param name="eventType">CLR event type</param>
            <returns>Mapped string event type name</returns>
        </member>
        <member name="M:Marten.Events.EventMappingExtensions.GetEventTypeName``1">
            <summary>
                Translates by convention the CLR type name into string event type name.
                It can handle both regular and generic types.
            </summary>
            <typeparam name="TEvent">CLR event type</typeparam>
            <returns>Mapped string event type name</returns>
        </member>
        <member name="M:Marten.Events.EventMappingExtensions.GetEventTypeNameWithSuffix(System.String,System.String)">
            <summary>
                Translates by convention the event type name into string event type name and suffix.
                It can handle both regular and generic types.
            </summary>
            <param name="eventTypeName">event type name</param>
            <param name="suffix">Type name suffix</param>
            <returns>Mapped string event type name in the format: $"{eventTypeName}_{suffix}"</returns>
        </member>
        <member name="M:Marten.Events.EventMappingExtensions.GetEventTypeNameWithSuffix(System.Type,System.String)">
            <summary>
                Translates by convention the CLR type name into string event type name and suffix.
                It can handle both regular and generic types.
            </summary>
            <param name="eventType">CLR event type</param>
            <returns>Mapped string event type name with suffix</returns>
        </member>
        <member name="M:Marten.Events.EventMappingExtensions.GetEventTypeNameWithSuffix``1(System.String)">
            <summary>
                Translates by convention the CLR type name into string event type name and suffix.
                It can handle both regular and generic types.
            </summary>
            <typeparam name="TEvent">CLR event type</typeparam>
            <returns>Mapped string event type name with suffix</returns>
        </member>
        <member name="M:Marten.Events.EventMappingExtensions.GetEventTypeNameWithSchemaVersion(System.Type,System.UInt32)">
            <summary>
                Translates by convention the CLR type name into string event type name with schema version suffix.
                It can handle both regular and generic types.
            </summary>
            <param name="eventType">CLR event type</param>
            <param name="schemaVersion">Event schema version</param>
            <returns>Mapped string event type name with schema version suffix</returns>
        </member>
        <member name="M:Marten.Events.EventMappingExtensions.GetEventTypeNameWithSchemaVersion``1(System.UInt32)">
            <summary>
                Translates by convention the CLR type name into string event type name with schema version suffix.
                It can handle both regular and generic types.
            </summary>
            <typeparam name="TEvent">CLR event type</typeparam>
            <param name="schemaVersion">Event schema version</param>
            <returns>Mapped string event type name with schema version suffix</returns>
        </member>
        <member name="M:Marten.Events.EventMappingExtensions.GetEventTypeNameWithSchemaVersion(System.String,System.UInt32)">
            <summary>
                Translates by convention the event type name into string event type name with schema version suffix.
                It can handle both regular and generic types.
            </summary>
            <param name="eventTypeName">event type name</param>
            <param name="schemaVersion">Event schema version</param>
            <returns>Mapped string event type name in the format: $"{eventTypeName}_{version}"</returns>
        </member>
        <member name="T:Marten.Events.EventSequenceFetcher">
            <summary>
                Used to fetch the next N values of the event store sequence numbers
            </summary>
        </member>
        <member name="P:Marten.Events.EventStoreStatistics.EventCount">
            <summary>
                Number of unique events in the event store table
            </summary>
        </member>
        <member name="P:Marten.Events.EventStoreStatistics.StreamCount">
            <summary>
                Number of unique streams in the event store
            </summary>
        </member>
        <member name="P:Marten.Events.EventStoreStatistics.EventSequenceNumber">
            <summary>
                Current value of the event sequence. This may be higher than the number
                of events if events have been archived or if there were failures while
                appending events
            </summary>
        </member>
        <member name="M:Marten.Events.IEventOperations.Append(System.Guid,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
                Append one or more events in order to an existing stream
            </summary>
            <param name="stream"></param>
            <param name="events"></param>
        </member>
        <member name="M:Marten.Events.IEventOperations.Append(System.Guid,System.Object[])">
            <summary>
                Append one or more events in order to an existing stream
            </summary>
            <param name="stream"></param>
            <param name="events"></param>
        </member>
        <member name="M:Marten.Events.IEventOperations.Append(System.String,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
                Append one or more events in order to an existing stream
            </summary>
            <param name="stream"></param>
            <param name="events"></param>
        </member>
        <member name="M:Marten.Events.IEventOperations.Append(System.String,System.Object[])">
            <summary>
                Append one or more events in order to an existing stream
            </summary>
            <param name="stream"></param>
            <param name="events"></param>
        </member>
        <member name="M:Marten.Events.IEventOperations.Append(System.Guid,System.Int64,System.Object[])">
            <summary>
                Append one or more events in order to an existing stream and verify that maximum event id for the stream
                matches supplied expected version or transaction is aborted.
            </summary>
            <param name="stream"></param>
            <param name="expectedVersion">Expected maximum event version after append</param>
            <param name="events"></param>
        </member>
        <member name="M:Marten.Events.IEventOperations.Append(System.String,System.Int64,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
                Append one or more events in order to an existing stream and verify that maximum event id for the stream
                matches supplied expected version or transaction is aborted.
            </summary>
            <param name="stream"></param>
            <param name="expectedVersion">Expected maximum event version after append</param>
            <param name="events"></param>
        </member>
        <member name="M:Marten.Events.IEventOperations.Append(System.String,System.Int64,System.Object[])">
            <summary>
                Append one or more events in order to an existing stream and verify that maximum event id for the stream
                matches supplied expected version or transaction is aborted.
            </summary>
            <param name="stream"></param>
            <param name="expectedVersion">Expected maximum event version after append</param>
            <param name="events"></param>
        </member>
        <member name="M:Marten.Events.IEventOperations.StartStream``1(System.Guid,System.Object[])">
            <summary>
                Creates a new event stream based on a user-supplied Guid and appends the events in order to the new stream
            </summary>
            <typeparam name="TAggregate"></typeparam>
            <param name="id"></param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventOperations.StartStream(System.Type,System.Guid,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
                Creates a new event stream based on a user-supplied Guid and appends the events in order to the new stream
            </summary>
            <param name="aggregateType"></param>
            <param name="id"></param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventOperations.StartStream(System.Type,System.Guid,System.Object[])">
            <summary>
                Creates a new event stream based on a user-supplied Guid and appends the events in order to the new stream
            </summary>
            <param name="aggregateType"></param>
            <param name="id"></param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventOperations.StartStream``1(System.String,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
                Creates a new event stream based on a user-supplied Guid and appends the events in order to the new stream
                - WILL THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <typeparam name="TAggregate"></typeparam>
            <param name="streamKey">String identifier of this stream</param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventOperations.StartStream``1(System.String,System.Object[])">
            <summary>
                Creates a new event stream based on a user-supplied Guid and appends the events in order to the new stream
                - WILL THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <typeparam name="TAggregate"></typeparam>
            <param name="streamKey">String identifier of this stream</param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventOperations.StartStream(System.Type,System.String,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
                Creates a new event stream based on a user-supplied Guid and appends the events in order to the new stream
                - WILL THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <param name="aggregateType"></param>
            <param name="streamKey">String identifier of this stream</param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventOperations.StartStream(System.Type,System.String,System.Object[])">
            <summary>
                Creates a new event stream based on a user-supplied Guid and appends the events in order to the new stream
                - WILL THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <param name="aggregateType"></param>
            <param name="streamKey">String identifier of this stream</param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventOperations.StartStream(System.Guid,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
                Creates a new event stream based on a user-supplied Guid and appends the events in order to the new stream - WILL
                THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <param name="id"></param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventOperations.StartStream(System.Guid,System.Object[])">
            <summary>
                Creates a new event stream based on a user-supplied Guid and appends the events in order to the new stream - WILL
                THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <param name="id"></param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventOperations.StartStream(System.String,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
                Creates a new event stream based on a user-supplied Guid and appends the events in order to the new stream
                - WILL THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <param name="streamKey"></param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventOperations.StartStream(System.String,System.Object[])">
            <summary>
                Creates a new event stream based on a user-supplied Guid and appends the events in order to the new stream
                - WILL THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <param name="streamKey"></param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventOperations.StartStream``1(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
                Creates a new event stream, assigns a new Guid id, and appends the events in order to the new stream
                - WILL THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <typeparam name="TAggregate"></typeparam>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventOperations.StartStream``1(System.Object[])">
            <summary>
                Creates a new event stream, assigns a new Guid id, and appends the events in order to the new stream
                - WILL THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <typeparam name="TAggregate"></typeparam>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventOperations.StartStream(System.Type,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
                Creates a new event stream, assigns a new Guid id, and appends the events in order to the new stream
                - WILL THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <typeparam name="TAggregate"></typeparam>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventOperations.StartStream(System.Type,System.Object[])">
            <summary>
                Creates a new event stream, assigns a new Guid id, and appends the events in order to the new stream
                - WILL THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <typeparam name="TAggregate"></typeparam>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventOperations.StartStream(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
                Creates a new event stream, assigns a new Guid id, and appends the events in order to the new stream
                - WILL THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <typeparam name="TAggregate"></typeparam>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventOperations.StartStream(System.Object[])">
            <summary>
                Creates a new event stream, assigns a new Guid id, and appends the events in order to the new stream
                - WILL THROW AN EXCEPTION IF THE STREAM ALREADY EXISTS
            </summary>
            <typeparam name="TAggregate"></typeparam>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="T:Marten.Events.IEventStorage">
            <summary>
                The implementation of this class is generated at runtime based on the configuration
                of the system
            </summary>
        </member>
        <member name="M:Marten.Events.IEventStorage.AppendEvent(Marten.Events.EventGraph,Marten.Internal.IMartenSession,Marten.Events.StreamAction,Marten.Events.IEvent)">
            <summary>
                Create a storage operation to append a single event
            </summary>
            <param name="events"></param>
            <param name="session"></param>
            <param name="stream"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStorage.InsertStream(Marten.Events.StreamAction)">
            <summary>
                Create a storage operation to insert a single event stream record
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStorage.QueryForStream(Marten.Events.StreamAction)">
            <summary>
                Create an IQueryHandler to find and load a Stream
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStorage.UpdateStreamVersion(Marten.Events.StreamAction)">
            <summary>
                Create a storage operation for updating the version of a single stream
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.Append(System.Guid,System.Int64,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
                Append one or more events in order to an existing stream and verify that maximum event id for the stream
                matches supplied expected version or transaction is aborted.
            </summary>
            <param name="stream"></param>
            <param name="expectedVersion">Expected maximum event version after append</param>
            <param name="events"></param>
        </member>
        <member name="M:Marten.Events.IEventStore.StartStream``1(System.Guid,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
                Creates a new event stream based on a user-supplied Guid and appends the events in order to the new stream
            </summary>
            <typeparam name="TAggregate"></typeparam>
            <param name="id"></param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.AppendOptimistic(System.String,System.Threading.CancellationToken,System.Object[])">
            <summary>
                Append events to an existing stream with optimistic concurrency checks against the
                existing version of the stream
            </summary>
            <param name="streamKey"></param>
            <param name="token"></param>
            <param name="events"></param>
            <exception cref="!:NonExistentStreamException"></exception>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.AppendOptimistic(System.String,System.Object[])">
            <summary>
                Append events to an existing stream with optimistic concurrency checks against the
                existing version of the stream
            </summary>
            <param name="streamKey"></param>
            <param name="events"></param>
            <exception cref="!:NonExistentStreamException"></exception>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.AppendOptimistic(System.Guid,System.Threading.CancellationToken,System.Object[])">
            <summary>
                Append events to an existing stream with optimistic concurrency checks against the
                existing version of the stream
            </summary>
            <param name="streamId"></param>
            <param name="token"></param>
            <param name="events"></param>
            <exception cref="!:NonExistentStreamException"></exception>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.AppendOptimistic(System.Guid,System.Object[])">
            <summary>
                Append events to an existing stream with optimistic concurrency checks against the
                existing version of the stream
            </summary>
            <param name="streamId"></param>
            <param name="events"></param>
            <exception cref="!:NonExistentStreamException"></exception>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.AppendExclusive(System.String,System.Threading.CancellationToken,System.Object[])">
            <summary>
                Append events to an existing stream with an exclusive lock against the
                stream until this session is saved
            </summary>
            <param name="streamKey"></param>
            <param name="token"></param>
            <param name="events"></param>
            <exception cref="!:NonExistentStreamException"></exception>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.AppendExclusive(System.String,System.Object[])">
            <summary>
                Append events to an existing stream with an exclusive lock against the
                stream until this session is saved
            </summary>
            <param name="streamKey"></param>
            <param name="events"></param>
            <exception cref="!:NonExistentStreamException"></exception>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.AppendExclusive(System.Guid,System.Threading.CancellationToken,System.Object[])">
            <summary>
                Append events to an existing stream with an exclusive lock against the
                stream until this session is saved
            </summary>
            <param name="streamId"></param>
            <param name="events"></param>
            <exception cref="!:NonExistentStreamException"></exception>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.AppendExclusive(System.Guid,System.Object[])">
            <summary>
                Append events to an existing stream with an exclusive lock against the
                stream until this session is saved
            </summary>
            <param name="streamId"></param>
            <param name="events"></param>
            <exception cref="!:NonExistentStreamException"></exception>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.ArchiveStream(System.Guid)">
            <summary>
                Mark a stream and all its events as archived
            </summary>
            <param name="streamId"></param>
        </member>
        <member name="M:Marten.Events.IEventStore.ArchiveStream(System.String)">
            <summary>
                Mark a stream and all its events as archived
            </summary>
            <param name="streamKey"></param>
        </member>
        <member name="M:Marten.Events.IEventStore.FetchForWriting``1(System.Guid,System.Threading.CancellationToken)">
            <summary>
                Fetch the projected aggregate T by id with built in optimistic concurrency checks
                starting at the point the aggregate was fetched.
            </summary>
            <param name="id"></param>
            <param name="cancellation"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.WriteToAggregate``1(System.Guid,System.Action{Marten.Events.IEventStream{``0}},System.Threading.CancellationToken)">
            <summary>
                Conditionally write to an event stream for the current version of the aggregate of type T
                This automatically persists the entire session
            </summary>
            <param name="id"></param>
            <param name="writing"></param>
            <param name="cancellation"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.WriteToAggregate``1(System.Guid,System.Func{Marten.Events.IEventStream{``0},System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>
                Conditionally write to an event stream for the current version of the aggregate of type T
                This automatically persists the entire session
            </summary>
            <param name="id"></param>
            <param name="writing"></param>
            <param name="cancellation"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.WriteToAggregate``1(System.String,System.Action{Marten.Events.IEventStream{``0}},System.Threading.CancellationToken)">
            <summary>
                Conditionally write to an event stream for the current version of the aggregate of type T
                This automatically persists the entire session
            </summary>
            <param name="id"></param>
            <param name="writing"></param>
            <param name="cancellation"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.WriteToAggregate``1(System.String,System.Func{Marten.Events.IEventStream{``0},System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>
                Conditionally write to an event stream for the current version of the aggregate of type T
                This automatically persists the entire session
            </summary>
            <param name="id"></param>
            <param name="writing"></param>
            <param name="cancellation"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.FetchForWriting``1(System.String,System.Threading.CancellationToken)">
            <summary>
                Fetch the projected aggregate T by id with built in optimistic concurrency checks
                starting at the point the aggregate was fetched.
            </summary>
            <param name="id"></param>
            <param name="cancellation"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.FetchForWriting``1(System.Guid,System.Int64,System.Threading.CancellationToken)">
            <summary>
                Fetch projected aggregate T by id and expected, current version of the aggregate. Will fail immediately
                with ConcurrencyInjection if the expectedVersion is stale. Builds in optimistic concurrency for later
            </summary>
            <param name="id"></param>
            <param name="expectedVersion"></param>
            <param name="cancellation"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.FetchForWriting``1(System.String,System.Int64,System.Threading.CancellationToken)">
            <summary>
                Fetch projected aggregate T by id and expected, current version of the aggregate. Will fail immediately
                with ConcurrencyInjection if the expectedVersion is stale. Builds in optimistic concurrency for later
            </summary>
            <param name="id"></param>
            <param name="expectedVersion"></param>
            <param name="cancellation"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.WriteToAggregate``1(System.Guid,System.Int32,System.Action{Marten.Events.IEventStream{``0}},System.Threading.CancellationToken)">
            <summary>
                Conditionally write to an event stream for the current version of the aggregate of type T
                This automatically persists the entire session
            </summary>
            <param name="id"></param>
            <param name="expectedVersion">The starting version of the aggregate for optimistic concurrency checks</param>
            <param name="writing"></param>
            <param name="cancellation"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.WriteToAggregate``1(System.Guid,System.Int32,System.Func{Marten.Events.IEventStream{``0},System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>
                Conditionally write to an event stream for the current version of the aggregate of type T
                This automatically persists the entire session
            </summary>
            <param name="id"></param>
            <param name="expectedVersion">The starting version of the aggregate for optimistic concurrency checks</param>
            <param name="writing"></param>
            <param name="cancellation"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.WriteToAggregate``1(System.String,System.Int32,System.Action{Marten.Events.IEventStream{``0}},System.Threading.CancellationToken)">
            <summary>
                Conditionally write to an event stream for the current version of the aggregate of type T
                This automatically persists the entire session
            </summary>
            <param name="id"></param>
            <param name="expectedVersion">The starting version of the aggregate for optimistic concurrency checks</param>
            <param name="writing"></param>
            <param name="cancellation"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.WriteToAggregate``1(System.String,System.Int32,System.Func{Marten.Events.IEventStream{``0},System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>
                Conditionally write to an event stream for the current version of the aggregate of type T
                This automatically persists the entire session
            </summary>
            <param name="id"></param>
            <param name="expectedVersion">The starting version of the aggregate for optimistic concurrency checks</param>
            <param name="writing"></param>
            <param name="cancellation"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.FetchForExclusiveWriting``1(System.Guid,System.Threading.CancellationToken)">
            <summary>
                Fetch projected aggregate T by id for exclusive writing
            </summary>
            <param name="id"></param>
            <param name="cancellation"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.FetchForExclusiveWriting``1(System.String,System.Threading.CancellationToken)">
            <summary>
                Fetch projected aggregate T by id for exclusive writing
            </summary>
            <param name="id"></param>
            <param name="cancellation"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.WriteExclusivelyToAggregate``1(System.Guid,System.Action{Marten.Events.IEventStream{``0}},System.Threading.CancellationToken)">
            <summary>
                Write exclusively to the stream for aggregate of type T. This can time out if it is unable
                to attain a lock on the stream in time
            </summary>
            <param name="id"></param>
            <param name="expectedVersion">The starting version of the aggregate for optimistic concurrency checks</param>
            <param name="writing"></param>
            <param name="cancellation"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.WriteExclusivelyToAggregate``1(System.String,System.Action{Marten.Events.IEventStream{``0}},System.Threading.CancellationToken)">
            <summary>
                Write exclusively to the stream for aggregate of type T. This can time out if it is unable
                to attain a lock on the stream in time
            </summary>
            <param name="id"></param>
            <param name="expectedVersion">The starting version of the aggregate for optimistic concurrency checks</param>
            <param name="writing"></param>
            <param name="cancellation"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.WriteExclusivelyToAggregate``1(System.Guid,System.Func{Marten.Events.IEventStream{``0},System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>
                Write exclusively to the stream for aggregate of type T. This can time out if it is unable
                to attain a lock on the stream in time
            </summary>
            <param name="id"></param>
            <param name="expectedVersion">The starting version of the aggregate for optimistic concurrency checks</param>
            <param name="writing"></param>
            <param name="cancellation"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IEventStore.WriteExclusivelyToAggregate``1(System.String,System.Func{Marten.Events.IEventStream{``0},System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>
                Write exclusively to the stream for aggregate of type T. This can time out if it is unable
                to attain a lock on the stream in time
            </summary>
            <param name="id"></param>
            <param name="expectedVersion">The starting version of the aggregate for optimistic concurrency checks</param>
            <param name="writing"></param>
            <param name="cancellation"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="P:Marten.Events.IEventStoreOptions.StreamIdentity">
            <summary>
                Configure whether event streams are identified with Guid or strings
            </summary>
        </member>
        <member name="P:Marten.Events.IEventStoreOptions.TenancyStyle">
            <summary>
                Configure the event sourcing storage for multi-tenancy
            </summary>
        </member>
        <member name="P:Marten.Events.IEventStoreOptions.EnableGlobalProjectionsForConjoinedTenancy">
            <summary>
            Enables global project projections (with single tenancy style) for events with conjoined tenancy
            </summary>
        </member>
        <member name="P:Marten.Events.IEventStoreOptions.DatabaseSchemaName">
            <summary>
                Override the database schema name for event related tables. By default this
                is the same schema as the document storage
            </summary>
        </member>
        <member name="P:Marten.Events.IEventStoreOptions.TimeProvider">
            <summary>
            TimeProvider used for event timestamping metadata. Replace for controlling the timestamps
            in testing
            </summary>
        </member>
        <member name="P:Marten.Events.IEventStoreOptions.EnableUniqueIndexOnEventId">
            <summary>
            Opt into having Marten create a unique index on Event.Id. The default is false. This may
            be helpful if you need to create an external reference id to another system, or need to
            load events by their Id
            </summary>
        </member>
        <member name="M:Marten.Events.IEventStoreOptions.AddEventType``1">
            <summary>
                Register an event type with Marten. This isn't strictly necessary for normal usage,
                but can help Marten with asynchronous projections where Marten hasn't yet encountered
                the event type. It can also be used for the event namespace migration.
                See more in <a href="https://martendb.io/events/versioning.html#namespace-migration">documentation</a>
            </summary>
            <typeparam name="TEvent">CLR event type</typeparam>
            <returns>Event store options, to allow fluent definition</returns>
        </member>
        <member name="M:Marten.Events.IEventStoreOptions.AddEventType(System.Type)">
            <summary>
                Register an event type with Marten. This isn't strictly necessary for normal usage,
                but can help Marten with asynchronous projections where Marten hasn't yet encountered
                the event type. It can also be used for the event namespace migration.
                See more in <a href="https://martendb.io/events/versioning.html#namespace-migration">documentation</a>
            </summary>
            <param name="eventType"></param>
        </member>
        <member name="M:Marten.Events.IEventStoreOptions.AddEventTypes(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
                Register an event type with Marten. This isn't strictly necessary for normal usage,
                but can help Marten with asynchronous projections where Marten hasn't yet encountered
                the event type. It can also be used for the event namespace migration.
                See more in <a href="https://martendb.io/events/versioning.html#namespace-migration">documentation</a>
            </summary>
            <param name="types"></param>
        </member>
        <member name="M:Marten.Events.IEventStoreOptions.MapEventType``1(System.String)">
            <summary>
                Maps CLR event type as particular event type name. This is useful for event type migration.
                See more in <a href="https://martendb.io/events/versioning.html#event-type-name-migration">documentation</a>
            </summary>
            <param name="eventTypeName">Event type name</param>
            <typeparam name="TEvent">Mapped CLR event type</typeparam>
        </member>
        <member name="M:Marten.Events.IEventStoreOptions.MapEventType(System.Type,System.String)">
            <summary>
                Maps CLR event type as particular event type name. This is useful for event type migration.
                See more in <a href="https://martendb.io/events/versioning.html#event-type-name-migration">documentation</a>
            </summary>
            <param name="eventType">Event type name</param>
            <param name="eventTypeName">Event type name</param>
        </member>
        <member name="M:Marten.Events.IEventStoreOptions.Subscribe(Marten.Subscriptions.ISubscription)">
            <summary>
            Add a new event subscription to this store
            </summary>
            <param name="subscription"></param>
        </member>
        <member name="M:Marten.Events.IEventStoreOptions.Subscribe(Marten.Subscriptions.ISubscription,System.Action{Marten.Subscriptions.ISubscriptionOptions})">
            <summary>
            Add a new event subscription to this store with the option to configure the filtering
            and async daemon behavior
            </summary>
            <param name="subscription"></param>
            <param name="configure"></param>
        </member>
        <member name="M:Marten.Events.IEventStoreOptions.Upcast``1(System.String,Marten.Services.Json.Transformations.JsonTransformation)">
            <summary>
                <para>
                    Method defines the JSON payload transformation. It "upcasts" one event schema into another.
                    You can use it to handle the event schema versioning/migration.
                </para>
                <para>
                    By calling it, you tell that for provided event type name, you'd like to get the particular CLR event type.
                    JSON transformation defines the custom mapping from JSON string to the CLR object.
                </para>
                <para>
                    When you define it, default deserialization for the particular event type won't be used.
                    See more in
                    <a href="https://martendb.io/events/versioning.html#raw-json-transformation-with-json-net">documentation</a>
                </para>
            </summary>
            <param name="eventTypeName">Event type name</param>
            <param name="jsonTransformation">Event payload transformation</param>
            <typeparam name="TEvent">Mapped CLR event type</typeparam>
            <returns>Event store options, to allow fluent definition</returns>
        </member>
        <member name="M:Marten.Events.IEventStoreOptions.Upcast(System.Type,System.String,Marten.Services.Json.Transformations.JsonTransformation)">
            <summary>
                <para>
                    Method defines the event JSON payload transformation. It "upcasts" one event schema into another.
                    You can use it to handle the event schema versioning/migration.
                </para>
                <para>
                    By calling it, you tell that for provided event type name, you'd like to get the particular CLR event type.
                    JSON transformation defines the custom mapping from JSON string to the CLR object.
                </para>
                <para>
                    When you define it, default deserialization for the particular event type won't be used.
                    See more in
                    <a href="https://martendb.io/events/versioning.html#raw-json-transformation-with-json-net">documentation</a>
                </para>
            </summary>
            <param name="eventType">Mapped CLR event type</param>
            <param name="eventTypeName">Event type name</param>
            <param name="jsonTransformation">Event payload transformation</param>
            <returns>Event store options, to allow fluent definition</returns>
        </member>
        <member name="M:Marten.Events.IEventStoreOptions.Upcast``2(System.String,System.Func{``0,``1})">
            <summary>
                <para>
                    Method defines the event JSON payload transformation. It "upcasts" one event schema into another.
                    You can use it to handle the event schema versioning/migration.
                </para>
                <para>
                    By calling it, you tell that instead of the old CLR type, for the specific event type name,
                    you'd like to get the new CLR event type.
                    Provided function takes the deserialized object of the old event type and returns the new, mapped one.
                </para>
                <para>
                    Internally it uses default deserialization and event type mapping for old CLR type
                    and calls the mapping function.
                    In your application code, you should use only the new event type in the aggregation and projection logic.
                    See more in
                    <a href="https://martendb.io/events/versioning.html#transformation-with-clr-types-will-look-like-this">documentation</a>
                </para>
            </summary>
            <param name="eventTypeName">Event type name</param>
            <param name="upcast">Event payload transformation, upcasting object of old CLR event type into the new one</param>
            <typeparam name="TOldEvent">Old CLR event type</typeparam>
            <typeparam name="TEvent">New CLR event type</typeparam>
            <returns>Event store options, to allow fluent definition</returns>
        </member>
        <member name="M:Marten.Events.IEventStoreOptions.Upcast``2(System.Func{``0,``1})">
            <summary>
                <para>
                    Method defines the event JSON payload transformation. It "upcasts" one event schema into another.
                    You can use it to handle the event schema versioning/migration.
                </para>
                <para>
                    By calling it, you tell that instead of the old CLR type, you'd like to get the new CLR event type.
                    Provided function takes the deserialized object of the old event type and returns the new, mapped one.
                </para>
                <para>
                    Internally it uses default deserialization and event type mapping for old CLR type
                    and calls the mapping function.
                    In your application code, you should use only the new event type in the aggregation and projection logic.
                    See more in
                    <a href="https://martendb.io/events/versioning.htmltransformation-with-clr-types-will-look-like-this">documentation</a>
                </para>
            </summary>
            <param name="upcast">Event payload transformation, upcasting object of old CLR event type into the new one</param>
            <typeparam name="TOldEvent">Old CLR event type</typeparam>
            <typeparam name="TEvent">New CLR event type</typeparam>
            <returns>Event store options, to allow fluent definition</returns>
        </member>
        <member name="M:Marten.Events.IEventStoreOptions.Upcast``2(System.String,System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task{``1}})">
            <summary>
                <para>
                    Method defines the event JSON payload transformation. It "upcasts" one event schema into another.
                    You can use it to handle the event schema versioning/migration.
                </para>
                <para>
                    By calling it, you tell that instead of the old CLR type, for the specific event type name,
                    you'd like to get the new CLR event type.
                    Provided function takes the deserialized object of the old event type and returns the new, mapped one.
                </para>
                <para>
                    Internally it uses default deserialization and event type mapping for old CLR type
                    and calls the mapping function.
                    In your application code, you should use only the new event type in the aggregation and projection logic
                    See more in <a href="https://martendb.io/events/versioning.html#function-with-clr-types">documentation</a>
                </para>
                <para>
                    <b>WARNING!</b> Transformation will only be run in the async API and throw exceptions when run in sync method
                    calls.
                </para>
            </summary>
            <param name="eventTypeName">Event type name</param>
            <param name="upcastAsync">
                Async only event payload transformation, upcasting object of old CLR event type into the new
                one
            </param>
            <typeparam name="TOldEvent">Old CLR event type</typeparam>
            <typeparam name="TEvent">New CLR event type</typeparam>
            <returns>Event store options, to allow fluent definition</returns>
            <exception cref="T:Marten.Exceptions.MartenException">when provided transformation is called in sync API</exception>
        </member>
        <member name="M:Marten.Events.IEventStoreOptions.Upcast``2(System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task{``1}})">
            <summary>
                <para>
                    Method defines the event JSON payload transformation. It "upcasts" one event schema into another.
                    You can use it to handle the event schema versioning/migration.
                </para>
                <para>
                    By calling it, you tell that instead of the old CLR type, you'd like to get the new CLR event type.
                    Provided function takes the deserialized object of the old event type and returns the new, mapped one.
                </para>
                <para>
                    Internally it uses default deserialization and event type mapping for old CLR type
                    and calls the mapping function.
                    In your application code, you should use only the new event type in the aggregation and projection logic.
                    See more in <a href="https://martendb.io/events/versioning.html#function-with-clr-types">documentation</a>
                </para>
                <para>
                    <b>WARNING!</b> Transformation will only be run in the async API and throw exceptions when run in sync method
                    calls.
                </para>
            </summary>
            <param name="upcastAsync">
                Async only event payload transformation, upcasting object of old CLR event type into the new
                one
            </param>
            <typeparam name="TOldEvent">Old CLR event type</typeparam>
            <typeparam name="TEvent">New CLR event type</typeparam>
            <exception cref="T:Marten.Exceptions.MartenException">when provided transformation is called in sync API</exception>
            <returns>Event store options, to allow fluent definition</returns>
        </member>
        <member name="M:Marten.Events.IEventStoreOptions.Upcast(Marten.Services.Json.Transformations.IEventUpcaster[])">
            <summary>
                <para>
                    Method defines the set of event JSON payload transformations. Each of them "upcasts" one event schema into
                    another.
                    You can use it to handle the event schema versioning/migration.
                </para>
                <para>
                    See more in <a href="https://martendb.io/events/versioning.html#upcasting-with-classes">documentation</a>
                </para>
            </summary>
            <param name="upcasters">List of upcasters transforming ("upcasting") events JSON payloads from one schema to another.</param>
            <returns>Event store options, to allow fluent definition</returns>
        </member>
        <member name="M:Marten.Events.IEventStoreOptions.Upcast``1">
            <summary>
                <para>
                    Method defines the event JSON payload transformation. It "upcasts" one event schema into another.
                    You can use it to handle the event schema versioning/migration.
                </para>
                <para>
                    See more in <a href="https://martendb.io/events/versioning.html#upcasting-with-classes">documentation</a>
                </para>
            </summary>
            <param name="upcasters">Upcaster type transforming ("upcasting") event JSON payload from one schema to another.</param>
            <returns>Event store options, to allow fluent definition</returns>
        </member>
        <member name="M:Marten.Events.IQueryEventStore.FetchStream(System.Guid,System.Int64,System.Nullable{System.DateTimeOffset},System.Int64)">
            <summary>
                Synchronously fetches all of the events for the named stream
            </summary>
            <param name="streamId"></param>
            <param name="version">If set, queries for events up to and including this version</param>
            <param name="timestamp">If set, queries for events captured on or before this timestamp</param>
            <param name="fromVersion">If set, queries for events on or from this version</param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IQueryEventStore.FetchStreamAsync(System.Guid,System.Int64,System.Nullable{System.DateTimeOffset},System.Int64,System.Threading.CancellationToken)">
            <summary>
                Synchronously fetches all of the events for the named stream
            </summary>
            <param name="streamId"></param>
            <param name="version">If set, queries for events up to and including this version</param>
            <param name="timestamp">If set, queries for events captured on or before this timestamp</param>
            <param name="fromVersion">If set, queries for events on or from this version</param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IQueryEventStore.FetchStream(System.String,System.Int64,System.Nullable{System.DateTimeOffset},System.Int64)">
            <summary>
                Synchronously fetches all of the events for the named stream
            </summary>
            <param name="streamKey"></param>
            <param name="version">If set, queries for events up to and including this version</param>
            <param name="timestamp">If set, queries for events captured on or before this timestamp</param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IQueryEventStore.FetchStreamAsync(System.String,System.Int64,System.Nullable{System.DateTimeOffset},System.Int64,System.Threading.CancellationToken)">
            <summary>
                Synchronously fetches all of the events for the named stream
            </summary>
            <param name="streamKey"></param>
            <param name="version">If set, queries for events up to and including this version</param>
            <param name="timestamp">If set, queries for events captured on or before this timestamp</param>
            <param name="fromVersion">If set, queries for events on or from this version</param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IQueryEventStore.AggregateStream``1(System.Guid,System.Int64,System.Nullable{System.DateTimeOffset},``0,System.Int64)">
            <summary>
                Perform a live aggregation of the raw events in this stream to a T object
            </summary>
            <typeparam name="T"></typeparam>
            <param name="streamId"></param>
            <param name="version">If set, queries for events up to and including this version</param>
            <param name="timestamp">If set, queries for events captured on or before this timestamp</param>
            <param name="fromVersion">If set, queries for events on or from this version</param>
            <param name="state">Instance of T to apply events to</param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IQueryEventStore.AggregateStreamAsync``1(System.Guid,System.Int64,System.Nullable{System.DateTimeOffset},``0,System.Int64,System.Threading.CancellationToken)">
            <summary>
                Perform a live aggregation of the raw events in this stream to a T object
            </summary>
            <typeparam name="T"></typeparam>
            <param name="streamId"></param>
            <param name="version">If set, queries for events up to and including this version</param>
            <param name="timestamp">If set, queries for events captured on or before this timestamp</param>
            <param name="fromVersion">If set, queries for events on or from this version</param>
            <param name="state">Instance of T to apply events to</param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IQueryEventStore.AggregateStream``1(System.String,System.Int64,System.Nullable{System.DateTimeOffset},``0,System.Int64)">
            <summary>
                Perform a live aggregation of the raw events in this stream to a T object
            </summary>
            <typeparam name="T"></typeparam>
            <param name="streamKey"></param>
            <param name="version"></param>
            <param name="timestamp"></param>
            <param name="state">Instance of T to apply events to</param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IQueryEventStore.AggregateStreamAsync``1(System.String,System.Int64,System.Nullable{System.DateTimeOffset},``0,System.Int64,System.Threading.CancellationToken)">
            <summary>
                Perform a live aggregation of the raw events in this stream to a T object
            </summary>
            <typeparam name="T"></typeparam>
            <param name="streamKey"></param>
            <param name="version">If set, queries for events up to and including this version</param>
            <param name="timestamp">If set, queries for events captured on or before this timestamp</param>
            <param name="fromVersion">If set, queries for events on or from this version</param>
            <param name="state">Instance of T to apply events to</param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IQueryEventStore.QueryRawEventDataOnly``1">
            <summary>
                Query directly against ONLY the raw event data. Use IQuerySession.Query() for aggregated documents!
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IQueryEventStore.QueryAllRawEvents">
            <summary>
                Query directly against the raw event data across all event types
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IQueryEventStore.Load``1(System.Guid)">
            <summary>
                Load a single event by its id knowing the event type upfront
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IQueryEventStore.LoadAsync``1(System.Guid,System.Threading.CancellationToken)">
            <summary>
                Load a single event by its id knowing the event type upfront
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IQueryEventStore.Load(System.Guid)">
            <summary>
                Load a single event by its id
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IQueryEventStore.LoadAsync(System.Guid,System.Threading.CancellationToken)">
            <summary>
                Load a single event by its id
            </summary>
            <param name="id"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IQueryEventStore.FetchStreamState(System.Guid)">
            <summary>
                Fetches only the metadata about a stream by id
            </summary>
            <param name="streamId"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IQueryEventStore.FetchStreamStateAsync(System.Guid,System.Threading.CancellationToken)">
            <summary>
                Fetches only the metadata about a stream by id
            </summary>
            <param name="streamId"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IQueryEventStore.FetchStreamState(System.String)">
            <summary>
                Fetches only the metadata about a stream by id
            </summary>
            <param name="streamKey"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.IQueryEventStore.FetchStreamStateAsync(System.String,System.Threading.CancellationToken)">
            <summary>
                Fetches only the metadata about a stream by id
            </summary>
            <param name="streamKey"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="P:Marten.Events.IReadOnlyEventStoreOptions.Daemon">
            <summary>
                Advanced configuration for the asynchronous projection execution
            </summary>
        </member>
        <member name="P:Marten.Events.IReadOnlyEventStoreOptions.StreamIdentity">
            <summary>
                Configure whether event streams are identified with Guid or strings
            </summary>
        </member>
        <member name="P:Marten.Events.IReadOnlyEventStoreOptions.TenancyStyle">
            <summary>
                Configure the event sourcing storage for multi-tenancy
            </summary>
        </member>
        <member name="P:Marten.Events.IReadOnlyEventStoreOptions.DatabaseSchemaName">
            <summary>
                Override the database schema name for event related tables. By default this
                is the same schema as the document storage
            </summary>
        </member>
        <member name="P:Marten.Events.IReadOnlyEventStoreOptions.MetadataConfig">
            <summary>
                Metadata configuration
            </summary>
        </member>
        <member name="P:Marten.Events.IReadOnlyEventStoreOptions.EnableUniqueIndexOnEventId">
            <summary>
            Opt into having Marten create a unique index on Event.Id. The default is false. This may
            be helpful if you need to create an external reference id to another system, or need to
            load events by their Id
            </summary>
        </member>
        <member name="M:Marten.Events.IReadOnlyEventStoreOptions.Projections">
            <summary>
                Configuration for all event store projections
            </summary>
        </member>
        <member name="P:Marten.Events.IReadonlyMetadataConfig.CorrelationIdEnabled">
            <summary>
                Optional metadata describing the correlation id for an events
            </summary>
        </member>
        <member name="P:Marten.Events.IReadonlyMetadataConfig.CausationIdEnabled">
            <summary>
                Optional metadata describing the causation id for an events
            </summary>
        </member>
        <member name="P:Marten.Events.IReadonlyMetadataConfig.HeadersEnabled">
            <summary>
                Optional, user defined headers for an event
            </summary>
        </member>
        <member name="P:Marten.Events.MetadataConfig.CorrelationIdEnabled">
            <summary>
                Setting to enable optional correlation id metadata for events
            </summary>
        </member>
        <member name="P:Marten.Events.MetadataConfig.CausationIdEnabled">
            <summary>
                Setting to enable optional causation id metadata for events
            </summary>
        </member>
        <member name="P:Marten.Events.MetadataConfig.HeadersEnabled">
            <summary>
                Setting to enable optional user defined metadata for events
            </summary>
        </member>
        <member name="M:Marten.Events.MetadataConfig.EnableAll">
            <summary>
                Method to enable all optional metadata fields
            </summary>
        </member>
        <member name="T:Marten.Events.ProjectionVersionAttribute">
            <summary>
            Alternative to mark aggregation projections as being versioned to
            opt into Marten's blue/green deployment support for projections
            </summary>
            <param name="version"></param>
        </member>
        <member name="M:Marten.Events.ProjectionVersionAttribute.#ctor(System.UInt32)">
            <summary>
            Alternative to mark aggregation projections as being versioned to
            opt into Marten's blue/green deployment support for projections
            </summary>
            <param name="version"></param>
        </member>
        <member name="T:Marten.Events.Querying.StreamStateQueryHandler">
            <summary>
                Internal base class for generated stream state query handling
            </summary>
        </member>
        <member name="T:Marten.Events.Schema.IEventTableColumn">
            <summary>
                This interface is used by the event store code generation to build the IEventStorage
            </summary>
        </member>
        <member name="P:Marten.Events.Schema.IEventTableColumn.Name">
            <summary>
                Column name
            </summary>
        </member>
        <member name="M:Marten.Events.Schema.IEventTableColumn.GenerateSelectorCodeSync(JasperFx.CodeGeneration.GeneratedMethod,Marten.Events.EventGraph,System.Int32)">
            <summary>
                Generate the synchronous IEventSelector code for this event table column
            </summary>
            <param name="method"></param>
            <param name="graph"></param>
            <param name="index"></param>
        </member>
        <member name="M:Marten.Events.Schema.IEventTableColumn.GenerateSelectorCodeAsync(JasperFx.CodeGeneration.GeneratedMethod,Marten.Events.EventGraph,System.Int32)">
            <summary>
                Generate the asynchronous IEventSelector code for this event table column
            </summary>
            <param name="method"></param>
            <param name="graph"></param>
            <param name="index"></param>
        </member>
        <member name="M:Marten.Events.Schema.IEventTableColumn.GenerateAppendCode(JasperFx.CodeGeneration.GeneratedMethod,Marten.Events.EventGraph,System.Int32)">
            <summary>
                Generate code for this column to capture the NpgsqlParameter value that should
                be persisted when appending an event to the events table
            </summary>
            <param name="method"></param>
            <param name="graph"></param>
            <param name="index"></param>
        </member>
        <member name="F:Marten.Events.StreamActionType.Start">
            <summary>
                This is a new stream. This action will be rejected
                if a stream with the same identity exists in the database
            </summary>
        </member>
        <member name="F:Marten.Events.StreamActionType.Append">
            <summary>
                Append these events to an existing stream. If the stream does not
                already exist, it will be created with these events
            </summary>
        </member>
        <member name="T:Marten.Events.StreamAction">
            <summary>
                Models a series of events to be appended to either a new or
                existing stream
            </summary>
        </member>
        <member name="P:Marten.Events.StreamAction.Id">
            <summary>
                Identity of the stream if using Guid's as the identity
            </summary>
        </member>
        <member name="P:Marten.Events.StreamAction.Key">
            <summary>
                The identity of this stream if using strings as the stream
                identity
            </summary>
        </member>
        <member name="P:Marten.Events.StreamAction.ActionType">
            <summary>
                Is this action the start of a new stream or appending
                to an existing stream?
            </summary>
        </member>
        <member name="P:Marten.Events.StreamAction.AggregateType">
            <summary>
                If the stream was started as tagged to an aggregate type, that will
                be reflected in this property. May be null
            </summary>
        </member>
        <member name="P:Marten.Events.StreamAction.AggregateTypeName">
            <summary>
                Marten's name for the aggregate type that will be persisted
                to the streams table
            </summary>
        </member>
        <member name="P:Marten.Events.StreamAction.TenantId">
            <summary>
                The Id of the current tenant
            </summary>
        </member>
        <member name="P:Marten.Events.StreamAction.Events">
            <summary>
                The events involved in this action
            </summary>
        </member>
        <member name="P:Marten.Events.StreamAction.ExpectedVersionOnServer">
            <summary>
                The expected *starting* version of the stream in the server. This is used
                to facilitate optimistic concurrency checks
            </summary>
        </member>
        <member name="P:Marten.Events.StreamAction.Version">
            <summary>
                The ending version of the stream for this action
            </summary>
        </member>
        <member name="P:Marten.Events.StreamAction.Timestamp">
            <summary>
                The recorded timestamp for these events
            </summary>
        </member>
        <member name="P:Marten.Events.StreamAction.Created">
            <summary>
                When was the stream created
            </summary>
        </member>
        <member name="M:Marten.Events.StreamAction.Start(Marten.Events.EventGraph,System.Guid,System.Object[])">
            <summary>
                Create a new StreamAction for starting a new stream
            </summary>
            <param name="streamId"></param>
            <param name="events"></param>
            <returns></returns>
            <exception cref="T:Marten.Exceptions.EmptyEventStreamException"></exception>
        </member>
        <member name="M:Marten.Events.StreamAction.Start(System.Guid,Marten.Events.IEvent[])">
            <summary>
                Create a new StreamAction for starting a new stream
            </summary>
            <param name="streamId"></param>
            <param name="events"></param>
            <returns></returns>
            <exception cref="T:Marten.Exceptions.EmptyEventStreamException"></exception>
        </member>
        <member name="M:Marten.Events.StreamAction.Start(Marten.Events.EventGraph,System.String,System.Object[])">
            <summary>
                Create a new StreamAction for starting a new stream
            </summary>
            <param name="streamKey"></param>
            <param name="events"></param>
            <returns></returns>
            <exception cref="T:Marten.Exceptions.EmptyEventStreamException"></exception>
        </member>
        <member name="M:Marten.Events.StreamAction.Start(System.String,Marten.Events.IEvent[])">
            <summary>
                Create a new StreamAction for starting a new stream
            </summary>
            <param name="streamKey"></param>
            <param name="events"></param>
            <returns></returns>
            <exception cref="T:Marten.Exceptions.EmptyEventStreamException"></exception>
        </member>
        <member name="M:Marten.Events.StreamAction.Append(Marten.Events.EventGraph,System.Guid,System.Object[])">
            <summary>
                Create a new StreamAction for appending to an existing stream
            </summary>
            <param name="streamId"></param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.StreamAction.Append(System.Guid,Marten.Events.IEvent[])">
            <summary>
                Create a new StreamAction for appending to an existing stream
            </summary>
            <param name="streamId"></param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.StreamAction.Append(Marten.Events.EventGraph,System.String,System.Object[])">
            <summary>
                Create a new StreamAction for appending to an existing stream
            </summary>
            <param name="streamKey"></param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.StreamAction.Append(System.String,Marten.Events.IEvent[])">
            <summary>
                Create a new StreamAction for appending to an existing stream
            </summary>
            <param name="streamKey"></param>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Events.StreamAction.PrepareEvents(System.Int64,Marten.Events.EventGraph,System.Collections.Generic.Queue{System.Int64},Marten.Internal.IMartenSession)">
            <summary>
                Applies versions, .Net type aliases, the reserved sequence numbers, timestamps, etc.
                to get the events ready to be inserted into the mt_events table
            </summary>
            <param name="currentVersion"></param>
            <param name="graph"></param>
            <param name="sequences"></param>
            <param name="session"></param>
            <exception cref="T:Marten.Exceptions.EventStreamUnexpectedMaxEventIdException"></exception>
        </member>
        <member name="T:Marten.Events.StreamIdentity">
            <summary>
                Specify the identity strategy for event streams
            </summary>
        </member>
        <member name="F:Marten.Events.StreamIdentity.AsGuid">
            <summary>
                Streams should be identified by Guid
            </summary>
        </member>
        <member name="F:Marten.Events.StreamIdentity.AsString">
            <summary>
                Streams should be identified by a user supplied string
            </summary>
        </member>
        <member name="P:Marten.Events.StreamState.Id">
            <summary>
                Identity of the stream if using Guid's as the identity
            </summary>
        </member>
        <member name="P:Marten.Events.StreamState.Version">
            <summary>
                Current version of the stream in the database. Corresponds to
                the number of events in the stream
            </summary>
        </member>
        <member name="P:Marten.Events.StreamState.AggregateType">
            <summary>
                If the stream was started as tagged to an aggregate type, that will
                be reflected in this property. May be null
            </summary>
        </member>
        <member name="P:Marten.Events.StreamState.LastTimestamp">
            <summary>
                The last time this stream was appended to
            </summary>
        </member>
        <member name="P:Marten.Events.StreamState.Created">
            <summary>
                The time at which this stream was created
            </summary>
        </member>
        <member name="P:Marten.Events.StreamState.Key">
            <summary>
                The identity of this stream if using strings as the stream
                identity
            </summary>
        </member>
        <member name="P:Marten.Events.StreamState.IsArchived">
            <summary>
                Is this event stream marked as archived
            </summary>
        </member>
        <member name="M:Marten.Events.TestSupport.ProjectionScenario.AssertAgainstProjectedData(System.String,System.Func{Marten.IQuerySession,System.Threading.CancellationToken,System.Threading.Tasks.Task})">
            <summary>
                General hook to run
            </summary>
            <param name="description"></param>
            <param name="assertions"></param>
        </member>
        <member name="M:Marten.Events.TestSupport.ProjectionScenario.DocumentShouldExist``1(System.String,System.Action{``0})">
            <summary>
                Verify that a document with the supplied id exists
            </summary>
            <param name="id"></param>
            <param name="assertions">Optional lambda to make additional assertions about the document state</param>
            <typeparam name="T">The document type</typeparam>
        </member>
        <member name="M:Marten.Events.TestSupport.ProjectionScenario.DocumentShouldExist``1(System.Int64,System.Action{``0})">
            <summary>
                Verify that a document with the supplied id exists
            </summary>
            <param name="id"></param>
            <param name="assertions">Optional lambda to make additional assertions about the document state</param>
            <typeparam name="T">The document type</typeparam>
        </member>
        <member name="M:Marten.Events.TestSupport.ProjectionScenario.DocumentShouldExist``1(System.Int32,System.Action{``0})">
            <summary>
                Verify that a document with the supplied id exists
            </summary>
            <param name="id"></param>
            <param name="assertions">Optional lambda to make additional assertions about the document state</param>
            <typeparam name="T">The document type</typeparam>
        </member>
        <member name="M:Marten.Events.TestSupport.ProjectionScenario.DocumentShouldExist``1(System.Guid,System.Action{``0})">
            <summary>
                Verify that a document with the supplied id exists
            </summary>
            <param name="id"></param>
            <param name="assertions">Optional lambda to make additional assertions about the document state</param>
            <typeparam name="T">The document type</typeparam>
        </member>
        <member name="M:Marten.Events.TestSupport.ProjectionScenario.DocumentShouldNotExist``1(System.String)">
            <summary>
                Asserts that a document with a given id has been deleted or does not exist
            </summary>
            <param name="id">The identity of the document</param>
            <typeparam name="T">The document type</typeparam>
        </member>
        <member name="M:Marten.Events.TestSupport.ProjectionScenario.DocumentShouldNotExist``1(System.Int64)">
            <summary>
                Asserts that a document with a given id has been deleted or does not exist
            </summary>
            <param name="id">The identity of the document</param>
            <typeparam name="T">The document type</typeparam>
        </member>
        <member name="M:Marten.Events.TestSupport.ProjectionScenario.DocumentShouldNotExist``1(System.Int32)">
            <summary>
                Asserts that a document with a given id has been deleted or does not exist
            </summary>
            <param name="id">The identity of the document</param>
            <typeparam name="T">The document type</typeparam>
        </member>
        <member name="M:Marten.Events.TestSupport.ProjectionScenario.DocumentShouldNotExist``1(System.Guid)">
            <summary>
                Asserts that a document with a given id has been deleted or does not exist
            </summary>
            <param name="id">The identity of the document</param>
            <typeparam name="T">The document type</typeparam>
        </member>
        <member name="P:Marten.Events.TestSupport.ProjectionScenario.DoNotDeleteExistingData">
            <summary>
                Disable the scenario from "cleaning" out any existing
                event and projected document data before running the scenario
            </summary>
        </member>
        <member name="P:Marten.Events.TestSupport.ProjectionScenario.TenantId">
            <summary>
                Opt into applying this scenario to a specific tenant id in the
                case of using multi-tenancy of any kind
            </summary>
        </member>
        <member name="M:Marten.Events.TestSupport.ProjectionScenario.AppendEvents(System.String,System.Action{Marten.Events.IEventOperations})">
            <summary>
                Make any number of append event operations in the scenario sequence
            </summary>
            <param name="description">Descriptive explanation of the action in case of failures</param>
            <param name="appendAction"></param>
        </member>
        <member name="M:Marten.Events.TestSupport.ProjectionScenario.AppendEvents(System.Action{Marten.Events.IEventOperations})">
            <summary>
                Make any number of append event operations in the scenario sequence
            </summary>
            <param name="appendAction"></param>
        </member>
        <member name="T:Marten.Events.TestSupport.ProjectionScenarioException">
            <summary>
                Thrown when a ProjectionScenario fails
            </summary>
        </member>
        <member name="T:Marten.Exceptions.EventDeserializationFailureException">
            <summary>
                Thrown if Marten encounters an exception while trying to deserialize
                or upcast a persisted event
            </summary>
        </member>
        <member name="T:Marten.Exceptions.InvalidConnectionStringException">
            <summary>
                Informs that Postgres connection string is invalid
            </summary>
        </member>
        <member name="T:Marten.Exceptions.InvalidProjectionException">
            <summary>
                Thrown when any configuration rules for an active projection are violated and the projection is invalid
            </summary>
        </member>
        <member name="T:Marten.Exceptions.MartenCommandException">
            <summary>
                Wraps the Postgres command exceptions. Unifies exception handling and brings additonal information.
            </summary>
        </member>
        <member name="M:Marten.Exceptions.MartenCommandException.#ctor(Npgsql.NpgsqlCommand,System.Exception)">
            <summary>
                Creates MartenCommandException based on the command and innerException information with formatted message.
            </summary>
            <param name="command">failed Postgres command</param>
            <param name="innerException">internal exception details</param>
        </member>
        <member name="M:Marten.Exceptions.MartenCommandException.#ctor(Npgsql.NpgsqlCommand,System.Exception,System.String)">
            <summary>
                Creates MartenCommandException based on the command and innerException information with formatted message.
            </summary>
            <param name="command">failed Postgres command</param>
            <param name="innerException">internal exception details</param>
            <param name="prefix">prefix that will be added to message</param>
        </member>
        <member name="P:Marten.Exceptions.MartenCommandException.Command">
            <summary>
                Failed Postgres command
            </summary>
        </member>
        <member name="T:Marten.Exceptions.NotSupportedReason">
            <summary>
                Reasons for feature not being supported
            </summary>
        </member>
        <member name="F:Marten.Exceptions.NotSupportedReason.FullTextSearchNeedsAtLeastPostgresVersion10">
            <summary>
                Full Text Search needs at least Postgres version 10 - eg. doing PlainTextSearch or using to_tsvector
            </summary>
        </member>
        <member name="F:Marten.Exceptions.NotSupportedReason.WebStyleSearchNeedsAtLeastPostgresVersion11">
            <summary>
                Web Styles Search needs at least Postgres version 11
            </summary>
        </member>
        <member name="T:Marten.Exceptions.MartenCommandNotSupportedException">
            <summary>
                Informs that feature used in Postgres command is not supported
            </summary>
        </member>
        <member name="M:Marten.Exceptions.MartenCommandNotSupportedException.#ctor(Marten.Exceptions.NotSupportedReason,Npgsql.NpgsqlCommand,System.Exception,System.String)">
            <summary>
                Creates MartenCommandNotSupportedException based on the reason, command and innerException information with
                formatted message.
            </summary>
            <param name="reason">reason for feature not being supported</param>
            <param name="command">failed Postgres command</param>
            <param name="innerException">internal exception details</param>
            <param name="message">optional additional exception information</param>
        </member>
        <member name="P:Marten.Exceptions.MartenCommandNotSupportedException.Reason">
            <summary>
                Reason for feature not being supported
            </summary>
        </member>
        <member name="T:Marten.Exceptions.MartenException">
            <summary>
                Base class for all Marten related exceptions
            </summary>
        </member>
        <member name="F:Marten.Schema.FullTextIndexAttribute.RegConfig">
            <summary>
                Specify Index type
            </summary>
        </member>
        <member name="P:Marten.Schema.FullTextIndexAttribute.IndexName">
            <summary>
                Specify the name of the index explicity
            </summary>
        </member>
        <member name="T:Marten.Schema.BulkLoading.IBulkLoader`1">
            <summary>
                Internal service to implement bulk loading
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Marten.Schema.ComputedIndex.Casings.Default">
            <summary>
                Leave the casing as is (default)
            </summary>
        </member>
        <member name="F:Marten.Schema.ComputedIndex.Casings.Upper">
            <summary>
                Change the casing to uppercase
            </summary>
        </member>
        <member name="F:Marten.Schema.ComputedIndex.Casings.Lower">
            <summary>
                Change the casing to lowercase
            </summary>
        </member>
        <member name="P:Marten.Schema.ComputedIndex.Casing">
            <summary>
                Marks the column value as upper/lower casing
            </summary>
        </member>
        <member name="P:Marten.Schema.ComputedIndex.TenancyScope">
            <summary>
                Specifies the unique index is scoped to the tenant
            </summary>
        </member>
        <member name="T:Marten.Schema.DatabaseSchemaNameAttribute">
            <summary>
                Overrides the database schema name for the document type
            </summary>
        </member>
        <member name="T:Marten.Schema.DdlTemplateAttribute">
            <summary>
                Override the DDL template for a single document type
            </summary>
        </member>
        <member name="T:Marten.Schema.DocumentAliasAttribute">
            <summary>
                Used to alter the document type alias with Marten to
                avoid naming collisions in the underlying Postgresql
                schema from similarly named document
                types
            </summary>
        </member>
        <member name="M:Marten.Schema.DocumentMapping.IgnoreIndex(System.String)">
            <summary>
                This directs the schema migration functionality to ignore the presence of this named index
                on the document storage table
            </summary>
            <param name="indexName"></param>
        </member>
        <member name="M:Marten.Schema.DocumentMapping.ReferencedTypes">
            <summary>
                Access to all other document types that are linked to by foreign keys
                from this document type
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Schema.DocumentMapping.AddFullTextIndex(System.String,System.Action{Weasel.Postgresql.Tables.Indexes.FullTextIndexDefinition})">
            <summary>
                Adds a full text index
            </summary>
            <param name="regConfig">The dictionary to used by the 'to_tsvector' function, defaults to 'english'.</param>
            <param name="configure">Optional action to further configure the full text index</param>
            <remarks>
                See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-DOCUMENTS
            </remarks>
        </member>
        <member name="M:Marten.Schema.DocumentMapping.AddFullTextIndex(System.Reflection.MemberInfo[][],System.String,System.String)">
            <summary>
                Adds a full text index
            </summary>
            <param name="members">Document fields that should be use by full text index</param>
            <param name="regConfig">The dictionary to used by the 'to_tsvector' function, defaults to 'english'.</param>
            <remarks>
                See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-DOCUMENTS
            </remarks>
        </member>
        <member name="M:Marten.Schema.DocumentMapping.AddNgramIndex(System.Action{Marten.Schema.NgramIndex})">
            <summary>
                Adds a full text index
            </summary>
            <param name="regConfig">The dictionary to used by the 'to_tsvector' function, defaults to 'english'.</param>
            <param name="configure">Optional action to further configure the ngram index</param>
        </member>
        <member name="M:Marten.Schema.DocumentMapping.AddNgramIndex(System.Reflection.MemberInfo[],System.String)">
            <summary>
                Adds a full text index
            </summary>
            <param name="members">Document fields that should be use by ngram index</param>
        </member>
        <member name="M:Marten.Schema.DocumentMapping`1.Duplicate(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String,System.Nullable{NpgsqlTypes.NpgsqlDbType},System.Action{Marten.Schema.DocumentIndex},System.Boolean)">
            <summary>
                Marks a property or field on this document type as a searchable field that is also duplicated in the
                database document table
            </summary>
            <param name="expression"></param>
            <param name="pgType">Optional, overrides the Postgresql column type for the duplicated field</param>
            <param name="configure">
                Optional, allows you to customize the Postgresql database index configured for the duplicated
                field
            </param>
            <returns></returns>
        </member>
        <member name="M:Marten.Schema.DocumentMapping`1.Index(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Action{Marten.Schema.ComputedIndex})">
            <summary>
                Adds a computed index
            </summary>
            <param name="expression"></param>
            <param name="configure"></param>
        </member>
        <member name="M:Marten.Schema.DocumentMapping`1.Index(System.Collections.Generic.IReadOnlyCollection{System.Linq.Expressions.Expression{System.Func{`0,System.Object}}},System.Action{Marten.Schema.ComputedIndex})">
            <summary>
                Adds a computed index
            </summary>
            <param name="expressions"></param>
            <param name="configure"></param>
        </member>
        <member name="M:Marten.Schema.DocumentMapping`1.FullTextIndex(System.String,System.Linq.Expressions.Expression{System.Func{`0,System.Object}}[])">
            <summary>
                Adds a full text index
            </summary>
            <param name="regConfig">The dictionary to used by the 'to_tsvector' function, defaults to 'english'.</param>
            <param name="expressions">Document fields that should be use by full text index</param>
            <remarks>
                See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-DOCUMENTS
            </remarks>
        </member>
        <member name="M:Marten.Schema.DocumentMapping`1.NgramIndex(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
                Adds an ngram index.
            </summary>
            <param name="expression">Document field that should be use by ngram index</param>
        </member>
        <member name="M:Marten.Schema.DocumentMapping`1.NgramIndex(System.Action{Marten.Schema.NgramIndex},System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
                Adds a full text index with default region config set to 'english'
            </summary>
            <param name="expressions">Document fields that should be use by full text index</param>
        </member>
        <member name="T:Marten.Schema.DuplicateFieldAttribute">
            <summary>
                Mark a single property or field on a document as a duplicated, searchable field
                for optimized searching
            </summary>
        </member>
        <member name="P:Marten.Schema.DuplicateFieldAttribute.PgType">
            <summary>
                Use to override the Postgresql database column type of this searchable field
            </summary>
        </member>
        <member name="P:Marten.Schema.DuplicateFieldAttribute.DbType">
            <summary>
                Use to override the NpgsqlDbType used when querying with a parameter
                against the property
            </summary>
        </member>
        <member name="P:Marten.Schema.DuplicateFieldAttribute.IndexMethod">
            <summary>
                Specifies the type of index to create
            </summary>
        </member>
        <member name="P:Marten.Schema.DuplicateFieldAttribute.IndexName">
            <summary>
                Specify the name of the index explicity
            </summary>
        </member>
        <member name="P:Marten.Schema.DuplicateFieldAttribute.IndexSortOrder">
            <summary>
                Specifies the sort order of the index (only applicable to B-tree indexes)
            </summary>
        </member>
        <member name="T:Marten.Schema.GinIndexedAttribute">
            <summary>
                Adds a gin index to the JSONB data of a document
            </summary>
        </member>
        <member name="T:Marten.Schema.HiloSequenceAttribute">
            <summary>
                Use to customize the Hilo sequence generation for a single document type
            </summary>
        </member>
        <member name="M:Marten.Schema.IDatabaseCreationExpressions.ForTenant(System.String)">
            <param name="tenantId">If omitted, configure for default tenancy</param>
        </member>
        <member name="M:Marten.Schema.IDatabaseCreationExpressions.MaintenanceDatabase(System.String)">
            <summary>
                Setup the maintenance database to which to connect to prior to database creation.
                If not specified, the store connection string with 'postgres' as database is used.
            </summary>
        </member>
        <member name="T:Marten.Schema.Identity.CombGuidIdGeneration">
            <summary>
                Comb Guid Id Generation. More info http://www.informit.com/articles/article.aspx?p=25862
            </summary>
        </member>
        <member name="M:Marten.Schema.Identity.CombGuidIdGeneration.NewGuid(System.DateTimeOffset)">
            <summary>
                Returns a new Guid COMB, consisting of a random Guid combined with the provided timestamp.
            </summary>
        </member>
        <member name="T:Marten.Schema.Identity.GuidIdGeneration">
            <summary>
                Simple Guid identity generation
            </summary>
        </member>
        <member name="T:Marten.Schema.Identity.IIdGeneration">
            <summary>
                Identity generation strategy
            </summary>
        </member>
        <member name="P:Marten.Schema.Identity.IIdGeneration.KeyTypes">
            <summary>
                What types are supported by this strategy? Example: string, or int/long, or Guid
            </summary>
        </member>
        <member name="P:Marten.Schema.Identity.IIdGeneration.RequiresSequences">
            <summary>
                Does this strategy require HiLo sequences
            </summary>
        </member>
        <member name="M:Marten.Schema.Identity.IIdGeneration.GenerateCode(JasperFx.CodeGeneration.GeneratedMethod,Marten.Schema.DocumentMapping)">
            <summary>
                This method must be implemented to build and set the identity on
                a document
            </summary>
            <param name="method"></param>
            <param name="mapping"></param>
        </member>
        <member name="T:Marten.Schema.Identity.NoOpIdGeneration">
            <summary>
                User-assigned identity strategy
            </summary>
        </member>
        <member name="T:Marten.Schema.Identity.StringIdGeneration">
            <summary>
                Validating identity strategy for user supplied string identities
            </summary>
        </member>
        <member name="T:Marten.Schema.IdentityAttribute">
            <summary>
                Use to designate an Id property or field on a document type that doesn't follow the
                id/Id naming convention
            </summary>
        </member>
        <member name="M:Marten.Schema.IDocumentCleaner.DeleteAllDocuments">
            <summary>
                Deletes all existing document data in the underlying Postgresql database
            </summary>
        </member>
        <member name="M:Marten.Schema.IDocumentCleaner.DeleteAllDocumentsAsync(System.Threading.CancellationToken)">
            <summary>
                Deletes all existing document data in the underlying Postgresql database
            </summary>
        </member>
        <member name="M:Marten.Schema.IDocumentCleaner.DeleteDocumentsByType(System.Type)">
            <summary>
                Deletes all the existing document data for the specified document type
            </summary>
            <param name="documentType"></param>
        </member>
        <member name="M:Marten.Schema.IDocumentCleaner.DeleteDocumentsByTypeAsync(System.Type,System.Threading.CancellationToken)">
            <summary>
                Deletes all the existing document data for the specified document type
            </summary>
            <param name="documentType"></param>
        </member>
        <member name="M:Marten.Schema.IDocumentCleaner.DeleteDocumentsExcept(System.Type[])">
            <summary>
                Delete all document data *except* for the specified document types.
            </summary>
            <param name="documentTypes"></param>
        </member>
        <member name="M:Marten.Schema.IDocumentCleaner.DeleteDocumentsExceptAsync(System.Type[])">
            <summary>
                Delete all document data *except* for the specified document types.
            </summary>
            <param name="documentTypes"></param>
        </member>
        <member name="M:Marten.Schema.IDocumentCleaner.DeleteDocumentsExceptAsync(System.Threading.CancellationToken,System.Type[])">
            <summary>
                Delete all document data *except* for the specified document types.
            </summary>
            <param name="documentTypes"></param>
        </member>
        <member name="M:Marten.Schema.IDocumentCleaner.CompletelyRemove(System.Type)">
            <summary>
                Drop all the schema objects in the underlying Postgresql database for the specified
                document type
            </summary>
            <param name="documentType"></param>
        </member>
        <member name="M:Marten.Schema.IDocumentCleaner.CompletelyRemoveAsync(System.Type,System.Threading.CancellationToken)">
            <summary>
                Drop all the schema objects in the underlying Postgresql database for the specified
                document type
            </summary>
            <param name="documentType"></param>
        </member>
        <member name="M:Marten.Schema.IDocumentCleaner.CompletelyRemoveAll">
            <summary>
                Remove all Marten-related schema objects from the underlying Postgresql database
            </summary>
        </member>
        <member name="M:Marten.Schema.IDocumentCleaner.CompletelyRemoveAllAsync(System.Threading.CancellationToken)">
            <summary>
                Remove all Marten-related schema objects from the underlying Postgresql database
            </summary>
        </member>
        <member name="M:Marten.Schema.IDocumentCleaner.DeleteAllEventData">
            <summary>
                Completely deletes all the event and stream data
            </summary>
        </member>
        <member name="M:Marten.Schema.IDocumentCleaner.DeleteAllEventDataAsync(System.Threading.CancellationToken)">
            <summary>
                Completely deletes all the event and stream data
            </summary>
        </member>
        <member name="M:Marten.Schema.IDocumentCleaner.DeleteSingleEventStream(System.Guid,System.String)">
            <summary>
                Deletes all stream and event data for the designated streamId. Will
                not impact projected documents. USE WITH CAUTION!
            </summary>
            <param name="streamId"></param>
            <param name="tenantId">Optional tenant id for conjoined multi-tenancy</param>
        </member>
        <member name="M:Marten.Schema.IDocumentCleaner.DeleteSingleEventStreamAsync(System.Guid,System.String,System.Threading.CancellationToken)">
            <summary>
                Deletes all stream and event data for the designated streamId. Will
                not impact projected documents. USE WITH CAUTION!
            </summary>
            <param name="streamId"></param>
            <param name="tenantId">Optional tenant id for conjoined multi-tenancy</param>
        </member>
        <member name="M:Marten.Schema.IDocumentCleaner.DeleteSingleEventStream(System.String,System.String)">
            <summary>
                Deletes all stream and event data for the designated streamId. Will
                not impact projected documents. USE WITH CAUTION!
            </summary>
            <param name="streamId"></param>
            <param name="tenantId">Optional tenant id for conjoined multi-tenancy</param>
        </member>
        <member name="M:Marten.Schema.IDocumentCleaner.DeleteSingleEventStreamAsync(System.String,System.String,System.Threading.CancellationToken)">
            <summary>
                Deletes all stream and event data for the designated streamId. Will
                not impact projected documents. USE WITH CAUTION!
            </summary>
            <param name="streamId"></param>
            <param name="tenantId">Optional tenant id for conjoined multi-tenancy</param>
        </member>
        <member name="T:Marten.Schema.IInitialData">
            <summary>
                A set of initial data to pre-populate a DocumentStore at startup time
                Users will have to be responsible for not duplicating data
            </summary>
        </member>
        <member name="M:Marten.Schema.IInitialData.Populate(Marten.IDocumentStore,System.Threading.CancellationToken)">
            <summary>
                Apply the data loading
            </summary>
            <param name="store"></param>
        </member>
        <member name="T:Marten.Schema.IndexedCreatedAtAttribute">
            <summary>
                Creates an index on the predefined Last Modified column
            </summary>
        </member>
        <member name="T:Marten.Schema.IndexedLastModifiedAttribute">
            <summary>
                Creates an index on the predefined Last Modified column
            </summary>
        </member>
        <member name="F:Marten.Schema.Indexing.Unique.TenancyScope.Global">
            <summary>
                The uniqueness of this index should be global for all tenants
            </summary>
        </member>
        <member name="F:Marten.Schema.Indexing.Unique.TenancyScope.PerTenant">
            <summary>
                The uniqueness of this index should be within one tenant
            </summary>
        </member>
        <member name="T:Marten.Schema.ITenantDatabaseCreationExpressions">
            <summary>
                Specify options that are passed to CREATE DATABASE.
                <see href="https://www.postgresql.org/docs/current/static/sql-createdatabase.html">CREATE DATABASE</see>
                documentation for options.
            </summary>
        </member>
        <member name="M:Marten.Schema.ITenantDatabaseCreationExpressions.DropExisting(System.Boolean)">
            <summary>
                If database exists, it is dropped prior to re-creation.
            </summary>
            <param name="killConnections">Kill connections to database prior to drop</param>
            <remarks>Requires CREATEDB privilege</remarks>
        </member>
        <member name="M:Marten.Schema.ITenantDatabaseCreationExpressions.CheckAgainstPgDatabase">
            <summary>
                Check for database existence from pg_database, otherwise detect "INVALID CATALOG NAME" on connect
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Schema.ITenantDatabaseCreationExpressions.OnDatabaseCreated(System.Action{Npgsql.NpgsqlConnection})">
            <summary>
                Callback to be invoked after database creation
            </summary>
        </member>
        <member name="T:Marten.Schema.MartenAttribute">
            <summary>
                Base type of an Attribute that can be extended to add per field/property
                or per document type customization to the document storage
            </summary>
        </member>
        <member name="M:Marten.Schema.MartenAttribute.Modify(Marten.Schema.DocumentMapping)">
            <summary>
                Customize Document storage at the document level
            </summary>
            <param name="mapping"></param>
        </member>
        <member name="M:Marten.Schema.MartenAttribute.Modify(Marten.Schema.DocumentMapping,System.Reflection.MemberInfo)">
            <summary>
                Customize the Document storage for a single member
            </summary>
            <param name="mapping"></param>
            <param name="member"></param>
        </member>
        <member name="M:Marten.Schema.MartenAttribute.Register(System.Type,Marten.StoreOptions)">
            <summary>
            When used with the automatic type discovery (assembly scanning), this will be called
            to make registrations to the Marten configuration with the type that this attribute
            decorates
            </summary>
            <param name="discoveredType"></param>
            <param name="options"></param>
        </member>
        <member name="T:Marten.Schema.MartenDocumentAttribute">
            <summary>
            Just marks a type as being a persisted Marten document for the AutoRegister()
            feature
            </summary>
        </member>
        <member name="T:Marten.Schema.MartenEventAttribute">
            <summary>
            Just marks a type as being a persisted Marten event for the AutoRegister()
            feature
            </summary>
        </member>
        <member name="P:Marten.Schema.MartenEventAttribute.Alias">
            <summary>
            Use to override the Marten event type alias
            </summary>
        </member>
        <member name="T:Marten.Schema.LastModifiedMetadataAttribute">
            <summary>
                Direct Marten to copy the last modified metadata to this member
            </summary>
        </member>
        <member name="T:Marten.Schema.CreatedAtMetadataAttribute">
            <summary>
                Direct Marten to copy the created timestamp metadata to this member
            </summary>
        </member>
        <member name="T:Marten.Schema.TenantIdMetadataAttribute">
            <summary>
                Direct Marten to copy the tenant id metadata to this member
            </summary>
        </member>
        <member name="T:Marten.Schema.IsSoftDeletedMetadataAttributeAttribute">
            <summary>
                Direct Marten to copy the is soft deleted metadata to this member
            </summary>
        </member>
        <member name="T:Marten.Schema.SoftDeletedAtMetadataAttribute">
            <summary>
                Direct Marten to copy the soft deleted timestamp metadata to this member
            </summary>
        </member>
        <member name="T:Marten.Schema.DocumentTypeMetadataAttribute">
            <summary>
                Direct Marten to copy the hierarchical document type metadata to this member
            </summary>
        </member>
        <member name="T:Marten.Schema.MultiTenantedAttribute">
            <summary>
                Directs Marten to store this document type with conjoined multi-tenancy
            </summary>
        </member>
        <member name="T:Marten.Schema.NgramIndex">
            <summary>
                Implements an index that extracts ngrams for the specified field.
            </summary>
        </member>
        <member name="P:Marten.Schema.NgramIndex.DataConfig">
            <summary>
                Gets or sets the data config.
            </summary>
        </member>
        <member name="F:Marten.Schema.PropertySearching.JSON_Locator_Only">
            <summary>
                Uses Postgresql's JSON locators to search within JSON data
            </summary>
        </member>
        <member name="F:Marten.Schema.PropertySearching.ContainmentOperator">
            <summary>
                Tries to use Postgresql's @> containment operator to search within JSON data
            </summary>
        </member>
        <member name="T:Marten.Schema.PropertySearchingAttribute">
            <summary>
                Customize the PropertySearching mode of a single document type
            </summary>
        </member>
        <member name="T:Marten.Schema.SoftDeletedAttribute">
            <summary>
                Marks a document type as "soft deleted"
            </summary>
        </member>
        <member name="P:Marten.Schema.SoftDeletedAttribute.Indexed">
            <summary>
                Creates an index on deleted documents
            </summary>
        </member>
        <member name="T:Marten.Schema.StructuralTypedAttribute">
            <summary>
                Allows you to duplicate storage with other classes of the same name
            </summary>
        </member>
        <member name="M:Marten.Schema.SubClasses.AddHierarchy">
            <summary>
                Programmatically directs Marten to map all the subclasses of <cref name="T" /> to a hierarchy of types.
                <c>Unadvised in projects with many types.</c>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Schema.SubClasses.AddHierarchy(Marten.MappedType[])">
            <summary>
                Programmatically directs Marten to map all the subclasses of <cref name="T" /> to a hierarchy of types
            </summary>
            <param name="allSubclassTypes">
                All the subclass types of <cref name="T" /> that you wish to map.
                You can use either params of <see cref="T:System.Type" /> or <see cref="T:Marten.MappedType" /> or a mix, since Type can implicitly
                convert to MappedType (without an alias)
            </param>
            <returns></returns>
        </member>
        <member name="T:Marten.Schema.SubClassMapping">
            <summary>
                IDocumentMapping implementation for a document type that's a subclass of a parent type, and
                maps to the parent storage
            </summary>
        </member>
        <member name="F:Marten.Schema.UniqueIndexAttribute.IndexType">
            <summary>
                Specify Index type
            </summary>
        </member>
        <member name="F:Marten.Schema.UniqueIndexAttribute.TenancyScope">
            <summary>
                Specify Tenancy for unique index
            </summary>
        </member>
        <member name="P:Marten.Schema.UniqueIndexAttribute.IsConcurrent">
            <summary>
                Specifies the index should be created in the background and not block/lock
            </summary>
        </member>
        <member name="P:Marten.Schema.UniqueIndexAttribute.IndexMethod">
            <summary>
                Specifies the type of index to create
            </summary>
        </member>
        <member name="P:Marten.Schema.UniqueIndexAttribute.IndexName">
            <summary>
                Specify the name of the index explicity
            </summary>
        </member>
        <member name="F:Marten.Schema.UniqueIndexType.DuplicatedField">
            <summary>
                Create a duplicated field for this unique index
            </summary>
        </member>
        <member name="F:Marten.Schema.UniqueIndexType.Computed">
            <summary>
                Use a computed expression without duplicating the field for this unique index
            </summary>
        </member>
        <member name="T:Marten.Schema.UseOptimisticConcurrencyAttribute">
            <summary>
                Directs Marten to use optimistic versioning checks when updating this document type
            </summary>
        </member>
        <member name="T:Marten.Schema.VersionAttribute">
            <summary>
                Direct Marten to make a field or property on a document be
                set and tracked as the document version or as the aggregate version
                when used on a projected aggregate
            </summary>
        </member>
        <member name="M:Marten.HostExtensions.PauseAllDaemonsAsync(Microsoft.Extensions.Hosting.IHost)">
            <summary>
            Testing helper to pause all projection daemons in the system and completely
            disable the daemon projection assignments
            </summary>
            <param name="host"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.HostExtensions.ResumeAllDaemonsAsync(Microsoft.Extensions.Hosting.IHost)">
            <summary>
            Testing helper to resume all projection daemons in the system and restart
            the daemon projection assignments
            </summary>
            <param name="host"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.HostExtensions.DocumentStore(Microsoft.Extensions.Hosting.IHost)">
            <summary>
            Retrieve the Marten document store for this IHost
            </summary>
            <param name="host"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.HostExtensions.DocumentStore``1(Microsoft.Extensions.Hosting.IHost)">
            <summary>
            Retrieve the Marten document store for this IHost when working with multiple Marten databases
            </summary>
            <param name="host"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.HostExtensions.CleanAllMartenDataAsync(Microsoft.Extensions.Hosting.IHost)">
            <summary>
            Clean off all Marten data in the default DocumentStore for this host
            </summary>
            <param name="host"></param>
        </member>
        <member name="M:Marten.HostExtensions.CleanAllMartenDataAsync``1(Microsoft.Extensions.Hosting.IHost)">
            <summary>
            Clean off all Marten data in the specified DocumentStore for this host when working with multiple Marten databases
            </summary>
            <param name="host"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Marten.HostExtensions.ResetAllMartenDataAsync(Microsoft.Extensions.Hosting.IHost)">
            <summary>
            Call DocumentStore.ResetAllData() on the document store in this host
            </summary>
            <param name="host"></param>
        </member>
        <member name="M:Marten.HostExtensions.ResetAllMartenDataAsync``1(Microsoft.Extensions.Hosting.IHost)">
            <summary>
            Call DocumentStore.ResetAllData() on the document store in this host when working with multiple Marten databases
            </summary>
            <param name="host"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Marten.IAdvancedSql.QueryAsync``1(System.String,System.Threading.CancellationToken,System.Object[])">
            <summary>
                Asynchronously queries the document storage with the supplied SQL.
                The type parameter can be a document class, a scalar or any JSON-serializable class.
                If the result is a document, the SQL must contain a select with the required fields in the correct order,
                depending on the session type and the metadata the document might use, at least id and data must be
                selected.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="sql"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IAdvancedSql.QueryAsync``2(System.String,System.Threading.CancellationToken,System.Object[])">
            <summary>
                Asynchronously queries the document storage with the supplied SQL.
                The type parameters can be any document class, scalar or JSON-serializable class.
                For each result type parameter, the SQL SELECT statement must contain a ROW.
                For document types, the row must contain the required fields in the correct order,
                depending on the session type and the metadata the document might use, at least id and data must be
                provided.
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <param name="sql"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IAdvancedSql.QueryAsync``3(System.String,System.Threading.CancellationToken,System.Object[])">
            <summary>
                Asynchronously queries the document storage with the supplied SQL.
                The type parameters can be any document class, scalar or JSON-serializable class.
                For each result type parameter, the SQL SELECT statement must contain a ROW.
                For document types, the row must contain the required fields in the correct order,
                depending on the session type and the metadata the document might use, at least id and data must be
                provided.
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <param name="sql"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IAdvancedSql.Query``1(System.String,System.Object[])">
            <summary>
                Asynchronously queries the document storage with the supplied SQL.
                The type parameter can be a document class, a scalar or any JSON-serializable class.
                If the result is a document, the SQL must contain a select with the required fields in the correct order,
                depending on the session type and the metadata the document might use, at least id and data must be
                selected.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="sql"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IAdvancedSql.Query``2(System.String,System.Object[])">
            <summary>
                Asynchronously queries the document storage with the supplied SQL.
                The type parameters can be any document class, scalar or JSON-serializable class.
                For each result type parameter, the SQL SELECT statement must contain a ROW.
                For document types, the row must contain the required fields in the correct order,
                depending on the session type and the metadata the document might use, at least id and data must be
                provided.
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <param name="sql"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IAdvancedSql.Query``3(System.String,System.Object[])">
            <summary>
                Asynchronously queries the document storage with the supplied SQL.
                The type parameters can be any document class, scalar or JSON-serializable class.
                For each result type parameter, the SQL SELECT statement must contain a ROW.
                For document types, the row must contain the required fields in the correct order,
                depending on the session type and the metadata the document might use, at least id and data must be
                provided.
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <param name="sql"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IAdvancedSql.StreamAsync``1(System.String,System.Threading.CancellationToken,System.Object[])">
            <summary>
                Asynchronously queries the document storage with the supplied SQL.
                The type parameters can be any document class, scalar or JSON-serializable class.
                For each result type parameter, the SQL SELECT statement must contain a ROW.
                For document types, the row must contain the required fields in the correct order,
                depending on the session type and the metadata the document might use, at least id and data must be
                provided.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="sql"></param>
            <param name="parameters"></param>
            <returns>An async enumerable iterating over the results</returns>
        </member>
        <member name="M:Marten.IAdvancedSql.StreamAsync``2(System.String,System.Threading.CancellationToken,System.Object[])">
            <summary>
                Asynchronously queries the document storage with the supplied SQL.
                The type parameters can be any document class, scalar or JSON-serializable class.
                For each result type parameter, the SQL SELECT statement must contain a ROW.
                For document types, the row must contain the required fields in the correct order,
                depending on the session type and the metadata the document might use, at least id and data must be
                provided.
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <param name="sql"></param>
            <param name="parameters"></param>
            <returns>An async enumerable iterating over the list of result tuples</returns>
        </member>
        <member name="M:Marten.IAdvancedSql.StreamAsync``3(System.String,System.Threading.CancellationToken,System.Object[])">
            <summary>
                Asynchronously queries the document storage with the supplied SQL.
                The type parameters can be any document class, scalar or JSON-serializable class.
                For each result type parameter, the SQL SELECT statement must contain a ROW.
                For document types, the row must contain the required fields in the correct order,
                depending on the session type and the metadata the document might use, at least id and data must be
                provided.
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <param name="sql"></param>
            <param name="parameters"></param>
            <returns>An async enumerable iterating over the list of result tuples</returns>
        </member>
        <member name="T:Marten.IConnectionFactory">
            <summary>
                Factory interface to customize the construction of an NpgsqlConnection
                to the Postgresql database
            </summary>
        </member>
        <member name="M:Marten.IConnectionFactory.Create">
            <summary>
                Create a new, isolated connection to the Postgresql database
            </summary>
            <returns></returns>
        </member>
        <member name="T:Marten.IDiagnostics">
            <summary>
                Access to diagnostics about the current Marten IDocumentStore
            </summary>
        </member>
        <member name="M:Marten.IDiagnostics.PreviewCommand``2(Marten.Linq.ICompiledQuery{``0,``1},Marten.DocumentTracking)">
            <summary>
                Preview the database command that will be executed for this compiled query
                object
            </summary>
            <typeparam name="TDoc"></typeparam>
            <typeparam name="TReturn"></typeparam>
            <param name="query"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IDiagnostics.ExplainPlan``2(Marten.Linq.ICompiledQuery{``0,``1})">
            <summary>
                Find the Postgresql EXPLAIN PLAN for this compiled query
            </summary>
            <typeparam name="TDoc"></typeparam>
            <typeparam name="TReturn"></typeparam>
            <param name="query"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IDiagnostics.GetPostgresVersion">
            <summary>
                Method to fetch Postgres server version
            </summary>
            <returns>Returns version</returns>
        </member>
        <member name="T:Marten.IDocumentOperations">
            <summary>
                Basic storage operations for document types, but cannot initiate any actual writes
            </summary>
        </member>
        <member name="M:Marten.IDocumentOperations.Delete``1(``0)">
            <summary>
                Mark this entity for deletion upon the next call to SaveChanges()
            </summary>
            <typeparam name="T"></typeparam>
            <param name="entity"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.Delete``1(System.Int32)">
            <summary>
                Mark an entity of type T with either a numeric or Guid id for deletion upon the next call to SaveChanges()
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.Delete``1(System.Int64)">
            <summary>
                Mark an entity of type T with either a numeric or Guid id for deletion upon the next call to SaveChanges()
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.Delete``1(System.Guid)">
            <summary>
                Mark an entity of type T with either a numeric or Guid id for deletion upon the next call to SaveChanges()
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.Delete``1(System.String)">
            <summary>
                Mark an entity of type T with a string id for deletion upon the next call to SaveChanges()
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.DeleteWhere``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
                Bulk delete all documents of type T matching the expression condition
            </summary>
            <typeparam name="T"></typeparam>
            <param name="expression"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.DeleteObjects(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
                Delete an enumerable of potentially mixed documents
            </summary>
            <param name="documents"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.Store``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
                Explicitly marks multiple documents as needing to be inserted or updated upon the next call to SaveChanges()
            </summary>
            <typeparam name="T"></typeparam>
            <param name="entity"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.Store``1(``0[])">
            <summary>
                Explicitly marks one or more documents as needing to be inserted or updated upon the next call to SaveChanges()
            </summary>
            <typeparam name="T"></typeparam>
            <param name="entity"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.UpdateExpectedVersion``1(``0,System.Guid)">
            <summary>
                Explicitly marks a document as needing to be updated and supplies the
                current known version for the purpose of optimistic versioning checks
            </summary>
            <typeparam name="T"></typeparam>
            <param name="entity"></param>
            <param name="version"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.UpdateRevision``1(``0,System.Int32)">
            <summary>
            Explicitly marks a document as needing to be updated and supplies the
            *new* revision for the purpose of optimistic versioning checks. This operation
            will be rejected and cause a ConcurrencyException on SaveChanges() if the revision in the database is greater or equal to the given
            revision
            </summary>
            <typeparam name="T"></typeparam>
            <param name="entity"></param>
            <param name="revision"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.TryUpdateRevision``1(``0,System.Int32)">
            <summary>
            Explicitly marks a document as needing to be updated and supplies the
            *new* revision for the purpose of optimistic versioning checks. This operation
            will do nothing  if the revision in the database is greater or equal to the given
            revision
            </summary>
            <param name="entity"></param>
            <param name="revision"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Marten.IDocumentOperations.StoreObjects(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
                Store an enumerable of potentially mixed documents
            </summary>
            <param name="documents"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.QueueOperation(Marten.Internal.Operations.IStorageOperation)">
            <summary>
                Catch all mechanism to add additional database calls to the batched
                updates in SaveChanges()/SaveChangesAsync()
            </summary>
            <param name="storageOperation"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.Insert``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
                Explicitly marks a document as needing to be inserted upon the next call to SaveChanges().
                Will throw an exception if the document already exists
            </summary>
            <typeparam name="T"></typeparam>
            <param name="entity"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.Insert``1(``0[])">
            <summary>
                Explicitly marks a document as needing to be inserted upon the next call to SaveChanges().
                Will throw an exception if the document already exists
            </summary>
            <typeparam name="T"></typeparam>
            <param name="entity"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.Update``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
                Explicitly marks a document as needing to be updated upon the next call to SaveChanges().
                Will throw an exception if the document does not already exists
            </summary>
            <typeparam name="T"></typeparam>
            <param name="entity"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.Update``1(``0[])">
            <summary>
                Explicitly marks a document as needing to be updated upon the next call to SaveChanges().
                Will throw an exception if the document does not already exists
            </summary>
            <typeparam name="T"></typeparam>
            <param name="entity"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.InsertObjects(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
                Insert an enumerable of potentially mixed documents. Will throw exceptions
                if a document overwrite is detected
            </summary>
            <param name="documents"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.HardDelete``1(``0)">
            <summary>
                Mark this entity for a "hard" deletion upon the next call to SaveChanges()
                that will delete the underlying database row
            </summary>
            <typeparam name="T"></typeparam>
            <param name="entity"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.HardDelete``1(System.Int32)">
            <summary>
                Mark an entity of type T with either a numeric or Guid id for "hard" deletion upon the next call to SaveChanges()
                that will delete the underlying database row
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.HardDelete``1(System.Int64)">
            <summary>
                Mark an entity of type T with either a numeric or Guid id for hard deletion upon the next call to SaveChanges()
                that will delete the underlying database row
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.HardDelete``1(System.Guid)">
            <summary>
                Mark an entity of type T with either a numeric or Guid id for hard deletion upon the next call to SaveChanges()
                that will delete the underlying database row
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.HardDelete``1(System.String)">
            <summary>
                Mark an entity of type T with a string id for hard deletion upon the next call to SaveChanges()
                that will delete the underlying database row
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.HardDeleteWhere``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
                Bulk hard delete all documents of type T matching the expression condition
                that will delete the underlying database rows
            </summary>
            <typeparam name="T"></typeparam>
            <param name="expression"></param>
        </member>
        <member name="M:Marten.IDocumentOperations.UndoDeleteWhere``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
                For soft-deleted document types, this is a one sized fits all mechanism to reverse the
                soft deletion tracking
            </summary>
            <param name="expression"></param>
            <typeparam name="T"></typeparam>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Marten.IDocumentOperations.QueueSqlCommand(System.String,System.Object[])">
            <summary>
                Registers a SQL command to be executed with the underlying unit of work as part of the batched command.
                Use "?" placeholders to denote parameter values
            </summary>
            <param name="sql"></param>
            <param name="parameterValues"></param>
        </member>
        <member name="T:Marten.IDocumentPolicy">
            <summary>
                Represents a pluggable configuration convention for all persisted documents
            </summary>
        </member>
        <member name="P:Marten.IDocumentSchemaResolver.DatabaseSchemaName">
            <summary>
                The schema name used to store the documents.
            </summary>
        </member>
        <member name="P:Marten.IDocumentSchemaResolver.EventsSchemaName">
            <summary>
                The database schema name for event related tables. By default this
                is the same schema as the document storage
            </summary>
        </member>
        <member name="M:Marten.IDocumentSchemaResolver.For``1(System.Boolean)">
            <summary>
                Find the database name of the table backing <typeparamref name="TDocument"/>. Supports documents and projections.
            </summary>
            <typeparam name="TDocument">The document or projection to look up.</typeparam>
            <param name="qualified" default="true">
                When true (default) the qualified name is returned (schema and table name).
                Otherwise only the table name is returned.
            </param>
            <returns>The name of <typeparamref name="TDocument"/> in the database.</returns>
        </member>
        <member name="M:Marten.IDocumentSchemaResolver.For(System.Type,System.Boolean)">
            <summary>
                Find the database name of the table backing <typeparamref name="TDocument"/>. Supports documents and projections.
            </summary>
            <param name="documentType">The document type</param>
            <param name="qualified" default="true">
                When true (default) the qualified name is returned (schema and table name).
                Otherwise only the table name is returned.
            </param>
            <returns>The name of <typeparamref name="TDocument"/> in the database.</returns>
        </member>
        <member name="M:Marten.IDocumentSchemaResolver.ForEvents(System.Boolean)">
            <summary>
                Find the database name of the table backing the events table. Supports documents and projections.
            </summary>
            <param name="qualified" default="true">
                When true (default) the qualified name is returned (schema and table name).
                Otherwise only the table name is returned.
            </param>
            <returns>The name of events table in the database.</returns>
        </member>
        <member name="M:Marten.IDocumentSchemaResolver.ForStreams(System.Boolean)">
            <summary>
                Find the database name of the table backing the event streams table. Supports documents and projections.
            </summary>
            <param name="qualified" default="true">
                When true (default) the qualified name is returned (schema and table name).
                Otherwise only the table name is returned.
            </param>
            <returns>The name of event streams table in the database.</returns>
        </member>
        <member name="M:Marten.IDocumentSchemaResolver.ForEventProgression(System.Boolean)">
            <summary>
                Find the database name of the table backing the event progression table. Supports documents and projections.
            </summary>
            <param name="qualified" default="true">
                When true (default) the qualified name is returned (schema and table name).
                Otherwise only the table name is returned.
            </param>
            <returns>The name of event progression table in the database.</returns>
        </member>
        <member name="T:Marten.IDocumentSession">
            <summary>
                Interface for querying a document database and unit of work updates
            </summary>
        </member>
        <member name="M:Marten.IDocumentSession.BeginTransaction">
            <summary>
            Force this session to start a connection and transaction. This will make the session do consistent reads through the transaction. Is
            idempotent.
            </summary>
        </member>
        <member name="M:Marten.IDocumentSession.BeginTransactionAsync(System.Threading.CancellationToken)">
            <summary>
            Force this session to start a connection and transaction. This will make the session do consistent reads through the transaction. Is
            idempotent.
            </summary>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="P:Marten.IDocumentSession.PendingChanges">
            <summary>
                List of all the pending changes to this IDocumentSession
            </summary>
        </member>
        <member name="P:Marten.IDocumentSession.Events">
            <summary>
                Access to the event store functionality
            </summary>
        </member>
        <member name="P:Marten.IDocumentSession.Concurrency">
            <summary>
                Override whether or not this session honors optimistic concurrency checks
            </summary>
        </member>
        <member name="P:Marten.IDocumentSession.Listeners">
            <summary>
                Writeable list of the listeners for this session
            </summary>
        </member>
        <member name="P:Marten.IDocumentSession.LastModifiedBy">
            <summary>
                Optional metadata describing the user name or
                process name for this unit of work
            </summary>
        </member>
        <member name="M:Marten.IDocumentSession.SaveChanges">
            <summary>
                Saves all the pending changes and deletions to the server in a single Postgresql transaction.
            </summary>
        </member>
        <member name="M:Marten.IDocumentSession.SaveChangesAsync(System.Threading.CancellationToken)">
            <summary>
                Asynchronously saves all the pending changes and deletions to the server in a single Postgresql transaction
            </summary>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentSession.Eject``1(``0)">
            <summary>
                Completely remove the document from this session's unit of work tracking and identity map caching
            </summary>
            <typeparam name="T"></typeparam>
            <param name="document"></param>
        </member>
        <member name="M:Marten.IDocumentSession.EjectAllOfType(System.Type)">
            <summary>
                Completely remove all the documents of given type from this session's unit of work tracking and identity map
                caching
            </summary>
            <typeparam name="T"></typeparam>
            <param name="type"></param>
        </member>
        <member name="M:Marten.IDocumentSession.SetHeader(System.String,System.Object)">
            <summary>
                Set an optional user defined metadata value by key
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:Marten.IDocumentSession.GetHeader(System.String)">
            <summary>
                Get an optional user defined metadata value by key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentSession.ForTenant(System.String)">
            <summary>
                Access data from another tenant and apply document or event updates to this
                IDocumentSession for a separate tenant
            </summary>
            <param name="tenantId"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentSession.EjectAllPendingChanges">
            <summary>
                Remove all queued operations in this unit of work, but will not impact any existing identity map. I.e., all
                document stores,
                event appends, etc.
            </summary>
        </member>
        <member name="M:Marten.ILoadByKeys`1.ById``1(``0[])">
            <summary>
                Supply the document id's to load
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.ILoadByKeys`1.ByIdAsync``1(``0[])">
            <summary>
                Supply the document id's to load asynchronously
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.ILoadByKeys`1.ById``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
                Supply the document id's to load
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.ILoadByKeys`1.ByIdAsync``1(System.Collections.Generic.IEnumerable{``0},System.Threading.CancellationToken)">
            <summary>
                Supply the document id's to load asynchronously
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="keys"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IChangeListener.AfterCommitAsync(Marten.IDocumentSession,Marten.Services.IChangeSet,System.Threading.CancellationToken)">
            <summary>
            Used to carry out actions on potentially changed projected documents generated and updated
            during the execution of asynchronous projections. This will give you "at most once" delivery guarantees
            </summary>
            <param name="session"></param>
            <param name="commit"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IChangeListener.BeforeCommitAsync(Marten.IDocumentSession,Marten.Services.IChangeSet,System.Threading.CancellationToken)">
            <summary>
            Used to carry out actions on potentially changed projected documents generated and updated
            during the execution of asynchronous projections. This will execute *before* database changes
            are committed. Use this for "at least once" delivery guarantees.
            </summary>
            <param name="session"></param>
            <param name="commit"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="T:Marten.IDocumentSessionListener">
            <summary>
                Used to listen to and intercept operations within an IDocumentSession.SaveChanges()/SaveChangesAsync()
                operation
            </summary>
        </member>
        <member name="M:Marten.IDocumentSessionListener.AfterCommitAsync(Marten.IDocumentSession,Marten.Services.IChangeSet,System.Threading.CancellationToken)">
            <summary>
                After an IDocumentSession is committed
            </summary>
            <param name="session"></param>
            <param name="commit"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentSessionListener.BeforeSaveChanges(Marten.IDocumentSession)">
            <summary>
                Called just after IDocumentSession.SaveChanges() is called, but before
                any database calls are made
            </summary>
            <param name="session"></param>
        </member>
        <member name="M:Marten.IDocumentSessionListener.BeforeSaveChangesAsync(Marten.IDocumentSession,System.Threading.CancellationToken)">
            <summary>
                Called just after IDocumentSession.SaveChanges() is called,
                but before any database calls are made
            </summary>
            <param name="session"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentSessionListener.AfterCommit(Marten.IDocumentSession,Marten.Services.IChangeSet)">
            <summary>
                After an IDocumentSession is committed
            </summary>
            <param name="session"></param>
            <param name="commit"></param>
        </member>
        <member name="M:Marten.IDocumentSessionListener.DocumentLoaded(System.Object,System.Object)">
            <summary>
                Called after a document is loaded
            </summary>
        </member>
        <member name="M:Marten.IDocumentSessionListener.DocumentAddedForStorage(System.Object,System.Object)">
            <summary>
                Called after a document is explicitly added to a session
                as a staged insert or update
            </summary>
        </member>
        <member name="T:Marten.DocumentSessionListenerBase">
            <summary>
                Base class to help create custom IDocumentSessionListener classes
            </summary>
        </member>
        <member name="T:Marten.IDocumentStore">
            <summary>
                The core abstraction for a Marten document and event store. This should probably be scoped as a
                singleton in your system
            </summary>
        </member>
        <member name="P:Marten.IDocumentStore.Options">
            <summary>
                Information about the current configuration of this IDocumentStore
            </summary>
        </member>
        <member name="P:Marten.IDocumentStore.Storage">
            <summary>
                Administration and diagnostic information about the underlying database storage
            </summary>
        </member>
        <member name="P:Marten.IDocumentStore.Advanced">
            <summary>
                Infrequently used operations like document cleaning and the initial store configuration
            </summary>
        </member>
        <member name="P:Marten.IDocumentStore.Diagnostics">
            <summary>
                Access to Marten's diagnostics for trouble shooting
            </summary>
        </member>
        <member name="M:Marten.IDocumentStore.BulkInsert``1(System.Collections.Generic.IReadOnlyCollection{``0},Marten.BulkInsertMode,System.Int32)">
            <summary>
                Uses Postgresql's COPY ... FROM STDIN BINARY feature to efficiently store
                a large number of documents of type "T" to the database. This operation is transactional.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="documents"></param>
            <param name="mode"></param>
            <param name="batchSize"></param>
        </member>
        <member name="M:Marten.IDocumentStore.BulkInsertEnlistTransaction``1(System.Collections.Generic.IReadOnlyCollection{``0},System.Transactions.Transaction,Marten.BulkInsertMode,System.Int32)">
            <summary>
                Uses Postgresql's COPY ... FROM STDIN BINARY feature to efficiently store
                a large number of documents of type "T" to the database. This operation enlists an existing transaction.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="documents"></param>
            <param name="transaction">an existing transaction</param>
            <param name="mode"></param>
            <param name="batchSize"></param>
        </member>
        <member name="M:Marten.IDocumentStore.BulkInsert``1(System.String,System.Collections.Generic.IReadOnlyCollection{``0},Marten.BulkInsertMode,System.Int32)">
            <summary>
                Uses Postgresql's COPY ... FROM STDIN BINARY feature to efficiently store
                a large number of documents of type "T" to the database. This operation is transactional.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="tenantId"></param>
            <param name="documents"></param>
            <param name="mode"></param>
            <param name="batchSize"></param>
        </member>
        <member name="M:Marten.IDocumentStore.BulkInsertAsync``1(System.Collections.Generic.IReadOnlyCollection{``0},Marten.BulkInsertMode,System.Int32,System.Threading.CancellationToken)">
            <summary>
                Uses Postgresql's COPY ... FROM STDIN BINARY feature to efficiently store
                a large number of documents of type "T" to the database. This operation is transactional.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="documents"></param>
            <param name="mode"></param>
            <param name="batchSize"></param>
        </member>
        <member name="M:Marten.IDocumentStore.BulkInsertEnlistTransactionAsync``1(System.Collections.Generic.IReadOnlyCollection{``0},System.Transactions.Transaction,Marten.BulkInsertMode,System.Int32,System.Threading.CancellationToken)">
            <summary>
                Uses Postgresql's COPY ... FROM STDIN BINARY feature to efficiently store
                a large number of documents of type "T" to the database. This operation enlists an existing transaction.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="documents"></param>
            <param name="transaction">an existing transaction</param>
            <param name="mode"></param>
            <param name="batchSize"></param>
        </member>
        <member name="M:Marten.IDocumentStore.BulkInsertAsync``1(System.String,System.Collections.Generic.IReadOnlyCollection{``0},Marten.BulkInsertMode,System.Int32,System.Threading.CancellationToken)">
            <summary>
                Uses Postgresql's COPY ... FROM STDIN BINARY feature to efficiently store
                a large number of documents of type "T" to the database. This operation is transactional.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="tenantId"></param>
            <param name="documents"></param>
            <param name="mode"></param>
            <param name="batchSize"></param>
        </member>
        <member name="M:Marten.IDocumentStore.OpenSession(Marten.DocumentTracking,System.Data.IsolationLevel)">
            <summary>
                Open a new IDocumentSession with the supplied DocumentTracking.
                "IdentityOnly" is the default.
            </summary>
            <param name="tracking"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.OpenSession(System.String,Marten.DocumentTracking,System.Data.IsolationLevel)">
            <summary>
                Open a new IDocumentSession with the supplied DocumentTracking.
                "IdentityOnly" is the default.
            </summary>
            <param name="tracking"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.OpenSession(Marten.Services.SessionOptions)">
            <summary>
                Open a new IDocumentSession with the supplied options
            </summary>
            <param name="options">Additional options for session</param>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.OpenSerializableSessionAsync(Marten.Services.SessionOptions,System.Threading.CancellationToken)">
            <summary>
                Open a new IDocumentSession with the supplied options and immediately open
                the database connection and start the transaction for the session. This is approapriate
                for Serializable transaction sessions
            </summary>
            <param name="options"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.LightweightSession(System.Data.IsolationLevel)">
            <summary>
                Convenience method to create a new "lightweight" IDocumentSession with no IdentityMap
                or automatic dirty checking
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.LightweightSession(System.String,System.Data.IsolationLevel)">
            <summary>
                Convenience method to create a new "lightweight" IDocumentSession with no IdentityMap
                or automatic dirty checking
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.LightweightSession(Marten.Services.SessionOptions)">
            <summary>
                Convenience method to create a new "lightweight" IDocumentSession with no IdentityMap
                or automatic dirty checking
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.LightweightSerializableSessionAsync(System.Threading.CancellationToken)">
            <summary>
                Convenience method to create a new "lightweight" IDocumentSession with no IdentityMap
                or automatic dirty checking
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.LightweightSerializableSessionAsync(System.String,System.Threading.CancellationToken)">
            <summary>
                Convenience method to create a new "lightweight" IDocumentSession with no IdentityMap
                or automatic dirty checking
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.LightweightSerializableSessionAsync(Marten.Services.SessionOptions,System.Threading.CancellationToken)">
            <summary>
                Convenience method to create a new "lightweight" IDocumentSession with no IdentityMap
                or automatic dirty checking
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.IdentitySession(System.Data.IsolationLevel)">
            <summary>
                Convenience method to create an IDocumentSession with IdentityMap but without automatic
                dirty checking
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.IdentitySession(System.String,System.Data.IsolationLevel)">
            <summary>
                Convenience method to create an IDocumentSession with IdentityMap but without automatic
                dirty checking
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.IdentitySession(Marten.Services.SessionOptions)">
            <summary>
                Convenience method to create an IDocumentSession with IdentityMap but without automatic
                dirty checking
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.IdentitySerializableSessionAsync(System.Threading.CancellationToken)">
            <summary>
                Convenience method to create an IDocumentSession with IdentityMap but without automatic
                dirty checking
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.IdentitySerializableSessionAsync(System.String,System.Threading.CancellationToken)">
            <summary>
                Convenience method to create an IDocumentSession with IdentityMap but without automatic
                dirty checking
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.IdentitySerializableSessionAsync(Marten.Services.SessionOptions,System.Threading.CancellationToken)">
            <summary>
                Convenience method to create an IDocumentSession with IdentityMap but without automatic
                dirty checking
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.DirtyTrackedSession(System.Data.IsolationLevel)">
            <summary>
                Convenience method to create an IDocumentSession with both IdentityMap and automatic
                dirty checking
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.DirtyTrackedSession(System.String,System.Data.IsolationLevel)">
            <summary>
                Convenience method to create an IDocumentSession with both IdentityMap and automatic
                dirty checking
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.DirtyTrackedSession(Marten.Services.SessionOptions)">
            <summary>
                Convenience method to create an IDocumentSession with both IdentityMap and automatic
                dirty checking
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.DirtyTrackedSerializableSessionAsync(System.Threading.CancellationToken)">
            <summary>
                Convenience method to create an IDocumentSession with both IdentityMap and automatic
                dirty checking
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.DirtyTrackedSerializableSessionAsync(System.String,System.Threading.CancellationToken)">
            <summary>
                Convenience method to create an IDocumentSession with both IdentityMap and automatic
                dirty checking
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.DirtyTrackedSerializableSessionAsync(Marten.Services.SessionOptions,System.Threading.CancellationToken)">
            <summary>
                Convenience method to create an IDocumentSession with both IdentityMap and automatic
                dirty checking
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.QuerySession">
            <summary>
                Opens a read-only IQuerySession to the current document store for efficient
                querying without any underlying object tracking.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.QuerySession(System.String)">
            <summary>
                Opens a read-only IQuerySession to the current document store for efficient
                querying without any underlying object tracking.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.QuerySession(Marten.Services.SessionOptions)">
            <summary>
                Opens a read-only IQuerySession to the current document store for efficient
                querying without any underlying object tracking.
            </summary>
            <param name="options">Additional options for session. DocumentTracking is not applicable for IQuerySession.</param>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.QuerySerializableSessionAsync(System.Threading.CancellationToken)">
            <summary>
                Opens a read-only IQuerySession to the current document store for efficient
                querying without any underlying object tracking.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.QuerySerializableSessionAsync(System.String,System.Threading.CancellationToken)">
            <summary>
                Opens a read-only IQuerySession to the current document store for efficient
                querying without any underlying object tracking.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.QuerySerializableSessionAsync(Marten.Services.SessionOptions,System.Threading.CancellationToken)">
            <summary>
                Opens a read-only IQuerySession to the current document store for efficient
                querying without any underlying object tracking.
            </summary>
            <param name="options">Additional options for session. DocumentTracking is not applicable for IQuerySession.</param>
            <returns></returns>
        </member>
        <member name="M:Marten.IDocumentStore.BulkInsertDocuments(System.Collections.Generic.IEnumerable{System.Object},Marten.BulkInsertMode,System.Int32)">
            <summary>
                Bulk insert a potentially mixed enumerable of document types
            </summary>
            <param name="documents"></param>
            <param name="mode"></param>
            <param name="batchSize"></param>
        </member>
        <member name="M:Marten.IDocumentStore.BulkInsertDocuments(System.String,System.Collections.Generic.IEnumerable{System.Object},Marten.BulkInsertMode,System.Int32)">
            <summary>
                Bulk insert a potentially mixed enumerable of document types
            </summary>
            <param name="documents"></param>
            <param name="mode"></param>
            <param name="batchSize"></param>
        </member>
        <member name="M:Marten.IDocumentStore.BulkInsertDocumentsAsync(System.Collections.Generic.IEnumerable{System.Object},Marten.BulkInsertMode,System.Int32,System.Threading.CancellationToken)">
            <summary>
                Bulk insert a potentially mixed enumerable of document types
            </summary>
            <param name="documents"></param>
            <param name="mode"></param>
            <param name="batchSize"></param>
        </member>
        <member name="M:Marten.IDocumentStore.BulkInsertDocumentsAsync(System.String,System.Collections.Generic.IEnumerable{System.Object},Marten.BulkInsertMode,System.Int32,System.Threading.CancellationToken)">
            <summary>
                Bulk insert a potentially mixed enumerable of document types
            </summary>
            <param name="documents"></param>
            <param name="mode"></param>
            <param name="batchSize"></param>
        </member>
        <member name="M:Marten.IDocumentStore.BuildProjectionDaemonAsync(System.String,Microsoft.Extensions.Logging.ILogger)">
            <summary>
                Build a new instance of the asynchronous projection daemon to use interactively
                in your own code
            </summary>
            <param name="tenantIdOrDatabaseIdentifier">
                If using multi-tenancy with multiple databases, supplying this will choose
                the database to target
            </param>
            <param name="logger">Override the logger inside this instance of the async daemon</param>
            <returns></returns>
        </member>
        <member name="M:Marten.IJsonLoader.FindById``1(System.String)">
            <summary>
                Load or find only the document json by string id for a document of type T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IJsonLoader.FindById``1(System.Int32)">
            <summary>
                Load or find only the document json by numeric or Guid id for a document of type T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IJsonLoader.FindById``1(System.Int64)">
            <summary>
                Load or find only the document json by numeric or Guid id for a document of type T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IJsonLoader.FindById``1(System.Guid)">
            <summary>
                Load or find only the document json by numeric or Guid id for a document of type T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IJsonLoader.FindByIdAsync``1(System.String,System.Threading.CancellationToken)">
            <summary>
                Asynchronously load or find only the document json by string id for a document of type T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IJsonLoader.FindByIdAsync``1(System.Int32,System.Threading.CancellationToken)">
            <summary>
                Asynchronously load or find only the document json by numeric or Guid id for a document of type T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IJsonLoader.FindByIdAsync``1(System.Int64,System.Threading.CancellationToken)">
            <summary>
                Asynchronously load or find only the document json by numeric or Guid id for a document of type T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IJsonLoader.FindByIdAsync``1(System.Guid,System.Threading.CancellationToken)">
            <summary>
                Asynchronously load or find only the document json by numeric or Guid id for a document of type T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IJsonLoader.StreamById``1(System.Int32,System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
                Write the raw persisted JSON for a single document found by id to the supplied stream. Returns false
                if the document cannot be found
            </summary>
            <param name="id"></param>
            <param name="destination"></param>
            <param name="token"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IJsonLoader.StreamById``1(System.Int64,System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
                Write the raw persisted JSON for a single document found by id to the supplied stream. Returns false
                if the document cannot be found
            </summary>
            <param name="id"></param>
            <param name="destination"></param>
            <param name="token"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IJsonLoader.StreamById``1(System.String,System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
                Write the raw persisted JSON for a single document found by id to the supplied stream. Returns false
                if the document cannot be found
            </summary>
            <param name="id"></param>
            <param name="destination"></param>
            <param name="token"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IJsonLoader.StreamById``1(System.Guid,System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
                Write the raw persisted JSON for a single document found by id to the supplied stream. Returns false
                if the document cannot be found
            </summary>
            <param name="id"></param>
            <param name="destination"></param>
            <param name="token"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:Marten.IMartenLogger">
            <summary>
                Records command usage, schema changes, and sessions within Marten
            </summary>
        </member>
        <member name="M:Marten.IMartenLogger.StartSession(Marten.IQuerySession)">
            <summary>
                Called when the session is initialized
            </summary>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IMartenLogger.SchemaChange(System.String)">
            <summary>
                Capture any DDL executed at runtime by Marten
            </summary>
            <param name="sql"></param>
        </member>
        <member name="T:Marten.IMartenSessionLogger">
            <summary>
                Use to create custom logging within an IQuerySession or IDocumentSession
            </summary>
        </member>
        <member name="M:Marten.IMartenSessionLogger.LogSuccess(Npgsql.NpgsqlCommand)">
            <summary>
                Log a command that executed successfully
            </summary>
            <param name="command"></param>
        </member>
        <member name="M:Marten.IMartenSessionLogger.LogFailure(Npgsql.NpgsqlCommand,System.Exception)">
            <summary>
                Log a command that failed
            </summary>
            <param name="command"></param>
            <param name="ex"></param>
        </member>
        <member name="M:Marten.IMartenSessionLogger.LogSuccess(Npgsql.NpgsqlBatch)">
            <summary>
                Log a command that executed successfully
            </summary>
            <param name="batch"></param>
        </member>
        <member name="M:Marten.IMartenSessionLogger.LogFailure(Npgsql.NpgsqlBatch,System.Exception)">
            <summary>
                Log a batch that failed
            </summary>
            <param name="batch"></param>
            <param name="ex"></param>
        </member>
        <member name="M:Marten.IMartenSessionLogger.LogFailure(System.Exception,System.String)">
            <summary>
            Log a message for generic errors
            </summary>
            <param name="ex"></param>
            <param name="message"></param>
            <param name="batch"></param>
        </member>
        <member name="M:Marten.IMartenSessionLogger.RecordSavedChanges(Marten.IDocumentSession,Marten.Services.IChangeSet)">
            <summary>
                Called immediately after committing an IDocumentSession
                through SaveChanges() or SaveChangesAsync()
            </summary>
            <param name="session"></param>
            <param name="commit"></param>
        </member>
        <member name="M:Marten.IMartenSessionLogger.OnBeforeExecute(Npgsql.NpgsqlCommand)">
            <summary>
                Called just before a command is to be executed. Use this to create
                performance logging of Marten operations
            </summary>
            <param name="command"></param>
        </member>
        <member name="M:Marten.IMartenSessionLogger.OnBeforeExecute(Npgsql.NpgsqlBatch)">
            <summary>
                Called just before a command is to be executed. Use this to create
                performance logging of Marten operations
            </summary>
            <param name="command"></param>
        </member>
        <member name="P:Marten.IMartenStorage.Database">
            <summary>
                Directly access the default database when *not* using "database per tenant" multi-tenancy
            </summary>
        </member>
        <member name="M:Marten.IMartenStorage.AllSchemaNames">
            <summary>
                All referenced schema names by the known objects in this database
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IMartenStorage.AllObjects">
            <summary>
                Return an enumerable of all schema objects in dependency order
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IMartenStorage.ToDatabaseScript">
            <summary>
                Return the SQL script for the entire database configuration as a single string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IMartenStorage.WriteCreationScriptToFile(System.String)">
            <summary>
                Write the SQL creation script to the supplied filename
            </summary>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IMartenStorage.WriteScriptsByType(System.String)">
            <summary>
                Write the SQL creation script by feature type to the supplied directory
            </summary>
            <param name="directory"></param>
        </member>
        <member name="M:Marten.IMartenStorage.ApplyAllConfiguredChangesToDatabaseAsync(System.Nullable{Weasel.Core.AutoCreate})">
            <summary>
                Apply all detected changes between configuration and the actual database to the database
                THIS APPLIES TO ALL MARTEN DATABASES IN THE CASE OF "database per tenant" multi-tenancy
            </summary>
            <param name="override">If supplied, this overrides the AutoCreate threshold of this database</param>
            <returns></returns>
        </member>
        <member name="M:Marten.IMartenStorage.CreateMigrationAsync">
            <summary>
                Determine a migration for the configured database against the actual database
                NOTE -- this is only valid for single tenant Marten usage
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IMartenStorage.FindOrCreateDatabase(System.String)">
            <summary>
                Directly access the Marten database containing the named tenant id or found by the database identifier
            </summary>
            <param name="tenantIdOrDatabaseIdentifier"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IMartenStorage.AllDatabases">
            <summary>
                A read only list of all known Marten databases addressed by this store
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Internal.CodeGeneration.FrameCollectionExtensions.SetMemberValue(JasperFx.CodeGeneration.FramesCollection,System.Reflection.MemberInfo,System.String,System.Type,JasperFx.CodeGeneration.GeneratedType)">
            <summary>
                Generates the necessary setter code to set a value of a document.
                Handles internal/private setters
            </summary>
            <param name="frames"></param>
            <param name="member"></param>
            <param name="variableName"></param>
            <param name="documentType"></param>
            <param name="generatedType"></param>
        </member>
        <member name="T:Marten.Internal.CodeGeneration.IDocumentSelector">
            <summary>
                Strictly a marker interface that tells the compiled query
                generation to use a new selector per session
            </summary>
        </member>
        <member name="T:Marten.Internal.CompiledQueries.ICompiledQueryAwareFilter">
            <summary>
            This marker interface is used for SQL fragment filters where
            there needs to be some special handling within compiled queries
            </summary>
        </member>
        <member name="P:Marten.Internal.IMartenSession.Concurrency">
            <summary>
                Override whether or not this session honors optimistic concurrency checks
            </summary>
        </member>
        <member name="P:Marten.Internal.IMartenSession.CausationId">
            <summary>
                Optional metadata describing the causation id for this
                unit of work
            </summary>
        </member>
        <member name="P:Marten.Internal.IMartenSession.CorrelationId">
            <summary>
                Optional metadata describing the correlation id for this
                unit of work
            </summary>
        </member>
        <member name="P:Marten.Internal.IMartenSession.LastModifiedBy">
            <summary>
                Optional metadata describing the user name or
                process name for this unit of work
            </summary>
        </member>
        <member name="P:Marten.Internal.IMartenSession.Headers">
            <summary>
                Optional metadata values. This may be null.
            </summary>
        </member>
        <member name="M:Marten.Internal.IMartenSession.ExecuteReader(Npgsql.NpgsqlCommand)">
            <summary>
                Execute a single command against the database with this session's connection and return the results
            </summary>
            <param name="command"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Internal.IMartenSession.ExecuteReaderAsync(Npgsql.NpgsqlCommand,System.Threading.CancellationToken)">
            <summary>
                Execute a single command against the database with this session's connection and return the results
            </summary>
            <param name="command"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Internal.Sessions.DocumentSessionBase.ForTenant(System.String)">
            <summary>
                Access data from another tenant and apply document or event updates to this
                IDocumentSession for a separate tenant
            </summary>
            <param name="tenantId"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Internal.Sessions.DocumentSessionBase.UndoDeleteWhere``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
                For soft-deleted document types, this is a one sized fits all mechanism to reverse the
                soft deletion tracking
            </summary>
            <param name="expression"></param>
            <typeparam name="T"></typeparam>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="P:Marten.Internal.Sessions.QuerySession.Database">
            <summary>
                Used for code generation
            </summary>
        </member>
        <member name="P:Marten.Internal.Sessions.QuerySession.Headers">
            <summary>
                This is meant to be lazy created, and can be null
            </summary>
        </member>
        <member name="M:Marten.Internal.Sessions.QuerySession.QueryStorageFor``2">
            <summary>
                This returns the query-only version of the document storage
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TId"></typeparam>
            <returns></returns>
            <exception cref="T:Marten.Exceptions.DocumentIdTypeMismatchException"></exception>
        </member>
        <member name="P:Marten.Internal.Storage.IDocumentStorage.SelectClauseWithDuplicatedFields">
            <summary>
            Necessary (maybe) for usage within the temporary tables when using Includes()
            </summary>
        </member>
        <member name="M:Marten.Internal.Storage.IDocumentStorage`2.SetIdentity(`0,`1)">
            <summary>
                Assign the given identity to the document
            </summary>
            <param name="document"></param>
            <param name="identity"></param>
        </member>
        <member name="P:Marten.IQuerySession.Database">
            <summary>
                The underlying Marten database for this session
            </summary>
        </member>
        <member name="P:Marten.IQuerySession.Connection">
            <summary>
                The currently open Npgsql connection for this session. Use with caution.
            </summary>
        </member>
        <member name="P:Marten.IQuerySession.Logger">
            <summary>
                The session specific logger for this session. Can be set for better integration
                with custom diagnostics
            </summary>
        </member>
        <member name="P:Marten.IQuerySession.RequestCount">
            <summary>
                Request count
            </summary>
        </member>
        <member name="P:Marten.IQuerySession.DocumentStore">
            <summary>
                The document store that created this session
            </summary>
        </member>
        <member name="P:Marten.IQuerySession.Events">
            <summary>
                Access to the event store functionality
            </summary>
        </member>
        <member name="P:Marten.IQuerySession.Json">
            <summary>
                Directly load the persisted JSON data for documents by Id
            </summary>
        </member>
        <member name="P:Marten.IQuerySession.CausationId">
            <summary>
                Optional metadata describing the causation id for this
                unit of work
            </summary>
        </member>
        <member name="P:Marten.IQuerySession.CorrelationId">
            <summary>
                Optional metadata describing the correlation id for this
                unit of work
            </summary>
        </member>
        <member name="P:Marten.IQuerySession.TenantId">
            <summary>
            The tenant id for this session. If not opened with a tenant id, this value will be "*DEFAULT*"
            </summary>
        </member>
        <member name="M:Marten.IQuerySession.Load``1(System.String)">
            <summary>
                Find or load a single document of type T by a string id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadAsync``1(System.String,System.Threading.CancellationToken)">
            <summary>
                Asynchronously find or load a single document of type T by a string id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.Load``1(System.Int32)">
            <summary>
                Load or find a single document of type T with either a numeric or Guid id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.Load``1(System.Int64)">
            <summary>
                Load or find a single document of type T with either a numeric or Guid id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.Load``1(System.Guid)">
            <summary>
                Load or find a single document of type T with either a numeric or Guid id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadAsync``1(System.Int32,System.Threading.CancellationToken)">
            <summary>
                Asynchronously load or find a single document of type T with either a numeric or Guid id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadAsync``1(System.Int64,System.Threading.CancellationToken)">
            <summary>
                Asynchronously load or find a single document of type T with either a numeric or Guid id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadAsync``1(System.Guid,System.Threading.CancellationToken)">
            <summary>
                Asynchronously load or find a single document of type T with either a numeric or Guid id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.Query``1">
            <summary>
                Use Linq operators to query the documents
                stored in Postgresql
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.Query``1(System.String,System.Object[])">
            <summary>
                Queries the document storage table for the document type T by supplied SQL. See
                https://martendb.io/documents/querying/sql.html for more information on usage.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="sql"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.StreamJson``1(System.IO.Stream,System.Threading.CancellationToken,System.String,System.Object[])">
            <summary>
                Stream the results of a user-supplied query directly to a stream as a JSON array
            </summary>
            <param name="destination"></param>
            <param name="token"></param>
            <param name="sql"></param>
            <param name="parameters"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.StreamJson``1(System.IO.Stream,System.String,System.Object[])">
            <summary>
                Stream the results of a user-supplied query directly to a stream as a JSON array
            </summary>
            <param name="destination"></param>
            <param name="sql"></param>
            <param name="parameters"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.QueryAsync``1(System.String,System.Threading.CancellationToken,System.Object[])">
            <summary>
                Asynchronously queries the document storage table for the document type T by supplied SQL. See
                https://martendb.io/documents/querying/sql.html for more information on usage.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="sql"></param>
            <param name="token"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.QueryAsync``1(System.String,System.Object[])">
            <summary>
                Asynchronously queries the document storage table for the document type T by supplied SQL. See
                https://martendb.io/documents/querying/sql.html for more information on usage.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="sql"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.AdvancedSqlQueryAsync``1(System.String,System.Threading.CancellationToken,System.Object[])">
            <summary>
                Asynchronously queries the document storage with the supplied SQL.
                The type parameter can be a document class, a scalar or any JSON-serializable class.
                If the result is a document, the SQL must contain a select with the required fields in the correct order,
                depending on the session type and the metadata the document might use, at least id and data must be
                selected.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="sql"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.AdvancedSqlQueryAsync``2(System.String,System.Threading.CancellationToken,System.Object[])">
            <summary>
                Asynchronously queries the document storage with the supplied SQL.
                The type parameters can be any document class, scalar or JSON-serializable class.
                For each result type parameter, the SQL SELECT statement must contain a ROW.
                For document types, the row must contain the required fields in the correct order,
                depending on the session type and the metadata the document might use, at least id and data must be
                provided.
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <param name="sql"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.AdvancedSqlQueryAsync``3(System.String,System.Threading.CancellationToken,System.Object[])">
            <summary>
                Asynchronously queries the document storage with the supplied SQL.
                The type parameters can be any document class, scalar or JSON-serializable class.
                For each result type parameter, the SQL SELECT statement must contain a ROW.
                For document types, the row must contain the required fields in the correct order,
                depending on the session type and the metadata the document might use, at least id and data must be
                provided.
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <param name="sql"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.AdvancedSqlQuery``1(System.String,System.Object[])">
            <summary>
                Asynchronously queries the document storage with the supplied SQL.
                The type parameter can be a document class, a scalar or any JSON-serializable class.
                If the result is a document, the SQL must contain a select with the required fields in the correct order,
                depending on the session type and the metadata the document might use, at least id and data must be
                selected.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="sql"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.AdvancedSqlQuery``2(System.String,System.Object[])">
            <summary>
                Asynchronously queries the document storage with the supplied SQL.
                The type parameters can be any document class, scalar or JSON-serializable class.
                For each result type parameter, the SQL SELECT statement must contain a ROW.
                For document types, the row must contain the required fields in the correct order,
                depending on the session type and the metadata the document might use, at least id and data must be
                provided.
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <param name="sql"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.AdvancedSqlQuery``3(System.String,System.Object[])">
            <summary>
                Asynchronously queries the document storage with the supplied SQL.
                The type parameters can be any document class, scalar or JSON-serializable class.
                For each result type parameter, the SQL SELECT statement must contain a ROW.
                For document types, the row must contain the required fields in the correct order,
                depending on the session type and the metadata the document might use, at least id and data must be
                provided.
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <param name="sql"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.CreateBatchQuery">
            <summary>
                Define a batch of deferred queries and load operations to be conducted in one asynchronous request to the
                database for potentially performance
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.Query``2(Marten.Linq.ICompiledQuery{``0,``1})">
            <summary>
                A query that is compiled so a copy of the DbCommand can be used directly in subsequent requests.
            </summary>
            <typeparam name="TDoc">The document</typeparam>
            <typeparam name="TOut">The output</typeparam>
            <param name="query">The instance of a compiled query</param>
            <returns>A single item query result</returns>
        </member>
        <member name="M:Marten.IQuerySession.QueryAsync``2(Marten.Linq.ICompiledQuery{``0,``1},System.Threading.CancellationToken)">
            <summary>
                An async query that is compiled so a copy of the DbCommand can be used directly in subsequent requests.
            </summary>
            <typeparam name="TDoc">The document</typeparam>
            <typeparam name="TOut">The output</typeparam>
            <param name="query">The instance of a compiled query</param>
            <param name="token">A cancellation token</param>
            <returns>A task for a single item query result</returns>
        </member>
        <member name="M:Marten.IQuerySession.StreamJsonOne``2(Marten.Linq.ICompiledQuery{``0,``1},System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
                Stream a single JSON document to the destination using a compiled query
            </summary>
            <param name="query"></param>
            <param name="destination"></param>
            <param name="token"></param>
            <typeparam name="TDoc"></typeparam>
            <typeparam name="TOut"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.StreamJsonMany``2(Marten.Linq.ICompiledQuery{``0,``1},System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
                Stream many documents as a JSON array to the destination using a compiled query
            </summary>
            <param name="query"></param>
            <param name="destination"></param>
            <param name="token"></param>
            <typeparam name="TDoc"></typeparam>
            <typeparam name="TOut"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.ToJsonOne``2(Marten.Linq.ICompiledQuery{``0,``1},System.Threading.CancellationToken)">
            <summary>
                Fetch the JSON representation of a single document using a compiled query
            </summary>
            <param name="query"></param>
            <param name="token"></param>
            <typeparam name="TDoc"></typeparam>
            <typeparam name="TOut"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.ToJsonMany``2(Marten.Linq.ICompiledQuery{``0,``1},System.Threading.CancellationToken)">
            <summary>
                Fetch the JSON array representation of a list of documents using a compiled query
            </summary>
            <param name="query"></param>
            <param name="token"></param>
            <typeparam name="TDoc"></typeparam>
            <typeparam name="TOut"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadMany``1(System.String[])">
            <summary>
                Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadMany``1(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadMany``1(System.Guid[])">
            <summary>
                Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadMany``1(System.Collections.Generic.IEnumerable{System.Guid})">
            <summary>
                Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadMany``1(System.Int32[])">
            <summary>
                Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadMany``1(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
                Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadMany``1(System.Int64[])">
            <summary>
                Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadMany``1(System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
                Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.String[])">
            <summary>
                Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Guid[])">
            <summary>
                Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Collections.Generic.IEnumerable{System.Guid})">
            <summary>
                Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Int32[])">
            <summary>
                Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
                Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Int64[])">
            <summary>
                Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
                Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Threading.CancellationToken,System.String[])">
            <summary>
                Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Threading.CancellationToken,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Threading.CancellationToken,System.Guid[])">
            <summary>
                Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Threading.CancellationToken,System.Collections.Generic.IEnumerable{System.Guid})">
            <summary>
                Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Threading.CancellationToken,System.Int32[])">
            <summary>
                Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Threading.CancellationToken,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
                Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Threading.CancellationToken,System.Int64[])">
            <summary>
                Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.LoadManyAsync``1(System.Threading.CancellationToken,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
                Load or find multiple documents by id
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.VersionFor``1(``0)">
            <summary>
                Retrieve the current known version of the given document
                according to this session. Will return null if the document is
                not part of this session
            </summary>
            <param name="entity"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.Search``1(System.String,System.String)">
            <summary>
                Performs a full text search against <typeparamref name="TDoc" />
            </summary>
            <param name="queryText">The text to search for.  May contain lexeme patterns used by PostgreSQL for full text searching</param>
            <param name="regConfig">
                The dictionary config passed to the 'to_tsquery' function, must match the config parameter used
                by <seealso cref="!:DocumentMapping.AddFullTextIndex(string)" />
            </param>
            <remarks>
                See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.IQuerySession.SearchAsync``1(System.String,System.String,System.Threading.CancellationToken)">
            <summary>
                Performs an asynchronous full text search against <typeparamref name="TDoc" />
            </summary>
            <param name="queryText">The text to search for.  May contain lexeme patterns used by PostgreSQL for full text searching</param>
            <param name="regConfig">
                The dictionary config passed to the 'to_tsquery' function, must match the config parameter used
                by <seealso cref="!:DocumentMapping.AddFullTextIndex(string)" />
            </param>
            <remarks>
                See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.IQuerySession.PlainTextSearch``1(System.String,System.String)">
            <summary>
                Performs a full text search against <typeparamref name="TDoc" /> using the 'plainto_tsquery' search function
            </summary>
            <param name="queryText">The text to search for.  May contain lexeme patterns used by PostgreSQL for full text searching</param>
            <param name="regConfig">
                The dictionary config passed to the 'to_tsquery' function, must match the config parameter used
                by <seealso cref="!:DocumentMapping.AddFullTextIndex(string)" />
            </param>
            <remarks>
                See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.IQuerySession.PlainTextSearchAsync``1(System.String,System.String,System.Threading.CancellationToken)">
            <summary>
                Performs an asynchronous full text search against <typeparamref name="TDoc" /> using the 'plainto_tsquery' function
            </summary>
            <param name="queryText">The text to search for.  May contain lexeme patterns used by PostgreSQL for full text searching</param>
            <param name="regConfig">
                The dictionary config passed to the 'to_tsquery' function, must match the config parameter used
                by <seealso cref="!:DocumentMapping.AddFullTextIndex(string)" />
            </param>
            <remarks>
                See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.IQuerySession.PhraseSearch``1(System.String,System.String)">
            <summary>
                Performs a full text search against <typeparamref name="TDoc" /> using the 'phraseto_tsquery' search function
            </summary>
            <param name="queryText">The text to search for.  May contain lexeme patterns used by PostgreSQL for full text searching</param>
            <param name="regConfig">
                The dictionary config passed to the 'to_tsquery' function, must match the config parameter used
                by <seealso cref="!:DocumentMapping.AddFullTextIndex(string)" />
            </param>
            <remarks>
                See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.IQuerySession.PhraseSearchAsync``1(System.String,System.String,System.Threading.CancellationToken)">
            <summary>
                Performs an asynchronous full text search against <typeparamref name="TDoc" /> using the 'phraseto_tsquery' search
                function
            </summary>
            <param name="queryText">The text to search for.  May contain lexeme patterns used by PostgreSQL for full text searching</param>
            <param name="regConfig">
                The dictionary config passed to the 'to_tsquery' function, must match the config parameter used
                by <seealso cref="!:DocumentMapping.AddFullTextIndex(string)" />
            </param>
            <remarks>
                See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.IQuerySession.WebStyleSearch``1(System.String,System.String)">
            <summary>
                Performs a full text search against <typeparamref name="TDoc" /> using the 'websearch_to_tsquery' search function
            </summary>
            <param name="searchTerm">
                The text to search for.  Uses an alternative syntax to the other search functions, similar to
                the one used by web search engines
            </param>
            <param name="regConfig">
                The dictionary config passed to the 'websearch_to_tsquery' function, must match the config
                parameter used by <seealso cref="!:DocumentMapping.AddFullTextIndex(string)" />
            </param>
            <remarks>
                Supported from Postgres 11
                See: https://www.postgresql.org/docs/11/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.IQuerySession.WebStyleSearchAsync``1(System.String,System.String,System.Threading.CancellationToken)">
            <summary>
                Performs an asynchronous full text search against <typeparamref name="TDoc" /> using the 'websearch_to_tsquery'
                search function
            </summary>
            <param name="searchTerm">
                The text to search for.  Uses an alternative syntax to the other search functions, similar to
                the one used by web search engines
            </param>
            <param name="regConfig">
                The dictionary config passed to the 'websearch_to_tsquery' function, must match the config
                parameter used by <seealso cref="!:DocumentMapping.AddFullTextIndex(string)" />
            </param>
            <param name="token"></param>
            <remarks>
                Supported from Postgres 11
                See: https://www.postgresql.org/docs/11/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.IQuerySession.MetadataFor``1(``0)">
            <summary>
                Fetch the entity version and last modified time from the database
            </summary>
            <param name="entity"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.MetadataForAsync``1(``0,System.Threading.CancellationToken)">
            <summary>
                Fetch the entity version and last modified time from the database
            </summary>
            <param name="entity"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.ForTenant(System.String)">
            <summary>
                Access data from another tenant and apply document or event updates to this
                IDocumentSession for a separate tenant
            </summary>
            <param name="tenantId"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.Execute(Npgsql.NpgsqlCommand)">
            <summary>
                Execute a single command against the database with this session's connection
            </summary>
            <param name="cmd"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.ExecuteAsync(Npgsql.NpgsqlCommand,System.Threading.CancellationToken)">
            <summary>
                Execute a single command against the database with this session's connection
            </summary>
            <param name="command"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.ExecuteReader(Npgsql.NpgsqlCommand)">
            <summary>
                Execute a single command against the database with this session's connection and return the results
            </summary>
            <param name="command"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.IQuerySession.ExecuteReaderAsync(Npgsql.NpgsqlCommand,System.Threading.CancellationToken)">
            <summary>
                Execute a single command against the database with this session's connection and return the results
            </summary>
            <param name="command"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="P:Marten.IQuerySession.AdvancedSql">
            <summary>
                Advanced sql query methods, to allow you to query the database
                beyond what you can do with LINQ.
            </summary>
        </member>
        <member name="P:Marten.IReadOnlyStoreOptions.Advanced">
            <summary>
                Uncommonly used configuration items
            </summary>
        </member>
        <member name="P:Marten.IReadOnlyStoreOptions.DatabaseSchemaName">
            <summary>
                Sets the database default schema name used to store the documents.
            </summary>
        </member>
        <member name="P:Marten.IReadOnlyStoreOptions.Events">
            <summary>
                Configuration of event streams and projections
            </summary>
        </member>
        <member name="P:Marten.IReadOnlyStoreOptions.Linq">
            <summary>
                Custom Linq query parsers applied to this DocumentStore
            </summary>
        </member>
        <member name="P:Marten.IReadOnlyStoreOptions.NameDataLength">
            <summary>
                Used to validate database object name lengths against Postgresql's NAMEDATALEN property to avoid
                Marten getting confused when comparing database schemas against the configuration. See
                https://www.postgresql.org/docs/current/static/sql-syntax-lexical.html
                for more information. This does NOT adjust NAMEDATALEN for you.
            </summary>
        </member>
        <member name="P:Marten.IReadOnlyStoreOptions.EnumStorage">
            <summary>
                Gets Enum values stored as either integers or strings. This is configured on your ISerializer
            </summary>
        </member>
        <member name="P:Marten.IReadOnlyStoreOptions.UpdateBatchSize">
            <summary>
                Sets the batch size for updating or deleting documents in IDocumentSession.SaveChanges() /
                IUnitOfWork.ApplyChanges()
            </summary>
        </member>
        <member name="P:Marten.IReadOnlyStoreOptions.Tenancy">
            <summary>
                Access to information about document store tenants configured in this application
            </summary>
        </member>
        <member name="M:Marten.IReadOnlyStoreOptions.Serializer">
            <summary>
                Access to the underlying Marten serializer
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IReadOnlyStoreOptions.Logger">
            <summary>
                Access to the attached Marten logger
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IReadOnlyStoreOptions.AllKnownDocumentTypes">
            <summary>
                Retrieve a list of all the currently known document types
                in this Martne store
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.IReadOnlyStoreOptions.FindOrResolveDocumentType(System.Type)">
            <summary>
                Finds or resolves the configuration for a given document type
                If the documentType is a subclass, you will retrieve the root
                parent document configuration.
            </summary>
            <param name="documentType"></param>
            <returns></returns>
        </member>
        <member name="P:Marten.IReadOnlyStoreOptions.Schema">
            <summary>
            Get database schema names for configured tables
            </summary>
        </member>
        <member name="T:Marten.ValueCasting">
            <summary>
                When selecting data through Linq Select() transforms,
                should the data elements returned from Postgresql be
                cast to their raw types or simple strings
            </summary>
        </member>
        <member name="F:Marten.ValueCasting.Strict">
            <summary>
                Json fields will be returned with their values cast to
                the proper type. I.e., {"number": 1}
            </summary>
        </member>
        <member name="F:Marten.ValueCasting.Relaxed">
            <summary>
                Json fields will be returned with their values in simple
                string values. I.e., {"number": "1"}
            </summary>
        </member>
        <member name="P:Marten.ISerializer.EnumStorage">
            <summary>
                Just gotta tell Marten if enum's are stored
                as int's or string's in the JSON
            </summary>
        </member>
        <member name="P:Marten.ISerializer.Casing">
            <summary>
                Specify whether properties in the JSON document should use Camel or Pascal casing.
            </summary>
        </member>
        <member name="P:Marten.ISerializer.ValueCasting">
            <summary>
                Controls how the Linq Select() behavior needs to work in the database
            </summary>
        </member>
        <member name="M:Marten.ISerializer.ToJson(System.Object)">
            <summary>
                Serialize the document object into a JSON string
            </summary>
            <param name="document"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.ISerializer.FromJson``1(System.IO.Stream)">
            <summary>
                Deserialize a JSON string stream into an object of type T
            </summary>
        </member>
        <member name="M:Marten.ISerializer.FromJson``1(System.Data.Common.DbDataReader,System.Int32)">
            <summary>
                Deserialize a JSON string into an object of type T
            </summary>
        </member>
        <member name="M:Marten.ISerializer.FromJsonAsync``1(System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
                Deserialize a JSON string stream into an object of type T
            </summary>
        </member>
        <member name="M:Marten.ISerializer.FromJsonAsync``1(System.Data.Common.DbDataReader,System.Int32,System.Threading.CancellationToken)">
            <summary>
                Deserialize a JSON string into an object of type T
            </summary>
        </member>
        <member name="M:Marten.ISerializer.FromJson(System.Type,System.IO.Stream)">
            <summary>
                Deserialize a JSON string stream into an object of type T
            </summary>
        </member>
        <member name="M:Marten.ISerializer.FromJson(System.Type,System.Data.Common.DbDataReader,System.Int32)">
            <summary>
                Deserialize a JSON string into the supplied Type
            </summary>
        </member>
        <member name="M:Marten.ISerializer.FromJsonAsync(System.Type,System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
                Deserialize a JSON string stream into an object of type T
            </summary>
        </member>
        <member name="M:Marten.ISerializer.FromJsonAsync(System.Type,System.Data.Common.DbDataReader,System.Int32,System.Threading.CancellationToken)">
            <summary>
                Deserialize a JSON string into the supplied Type
            </summary>
        </member>
        <member name="M:Marten.ISerializer.ToCleanJson(System.Object)">
            <summary>
                Serialize a document without any extra
                type handling metadata
            </summary>
            <param name="document"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.ISerializer.ToJsonWithTypes(System.Object)">
            <summary>
                Write the JSON for a document with embedded
                type information. This is used inside the patching API
                to handle polymorphic collections
            </summary>
            <param name="document"></param>
            <returns></returns>
        </member>
        <member name="T:Marten.Casing">
            <summary>
                Governs the JSON serialization behavior of how .Net
                member names are persisted in the JSON stored in
                the database
            </summary>
        </member>
        <member name="F:Marten.Casing.Default">
            <summary>
                Exactly mimic the .Net member names in the JSON persisted to the database
            </summary>
        </member>
        <member name="F:Marten.Casing.CamelCase">
            <summary>
                Force the .Net member names to camel casing when serialized to JSON in
                the database
            </summary>
        </member>
        <member name="F:Marten.Casing.SnakeCase">
            <summary>
                Force the .Net member names to snake casing when serialized to JSON in
                the database
            </summary>
        </member>
        <member name="T:Marten.CollectionStorage">
            <summary>
                Governs .Net collection serialization
            </summary>
        </member>
        <member name="F:Marten.CollectionStorage.Default">
            <summary>
                Use default serialization for collections according to the serializer
                being used
            </summary>
        </member>
        <member name="F:Marten.CollectionStorage.AsArray">
            <summary>
                Direct the underlying serializer to serialize collections as JSON arrays
            </summary>
        </member>
        <member name="T:Marten.ISessionFactory">
            <summary>
                Pluggable strategy for customizing how IDocumentSession / IQuerySession
                objects are created within an application.
            </summary>
        </member>
        <member name="M:Marten.ISessionFactory.QuerySession">
            <summary>
                Build new instances of IQuerySession on demand
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.ISessionFactory.OpenSession">
            <summary>
                Build new instances of IDocumentSession on demand
            </summary>
            <returns></returns>
        </member>
        <member name="T:Marten.SessionFactoryBase">
            <summary>
            Base class for simple creation of document sessions
            </summary>
        </member>
        <member name="M:Marten.SessionFactoryBase.ApplyMetadata(Marten.IDocumentSession)">
            <summary>
            A hook to apply tracking metadata to the Document Session
            </summary>
            <param name="documentSession"></param>
        </member>
        <member name="T:Marten.ITenantOperations">
            <summary>
                Access to querying or registering updates for a separate tenant
                to a parent IDocumentSession
            </summary>
        </member>
        <member name="P:Marten.ITenantOperations.TenantId">
            <summary>
                The tenant id of this tenant operations
            </summary>
        </member>
        <member name="T:Marten.ITenantQueryOperations">
            <summary>
                Access to querying or registering updates for a separate tenant
                to a parent IDocumentSession
            </summary>
        </member>
        <member name="P:Marten.ITenantQueryOperations.TenantId">
            <summary>
                The tenant id of this tenant operations
            </summary>
        </member>
        <member name="M:Marten.Linq.CreatedAt.CreatedAtExtensions.CreatedSince(System.Object,System.DateTimeOffset)">
            <summary>
                The search results should include documents created since given time (&gt;)
            </summary>
            <param name="doc"></param>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.CreatedAt.CreatedAtExtensions.CreatedBefore(System.Object,System.DateTimeOffset)">
            <summary>
                The search results should include documents created before given time (&lt;)
            </summary>
            <param name="doc"></param>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="T:Marten.Linq.FetchType">
            <summary>
                In basic terms, how is the IQueryable going to be executed?
            </summary>
        </member>
        <member name="F:Marten.Linq.FetchType.FetchOne">
            <summary>
                First/FirstOrDefault/Single/SingleOrDefault
            </summary>
        </member>
        <member name="F:Marten.Linq.FetchType.FetchMany">
            <summary>
                Any execution that returns an IEnumerable (ToArray()/ToList()/etc.)
            </summary>
        </member>
        <member name="F:Marten.Linq.FetchType.Count">
            <summary>
                Using IQueryable.Count()
            </summary>
        </member>
        <member name="F:Marten.Linq.FetchType.Any">
            <summary>
                Using IQueryable.Any()
            </summary>
        </member>
        <member name="T:Marten.Linq.IQueryPlanning">
            <summary>
                To "help" out the compiled query planning, you may need to implement this interface
                to create meaningful, unique values for each query parameter. NOTE: a value for Take()
                and Skip() must be greater than zero for query planning to work!
            </summary>
        </member>
        <member name="T:Marten.Linq.ICompiledQueryMarker">
            <summary>
            Strictly a marker class to help Marten discover compiled query types
            in assemblies
            </summary>
        </member>
        <member name="T:Marten.Linq.ICompiledQuery`2">
            <summary>
                Used to express a query expression that when used will be cached by class type implementing this interface
            </summary>
            <typeparam name="TDoc">The document</typeparam>
            <typeparam name="TOut">The result type for a query</typeparam>
        </member>
        <member name="T:Marten.Linq.ICompiledListQuery`1">
            <summary>
                A *temporary* marker interface that for now is necessary to express enumerable result sets
                Once the concept of a result transformer is introduced we can remove the need for this extra interface
            </summary>
            <typeparam name="TDoc">The document</typeparam>
        </member>
        <member name="T:Marten.Linq.ICompiledListQuery`2">
            <summary>
                A temporary marker interface that for now is necessary to express enumerable result sets
            </summary>
            <typeparam name="TDoc">The document</typeparam>
            <typeparam name="TOut">The output type</typeparam>
        </member>
        <member name="T:Marten.Linq.ICompiledQuery`1">
            <summary>
                Used to express a query expression that when used will be cached by class type implementing this interface
            </summary>
            <typeparam name="TDoc">The document</typeparam>
        </member>
        <member name="M:Marten.Linq.IConfigureExplainExpressions.Analyze">
            <summary>
                Carry out the command and show actual run times and other statistics.
            </summary>
        </member>
        <member name="M:Marten.Linq.IConfigureExplainExpressions.Verbose">
            <summary>
                Display additional information regarding the plan. Specifically, include the output column list for each node in
                the plan tree, schema-qualify table and function names, always label variables in expressions with their range
                table alias, and always print the name of each trigger for which statistics are displayed.
            </summary>
        </member>
        <member name="M:Marten.Linq.IConfigureExplainExpressions.Costs">
            <summary>
                Include information on the estimated startup and total cost of each plan node, as well as the estimated number of
                rows and the estimated width of each row.
            </summary>
        </member>
        <member name="M:Marten.Linq.IConfigureExplainExpressions.Buffers">
            <summary>
                Include information on buffer usage. Specifically, include the number of shared blocks hit, read, dirtied, and
                written, the number of local blocks hit, read, dirtied, and written, and the number of temp blocks read and
                written.
            </summary>
        </member>
        <member name="M:Marten.Linq.IConfigureExplainExpressions.Timing">
            <summary>
                Include the actual startup time and time spent in the node in the output.
            </summary>
        </member>
        <member name="M:Marten.Linq.IMartenQueryable`1.Include``1(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Action{``0})">
            <summary>
                Also fetch related documents, and call the callback lambda for each
                related document
            </summary>
            <param name="idSource"></param>
            <param name="callback"></param>
            <typeparam name="TInclude"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.IMartenQueryable`1.Include``1(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Action{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
                Also fetch related documents, and call the callback lambda for each
                related document
            </summary>
            <param name="idSource"></param>
            <param name="callback"></param>
            <param name="filter">Supply a Where() clause to filter the included documents returned</param>
            <typeparam name="TInclude"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.IMartenQueryable`1.Include``1(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Collections.Generic.IList{``0})">
            <summary>
                Also fetch related documents, and add the related documents to
                the supplied list
            </summary>
            <param name="idSource"></param>
            <param name="list"></param>
            <typeparam name="TInclude"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.IMartenQueryable`1.Include``1(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Collections.Generic.IList{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
                Also fetch related documents, and add the related documents to
                the supplied list
            </summary>
            <param name="idSource"></param>
            <param name="list"></param>
            <param name="filter">Specify Where() filtering on the included documents</param>
            <typeparam name="TInclude"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.IMartenQueryable`1.Include``2(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Collections.Generic.IDictionary{``1,``0})">
            <summary>
                Also fetch related documents, and add the related documents to
                the supplied dictionary organized by the identity of the related document
            </summary>
            <param name="idSource"></param>
            <param name="dictionary"></param>
            <typeparam name="TInclude"></typeparam>
            <typeparam name="TKey"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.IMartenQueryable`1.Include``2(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Collections.Generic.IDictionary{``1,``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
                Also fetch related documents, and add the related documents to
                the supplied dictionary organized by the identity of the related document
            </summary>
            <param name="idSource"></param>
            <param name="dictionary"></param>
            <param name="filter">Limit the included documents fetched from the server</param>
            <typeparam name="TInclude"></typeparam>
            <typeparam name="TKey"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.IMartenQueryable`1.Include``1(System.Action{``0})">
            <summary>
                Also fetch related documents, and call the callback lambda for each
                related document. Follow this with <c>.On(idSource)</c> to specify how to
                map to this document.
            </summary>
            <param name="callback"></param>
            <typeparam name="TInclude"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.IMartenQueryable`1.Include``1(System.Collections.Generic.IList{``0})">
            <summary>
                Also fetch related documents, and add the related documents to
                the supplied list. Follow this with <c>.On(idSource)</c> to specify how to
                map to this document.
            </summary>
            <param name="idSource"></param>
            <param name="list"></param>
            <typeparam name="TInclude"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.IMartenQueryable`1.Include``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
                Also fetch related documents, and add the related documents to
                the supplied dictionary organized by the property mapped to the related
                document. Follow this with <c>.On(idSource)</c> to specify how to map to
                this document.
            </summary>
            <param name="idSource"></param>
            <param name="dictionary"></param>
            <typeparam name="TInclude"></typeparam>
            <typeparam name="TKey"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.IMartenQueryable`1.Include``2(System.Collections.Generic.IDictionary{``0,System.Collections.Generic.IList{``1}})">
            <summary>
                Also fetch related documents, and add the related documents to
                the supplied dictionary of lists organized by the property mapped to the
                related document. Follow this with <c>.On(idSource)</c> to specify how
                to map to this document.
            </summary>
            <param name="idSource"></param>
            <param name="dictionary"></param>
            <typeparam name="TInclude"></typeparam>
            <typeparam name="TKey"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.IMartenQueryable`1.Include``2(System.Collections.Generic.IDictionary{``0,System.Collections.Generic.List{``1}})">
            <summary>
                Also fetch related documents, and add the related documents to
                the supplied dictionary of lists organized by the property mapped to the
                related document. Follow this with <c>.On(idSource)</c> to specify how
                to map to this document.
            </summary>
            <param name="idSource"></param>
            <param name="dictionary"></param>
            <typeparam name="TInclude"></typeparam>
            <typeparam name="TKey"></typeparam>
            <returns></returns>
        </member>
        <member name="T:Marten.Linq.Includes.IIncludeReader">
            <summary>
                Used internally to process Include() operations
                in the Linq support
            </summary>
        </member>
        <member name="M:Marten.Linq.Includes.IMartenQueryableIncludeBuilder`2.On(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Specify which property to use to map to the identity of the related document.
            </summary>
            <param name="idSource"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.Includes.IMartenQueryableIncludeBuilder`2.On(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Linq.Expressions.Expression{System.Func{`1,System.Boolean}})">
            <summary>
            Specify which property to use to map to the identity of the related document.
            </summary>
            <param name="idSource"></param>
            <param name="filter">Limit the included documents fetched from the server</param>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.Includes.IMartenQueryableIncludeBuilder`2.On``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Linq.Expressions.Expression{System.Func{`1,``0}})">
            <summary>
            Specify which property on the queried document to map with, and the property
            on the related document to map to.
            </summary>
            <param name="idSource"></param>
            <param name="idMapping"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.Includes.IMartenQueryableIncludeBuilder`2.On``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Linq.Expressions.Expression{System.Func{`1,``0}},System.Linq.Expressions.Expression{System.Func{`1,System.Boolean}})">
            <summary>
            Specify which property on the queried document to map with, and the property
            on the related document to map to.
            </summary>
            <param name="idSource"></param>
            <param name="idMapping"></param>
            <param name="filter">Limit the included documents fetched from the server</param>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.Includes.IMartenQueryableIncludeBuilder`3.On(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Specify which property to use to map to the identity of the related document.
            </summary>
            <param name="idSource"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.Includes.IMartenQueryableIncludeBuilder`3.On(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Linq.Expressions.Expression{System.Func{`2,System.Boolean}})">
            <summary>
            Specify which property to use to map to the identity of the related document.
            </summary>
            <param name="idSource"></param>
            <param name="filter">Limit the included documents fetched from the server</param>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.Includes.IMartenQueryableIncludeBuilder`3.On(System.Linq.Expressions.Expression{System.Func{`0,`1}},System.Linq.Expressions.Expression{System.Func{`2,`1}})">
            <summary>
            Specify which property on the queried document to map with, and the property
            on the related document to map to.
            </summary>
            <param name="idSource"></param>
            <param name="idMapping"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.Includes.IMartenQueryableIncludeBuilder`3.On(System.Linq.Expressions.Expression{System.Func{`0,`1}},System.Linq.Expressions.Expression{System.Func{`2,`1}},System.Linq.Expressions.Expression{System.Func{`2,System.Boolean}})">
            <summary>
            Specify which property on the queried document to map with, and the property
            on the related document to map to.
            </summary>
            <param name="idSource"></param>
            <param name="idMapping"></param>
            <param name="filter">Limit the included documents fetched from the server</param>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.Includes.IMartenQueryableIncludeBuilder`3.On``1(System.Linq.Expressions.Expression{System.Func{`0,System.Nullable{``0}}},System.Linq.Expressions.Expression{System.Func{`2,System.Nullable{``0}}})">
            <summary>
            Specify which property on the queried document to map with, and the property
            on the related document to map to.
            </summary>
            <param name="idSource"></param>
            <param name="idMapping"></param>
            <typeparam name="TId">The key type, as a value-type</typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.Includes.IMartenQueryableIncludeBuilder`3.On``1(System.Linq.Expressions.Expression{System.Func{`0,System.Nullable{``0}}},System.Linq.Expressions.Expression{System.Func{`2,System.Nullable{``0}}},System.Linq.Expressions.Expression{System.Func{`2,System.Boolean}})">
            <summary>
            Specify which property on the queried document to map with, and the property
            on the related document to map to.
            </summary>
            <param name="idSource"></param>
            <param name="idMapping"></param>
            <param name="filter">Limit the included documents fetched from the server</param>
            <typeparam name="TId">The key type, as a value-type</typeparam>
            <returns></returns>
        </member>
        <member name="T:Marten.Linq.Includes.Include">
            <summary>
                Used internally to process Include() operations
                in the Linq support
            </summary>
        </member>
        <member name="M:Marten.Linq.Includes.Include.ReaderToAction``1(Marten.Internal.IMartenSession,System.Action{``0})">
            <summary>
                Used internally to process Include() operations
                in the Linq support
            </summary>
        </member>
        <member name="M:Marten.Linq.Includes.Include.ReaderToList``1(Marten.Internal.IMartenSession,System.Collections.Generic.IList{``0})">
            <summary>
                Used internally to process Include() operations
                in the Linq support
            </summary>
        </member>
        <member name="M:Marten.Linq.Includes.Include.ReaderToDictionary``2(Marten.Internal.IMartenSession,System.Collections.Generic.IDictionary{``1,``0})">
            <summary>
                Used internally to process Include() operations
                in the Linq support
            </summary>
        </member>
        <member name="T:Marten.Linq.Includes.IncludeQueryHandler`1">
            <summary>
                Used internally to process Include() operations
                in the Linq support
            </summary>
        </member>
        <member name="M:Marten.Linq.LastModified.LastModifiedExtensions.ModifiedSince(System.Object,System.DateTimeOffset)">
            <summary>
                The search results should include documents modified since given time (&gt;)
            </summary>
            <param name="doc"></param>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.LastModified.LastModifiedExtensions.ModifiedBefore(System.Object,System.DateTimeOffset)">
            <summary>
                The search results should include documents modified before given time (&lt;)
            </summary>
            <param name="doc"></param>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.MatchesSql.MatchesSqlExtensions.MatchesSql(System.Object,Weasel.Postgresql.SqlGeneration.ISqlFragment)">
            <summary>
                The search results should match the specified where fragment.
            </summary>
            <param name="doc"></param>
            <param name="whereFragment"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.MatchesSql.MatchesSqlExtensions.MatchesSql(System.Object,System.String,System.Object[])">
            <summary>
                The search results should match the specified raw sql fragment. "?" is assumed to be a place holder
            for parameters. Use the MatchesJsonPath() usage instead if your SQL utilizes any JSONPath operators!
            </summary>
            <param name="doc"></param>
            <param name="sql"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.MatchesSql.MatchesSqlExtensions.MatchesJsonPath(System.Object,System.String,System.Object[])">
            <summary>
                The search results should match the specified raw sql fragment that is assumed to include JSONPath. Use "^" for parameters instead of "?" to disambiguate from JSONPath
            </summary>
            <param name="doc"></param>
            <param name="sql"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="P:Marten.Linq.Members.AllCollectionConditionFilter.Not">
            <summary>
                Psych! Should there be a NOT in front of the sub query
            </summary>
        </member>
        <member name="P:Marten.Linq.Members.DuplicatedField.DbType">
            <summary>
                Used to override the assigned DbType used by Npgsql when a parameter
                is used in a query against this column
            </summary>
        </member>
        <member name="P:Marten.Linq.Members.ICollectionMember.ExplodeLocator">
            <summary>
                Locator against the parent JSONB data that will "explode" the elements into a record set
            </summary>
        </member>
        <member name="T:Marten.Linq.Members.IMemberSource">
            <summary>
                An extension point to "teach" Marten how to support new member types in the Linq support
            </summary>
        </member>
        <member name="P:Marten.Linq.Members.IQueryableMember.JsonPathSegment">
            <summary>
                JSONPath segment name
            </summary>
        </member>
        <member name="P:Marten.Linq.Members.IQueryableMember.TypedLocator">
            <summary>
                Postgresql locator that also casts the raw string data to the proper Postgresql type
            </summary>
        </member>
        <member name="P:Marten.Linq.Members.IQueryableMember.RawLocator">
            <summary>
                Postgresql locator that returns the raw string value within the JSONB document
            </summary>
        </member>
        <member name="P:Marten.Linq.Members.IQueryableMember.JSONBLocator">
            <summary>
                Locate the data for this field as JSONB
            </summary>
        </member>
        <member name="P:Marten.Linq.Members.IQueryableMember.LocatorForIncludedDocumentId">
            <summary>
                Locator for usage in "include" operations to get at the potential identifiers
                of the included documents
            </summary>
        </member>
        <member name="P:Marten.Linq.Members.IQueryableMember.NullTestLocator">
            <summary>
                Locator for usage in is null / is not null checks
            </summary>
        </member>
        <member name="M:Marten.Linq.Members.IQueryableMember.BuildOrderingExpression(Marten.Linq.Parsing.Operators.Ordering,Marten.Linq.Parsing.Operators.CasingRule)">
            <summary>
                Build the locator or expression for usage within "ORDER BY" clauses
            </summary>
            <param name="ordering"></param>
            <param name="casingRule"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.Members.IQueryableMember.FindOrPlaceChildDictionaryForContainment(System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
                This facilitates containment operator filters as an ancestor member
            </summary>
            <param name="dict"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.Members.IQueryableMember.PlaceValueInDictionaryForContainment(System.Collections.Generic.Dictionary{System.String,System.Object},System.Linq.Expressions.ConstantExpression)">
            <summary>
                This facilitates containment operator filters as the leaf member
            </summary>
            <param name="dict"></param>
            <param name="constant"></param>
        </member>
        <member name="M:Marten.Linq.Members.QueryableMember.#ctor(Marten.Linq.Members.IQueryableMember,Marten.Casing,System.Reflection.MemberInfo)">
            <summary>
            </summary>
            <param name="parentLocator">JSONB location of the parent element</param>
            <param name="member"></param>
        </member>
        <member name="P:Marten.Linq.Members.QueryableMember.JSONBLocator">
            <summary>
                Locate the data for this field as JSONB
            </summary>
        </member>
        <member name="T:Marten.Linq.Members.ValueCollections.SelectManyValueCollection">
            <summary>
            This takes the place of the ValueCollectionMember when this member
            is used inside of a SelectMany() clause
            </summary>
        </member>
        <member name="P:Marten.Linq.Members.ValueCollections.ValueCollectionMember.SimpleLocator">
            <summary>
            Only used to craft children locators later
            </summary>
        </member>
        <member name="T:Marten.Linq.OrderingDirection">
            <summary>
            Specifies the direction used to sort the result items in a query using an <see cref="T:Remotion.Linq.Clauses.OrderByClause" />.
            </summary>
        </member>
        <member name="F:Marten.Linq.OrderingDirection.Asc">
            <summary>
            Sorts the items in an ascending way, from smallest to largest.
            </summary>
        </member>
        <member name="F:Marten.Linq.OrderingDirection.Desc">
            <summary>
            Sorts the items in an descending way, from largest to smallest.
            </summary>
        </member>
        <member name="T:Marten.Linq.Parsing.IMethodCallParser">
            <summary>
                Models the Sql generation for a method call
                in a Linq query. For example, map an expression like Where(x => x.Property.StartsWith("prefix"))
                to part of a Sql WHERE clause
            </summary>
        </member>
        <member name="M:Marten.Linq.Parsing.IMethodCallParser.Matches(System.Linq.Expressions.MethodCallExpression)">
            <summary>
                Can this parser create a Sql where clause
                from part of a Linq expression that calls
                a method
            </summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.Parsing.IMethodCallParser.Parse(Marten.Linq.Members.IQueryableMemberCollection,Marten.IReadOnlyStoreOptions,System.Linq.Expressions.MethodCallExpression)">
            <summary>
                Creates an ISqlFragment object that Marten
                uses to help construct the underlying Sql
                command
            </summary>
            <param name="memberCollection"></param>
            <param name="options"></param>
            <param name="expression"></param>
            <param name="serializer"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.Parsing.LinqInternalExtensions.WriteJsonPath(Marten.Linq.Members.IQueryableMember,Weasel.Postgresql.ICommandBuilder)">
            <summary>
                Write out the JSONPath locator for the current member within its collection
            </summary>
            <param name="member"></param>
            <param name="builder"></param>
        </member>
        <member name="T:Marten.Linq.Parsing.Methods.SimpleEqualsParser">
            <summary>
                Implement Equals for <see cref="T:System.Int32" />, <see cref="T:System.Int64" />, <see cref="T:System.Decimal" />, <see cref="T:System.Guid" />,
                <see cref="T:System.Boolean" />, <see cref="T:System.DateTime" />, <see cref="T:System.DateTimeOffset" />.
            </summary>
            <remarks>
                Equals(object) calls into <see cref="M:System.Convert.ChangeType(System.Object,System.Type)" />. Equals(null) is converted to "is
                null" query.
            </remarks>
        </member>
        <member name="T:Marten.Linq.Parsing.Methods.SimpleNotEqualsParser">
            <summary>
                Implement !Equals for <see cref="T:System.Int32" />, <see cref="T:System.Int64" />, <see cref="T:System.Decimal" />, <see cref="T:System.Guid" />,
                <see cref="T:System.Boolean" />, <see cref="T:System.DateTime" />, <see cref="T:System.DateTimeOffset" />.
            </summary>
            <remarks>
                Equals(object) calls into <see cref="M:System.Convert.ChangeType(System.Object,System.Type)" />. Equals(null) is converted to "is
                null" query.
            </remarks>
        </member>
        <member name="P:Marten.Linq.Parsing.Operators.Ordering.IsTransformed">
            <summary>
            Refers to whether or not this ordering is transformed such that it cannot
            be combined with a Distinct(Select()) usage
            </summary>
        </member>
        <member name="P:Marten.Linq.QueryPlan.NodeType">
            <summary>
                The scan type to be used to retrieve the data (ie sequential, index).
            </summary>
        </member>
        <member name="P:Marten.Linq.QueryPlan.RelationName">
            <summary>
                The table name from which the 'select' was queried.
            </summary>
        </member>
        <member name="P:Marten.Linq.QueryPlan.Alias">
            <summary>
                The table alias that was used (if none was used, <see cref="P:Marten.Linq.QueryPlan.RelationName" /> is returned).
            </summary>
        </member>
        <member name="P:Marten.Linq.QueryPlan.StartupCost">
            <summary>
                The cost of initialising the query.
                (note that "cost" does not have a unit - it's an arbitrary value)
            </summary>
        </member>
        <member name="P:Marten.Linq.QueryPlan.TotalCost">
            <summary>
                The cost ofo performing the query.
                (note that "cost" does not have a unit - it's an arbitrary value)
            </summary>
        </member>
        <member name="P:Marten.Linq.QueryPlan.PlanRows">
            <summary>
                The estimated number of rows returned.
            </summary>
        </member>
        <member name="P:Marten.Linq.QueryPlan.PlanWidth">
            <summary>
                The storage size of the query returned fields.
            </summary>
        </member>
        <member name="P:Marten.Linq.QueryPlan.Command">
            <summary>
                The command executed by Marten
            </summary>
        </member>
        <member name="T:Marten.Linq.QueryStatistics">
            <summary>
                Used to supply the total number of rows in the database for server side
                paging scenarios
            </summary>
        </member>
        <member name="P:Marten.Linq.QueryStatistics.TotalResults">
            <summary>
                The total number of records in the database for this query
            </summary>
        </member>
        <member name="M:Marten.Linq.SoftDeletes.SoftDeletedExtensions.MaybeDeleted(System.Object)">
            <summary>
                The search results should include all documents, whether
                soft-deleted or not
            </summary>
            <typeparam name="T"></typeparam>
            <param name="doc"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.SoftDeletes.SoftDeletedExtensions.IsDeleted(System.Object)">
            <summary>
                The search results should only include soft-deleted
                documents
            </summary>
            <typeparam name="T"></typeparam>
            <param name="doc"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.SoftDeletes.SoftDeletedExtensions.DeletedSince(System.Object,System.DateTimeOffset)">
            <summary>
                The search results should include documents deleted since given time (&gt;)
            </summary>
            <param name="doc"></param>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Linq.SoftDeletes.SoftDeletedExtensions.DeletedBefore(System.Object,System.DateTimeOffset)">
            <summary>
                The search results should include documents deleted before given time (&lt;)
            </summary>
            <param name="doc"></param>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="T:Marten.Linq.SqlGeneration.ExplodeCollectionStatement">
            <summary>
                This statement explodes a collection element to a series
                of rows
            </summary>
        </member>
        <member name="P:Marten.Linq.SqlGeneration.Filters.AllValuesAreNullFilter.Not">
            <summary>
                Psych! Should there be a NOT in front of the sub query
            </summary>
        </member>
        <member name="T:Marten.Linq.SqlGeneration.Filters.ITenantFilter">
            <summary>
                Marker interface to help Marten track whether or not a Linq
                query has some kind of tenant-aware filtering
            </summary>
        </member>
        <member name="T:Marten.Linq.SqlGeneration.Filters.SpecificTenantFilter">
            <summary>
                SQL WHERE fragment for a specific tenant
            </summary>
        </member>
        <member name="P:Marten.Linq.SqlGeneration.Filters.SubQueryFilter.Not">
            <summary>
                Psych! Should there be a NOT in front of the sub query
            </summary>
        </member>
        <member name="T:Marten.Linq.SqlGeneration.Filters.DictionaryValueUsage">
            Tracks the usage of values within a serialized dictionary that is part of either
            a JSONPath or containment operator query. This is used for compiled query tracking
        </member>
        <member name="T:Marten.Linq.SqlGeneration.FilterStatement">
            <summary>
                This is built to filter a child collection in a CTE query
            </summary>
        </member>
        <member name="T:Marten.Linq.SqlGeneration.IOperationFragment">
            <summary>
                Internal marker interface for organizing operations
            </summary>
        </member>
        <member name="T:Marten.Linq.SqlGeneration.ISelectClause">
            <summary>
                Internal interface for the Linq subsystem
            </summary>
        </member>
        <member name="T:Marten.Linq.SqlGeneration.LiteralSql">
            <summary>
            Exactly what it sounds like, represents a little bit
            of literal SQL within a bigger statement
            </summary>
            <param name="Text"></param>
        </member>
        <member name="M:Marten.Linq.SqlGeneration.LiteralSql.#ctor(System.String)">
            <summary>
            Exactly what it sounds like, represents a little bit
            of literal SQL within a bigger statement
            </summary>
            <param name="Text"></param>
        </member>
        <member name="P:Marten.Linq.SqlGeneration.LiteralSql.Text">
            <summary></summary>
        </member>
        <member name="P:Marten.Linq.SqlGeneration.Statement.ExportName">
            <summary>
                For CTEs
            </summary>
        </member>
        <member name="M:Marten.Linq.SqlGeneration.Statement.AddToEnd(Marten.Linq.SqlGeneration.Statement)">
            <summary>
                Place the descendent at the very end
            </summary>
            <param name="descendent"></param>
        </member>
        <member name="M:Marten.LinqExtensions.IsOneOf``1(``0,``0[])">
            <summary>
                Used for Linq queries to match an element to one of a list of values
            </summary>
            <typeparam name="T"></typeparam>
            <param name="variable"></param>
            <param name="matches"></param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">when called for collection</exception>
        </member>
        <member name="M:Marten.LinqExtensions.IsOneOf``1(``0,System.Collections.Generic.IList{``0})">
            <summary>
                Used for Linq queries to match an element to one of a list of values
            </summary>
            <typeparam name="T"></typeparam>
            <param name="variable"></param>
            <param name="matches"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.LinqExtensions.In``1(``0,``0[])">
            <summary>
                Used for Linq queries to match an element to one of a list of values
            </summary>
            <typeparam name="T"></typeparam>
            <param name="variable"></param>
            <param name="matches"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.LinqExtensions.In``1(``0,System.Collections.Generic.IList{``0})">
            <summary>
                Used for Linq queries to match an element to one of a list of values
            </summary>
            <typeparam name="T"></typeparam>
            <param name="variable"></param>
            <param name="matches"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.LinqExtensions.IsSupersetOf``1(System.Collections.Generic.IEnumerable{``0},``0[])">
            <summary>
                Used for Linq queries to determines whether an element is a superset of the specified collection
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.LinqExtensions.IsSubsetOf``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
                Used for Linq queries to determines whether an element is a subset of the specified collection
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.LinqExtensions.IsSubsetOf``1(System.Collections.Generic.IEnumerable{``0},``0[])">
            <summary>
                Used for Linq queries to determines whether an element is a subset of the specified collection
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.LinqExtensions.IsSupersetOf``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
                Used for Linq queries to determines whether an element is a superset of the specified collection
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.LinqExtensions.IsEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
                Used for Linq queries to match on empty child collections
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.LinqExtensions.AnyTenant``1(``0)">
            <summary>
                Query across any and all tenants
            </summary>
            <typeparam name="T"></typeparam>
            <param name="variable"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.LinqExtensions.TenantIsOneOf``1(``0,System.String[])">
            <summary>
                Query for the range of supplied tenants
            </summary>
            <typeparam name="T"></typeparam>
            <param name="variable"></param>
            <param name="tenantIds"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.LinqExtensions.Search``1(``0,System.String)">
            <summary>
                Performs a full text search against <typeparamref name="TDoc" />
            </summary>
            <param name="searchTerm">
                The text to search for.  May contain lexeme patterns used by PostgreSQL for full text
                searching
            </param>
            <remarks>
                See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.LinqExtensions.Search``1(``0,System.String,System.String)">
            <summary>
                Performs a full text search against <typeparamref name="TDoc" />
            </summary>
            <param name="searchTerm">
                The text to search for.  May contain lexeme patterns used by PostgreSQL for full text
                searching
            </param>
            <param name="regConfig">
                The dictionary config passed to the 'to_tsquery' function, must match the config parameter used
                by <seealso cref="!:DocumentMapping.AddFullTextIndex(string)" />
            </param>
            <remarks>
                See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.LinqExtensions.PlainTextSearch``1(``0,System.String)">
            <summary>
                Performs a full text search against <typeparamref name="TDoc" /> using the 'plainto_tsquery' search function
            </summary>
            <param name="queryText">The text to search for.  May contain lexeme patterns used by PostgreSQL for full text searching</param>
            <remarks>
                See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.LinqExtensions.PlainTextSearch``1(``0,System.String,System.String)">
            <summary>
                Performs a full text search against <typeparamref name="TDoc" /> using the 'plainto_tsquery' search function
            </summary>
            <param name="queryText">The text to search for.  May contain lexeme patterns used by PostgreSQL for full text searching</param>
            <param name="regConfig">
                The dictionary config passed to the 'to_tsquery' function, must match the config parameter used
                by <seealso cref="!:DocumentMapping.AddFullTextIndex(string)" />
            </param>
            <remarks>
                See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.LinqExtensions.PhraseSearch``1(``0,System.String)">
            <summary>
                Performs a full text search against <typeparamref name="TDoc" /> using the 'phraseto_tsquery' search function
            </summary>
            <param name="queryText">The text to search for.  May contain lexeme patterns used by PostgreSQL for full text searching</param>
            <remarks>
                See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.LinqExtensions.PhraseSearch``1(``0,System.String,System.String)">
            <summary>
                Performs a full text search against <typeparamref name="TDoc" /> using the 'phraseto_tsquery' search function
            </summary>
            <param name="queryText">The text to search for.  May contain lexeme patterns used by PostgreSQL for full text searching</param>
            <param name="regConfig">
                The dictionary config passed to the 'to_tsquery' function, must match the config parameter used
                by <seealso cref="!:DocumentMapping.AddFullTextIndex(string)" />
            </param>
            <remarks>
                See: https://www.postgresql.org/docs/10/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.LinqExtensions.WebStyleSearch``1(``0,System.String)">
            <summary>
                Performs a full text search against <typeparamref name="T" /> using the 'websearch_to_tsquery' search function
            </summary>
            <param name="searchTerm">
                The text to search for.  Uses an alternative syntax to the other search functions, similar to
                the one used by web search engines
            </param>
            <remarks>
                Supported from Postgres 11
                See: https://www.postgresql.org/docs/11/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.LinqExtensions.WebStyleSearch``1(``0,System.String,System.String)">
            <summary>
                Performs a full text search against <typeparamref name="T" /> using the 'websearch_to_tsquery' search function
            </summary>
            <param name="searchTerm">
                The text to search for.  Uses an alternative syntax to the other search functions, similar to
                the one used by web search engines
            </param>
            <param name="regConfig">
                The dictionary config passed to the 'websearch_to_tsquery' function, must match the config
                parameter used by <seealso cref="!:DocumentMapping.AddFullTextIndex(string)" />
            </param>
            <remarks>
                Supported from Postgres 11
                See: https://www.postgresql.org/docs/11/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES
            </remarks>
        </member>
        <member name="M:Marten.LinqExtensions.NgramSearch``1(``0,System.String)">
            <summary>
                Performs a ngram search against <typeparamref name="T" /> using a custom ngram search function
            </summary>
            <param name="searchTerm">The text to search for.</param>
        </member>
        <member name="P:Marten.IReadOnlyLinqParsing.FieldSources">
            <summary>
                Registered extensions to the Marten Linq support for special handling of
                specific .Net types
            </summary>
        </member>
        <member name="P:Marten.IReadOnlyLinqParsing.MethodCallParsers">
            <summary>
                Custom Linq expression parsers for your own methods
            </summary>
        </member>
        <member name="F:Marten.LinqParsing.MethodCallParsers">
            <summary>
                Add custom Linq expression parsers for your own methods
            </summary>
        </member>
        <member name="P:Marten.LinqParsing.MemberSources">
            <summary>
                Register extensions to the Marten Linq support for special handling of
                specific .Net types
            </summary>
        </member>
        <member name="T:Marten.MartenRegistry">
            <summary>
                Used to customize or optimize the storage and retrieval of document types
            </summary>
        </member>
        <member name="M:Marten.MartenRegistry.Include``1">
            <summary>
                Include the declarations from another MartenRegistry type
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Marten.MartenRegistry.Include(Marten.MartenRegistry)">
            <summary>
                Include the declarations from another MartenRegistry object
            </summary>
            <param name="registry"></param>
        </member>
        <member name="M:Marten.MartenRegistry.For``1">
            <summary>
                Configure a single document type
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.IgnoreIndex(System.String)">
            <summary>
                Direct the schema migration detection to ignore the presence of the
                named index on the document storage table
            </summary>
            <param name="indexName"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.PropertySearching(Marten.Schema.PropertySearching)">
            <summary>
                Specify the property searching mechanism for this document type. The default is
                JSON_Locator_Only
            </summary>
            <param name="searching"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.DocumentAlias(System.String)">
            <summary>
                Override the Postgresql schema alias for this document type in order
                to disambiguate similarly named document types. The default is just
                the document type name to lower case.
            </summary>
            <param name="alias"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.Duplicate(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String,System.Nullable{NpgsqlTypes.NpgsqlDbType},System.Action{Marten.Schema.DocumentIndex},System.Boolean)">
            <summary>
                Marks a property or field on this document type as a searchable field that is also duplicated in the
                database document table
            </summary>
            <param name="expression"></param>
            <param name="pgType">Optional, overrides the Postgresql column type for the duplicated field</param>
            <param name="configure">
                Optional, allows you to customize the Postgresql database index configured for the duplicated
                field
            </param>
            <param name="dbType">Optional, overrides the Npgsql DbType for any parameter usage of this property</param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.Index(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Action{Marten.Schema.ComputedIndex})">
            <summary>
                Creates a computed index on this data member within the JSON data storage
            </summary>
            <param name="expression"></param>
            <param name="configure"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.Index(System.Collections.Generic.IReadOnlyCollection{System.Linq.Expressions.Expression{System.Func{`0,System.Object}}},System.Action{Marten.Schema.ComputedIndex})">
            <summary>
                Creates a computed index on this data member within the JSON data storage
            </summary>
            <param name="expressions"></param>
            <param name="configure"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.UniqueIndex(System.Linq.Expressions.Expression{System.Func{`0,System.Object}}[])">
            <summary>
                Creates a unique index on this data member within the JSON data storage
            </summary>
            <param name="expressions"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.UniqueIndex(System.String,System.Linq.Expressions.Expression{System.Func{`0,System.Object}}[])">
            <summary>
                Creates a unique index on this data member within the JSON data storage
            </summary>
            <param name="indexName">Name of the index</param>
            <param name="expressions"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.UniqueIndex(Marten.Schema.UniqueIndexType,System.Linq.Expressions.Expression{System.Func{`0,System.Object}}[])">
            <summary>
                Creates a unique index on this data member within the JSON data storage
            </summary>
            <param name="indexType">Type of the index</param>
            <param name="expressions"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.UniqueIndex(Marten.Schema.UniqueIndexType,System.String,System.Linq.Expressions.Expression{System.Func{`0,System.Object}}[])">
            <summary>
                Creates a unique index on this data member within the JSON data storage
            </summary>
            <param name="indexType">Type of the index</param>
            <param name="indexName">Name of the index</param>
            <param name="expressions"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.UniqueIndex(Marten.Schema.UniqueIndexType,System.String,Marten.Schema.Indexing.Unique.TenancyScope,System.Linq.Expressions.Expression{System.Func{`0,System.Object}}[])">
            <summary>
                Creates a unique index on this data member within the JSON data storage
            </summary>
            <param name="indexType">Type of the index</param>
            <param name="indexTenancyStyle">Style of tenancy</param>
            <param name="indexName">Name of the index</param>
            <param name="tenancyScope">Whether the unique index applies on a per tenant basis</param>
            <param name="expressions"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.IndexLastModified(System.Action{Marten.Schema.DocumentIndex})">
            <summary>
                Creates an index on the predefined Last Modified column
            </summary>
            <param name="configure"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.IndexCreatedAt(System.Action{Marten.Schema.DocumentIndex})">
            <summary>
                Creates an index on the predefined Created timestamp column
            </summary>
            <param name="configure"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.FullTextIndex(System.String,System.Action{Weasel.Postgresql.Tables.Indexes.FullTextIndexDefinition})">
            <summary>
                Create a full text index
            </summary>
            <param name="regConfig"></param>
            <param name="configure"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.FullTextIndex(System.Action{Weasel.Postgresql.Tables.Indexes.FullTextIndexDefinition})">
            <summary>
                Create a full text index
            </summary>
            <param name="configure"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.FullTextIndex(System.Linq.Expressions.Expression{System.Func{`0,System.Object}}[])">
            <summary>
                Create a full text index against designated fields on this document
            </summary>
            <param name="expressions"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.FullTextIndex(System.String,System.Linq.Expressions.Expression{System.Func{`0,System.Object}}[])">
            <summary>
                Create a full text index against designated fields on this document
            </summary>
            <param name="expressions"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.FullTextIndex(System.Action{Weasel.Postgresql.Tables.Indexes.FullTextIndexDefinition},System.Linq.Expressions.Expression{System.Func{`0,System.Object}}[])">
            <summary>
                Create a full text index against designated fields on this document
            </summary>
            <param name="expressions"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.NgramIndex(System.Action{Marten.Schema.NgramIndex})">
            <summary>
                Creates an n-gram index for the field which can be used for substring based matching, similar to the trigram
                extension but also generates uni-grams and bi-grams.
            </summary>
            <param name="configure">
            </param>
            <returns>
            </returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.NgramIndex(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
                Creates an n-gram index for the field which can be used for substring based matching, similar to the trigram
                extension but also generates uni-grams and bi-grams.
            </summary>
            <param name="expression">
            </param>
            <returns>
            </returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.NgramIndex(System.Action{Marten.Schema.NgramIndex},System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
                Creates an n-gram index for the field which can be used for substring based matching, similar to the trigram
                extension but also generates uni-grams and bi-grams.
            </summary>
            <param name="configure">
            </param>
            <param name="expression">
            </param>
            <returns>
            </returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.ForeignKey``1(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Action{Marten.Schema.DocumentForeignKey},System.Action{Marten.Schema.DocumentIndex})">
            <summary>
                Add a foreign key reference to another document type
            </summary>
            <param name="expression"></param>
            <param name="foreignKeyConfiguration"></param>
            <param name="indexConfiguration"></param>
            <typeparam name="TReference"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.ForeignKey(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String,System.String,System.String,System.Action{Weasel.Postgresql.Tables.ForeignKey})">
            <summary>
                Create a foreign key against the designated member of the document
            </summary>
            <param name="expression"></param>
            <param name="schemaName"></param>
            <param name="tableName"></param>
            <param name="columnName"></param>
            <param name="foreignKeyConfiguration"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.HiloSettings(Marten.Schema.Identity.Sequences.HiloSettings)">
            <summary>
                Overrides the Hilo sequence increment and "maximum low" number for document types that
                use numeric id's and the Hilo Id assignment
            </summary>
            <param name="settings"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.DatabaseSchemaName(System.String)">
            <summary>
                Overrides the database schema name used to store the documents.
            </summary>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.IdStrategy(Marten.Schema.Identity.IIdGeneration)">
            <summary>
                Overrides the stragtegy used for id generation.
            </summary>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.Identity(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
                Explicitly choose the identity member for this document type
            </summary>
            <param name="member"></param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.GinIndexJsonData(System.Action{Marten.Schema.DocumentIndex})">
            <summary>
                Adds a Postgresql Gin index to the JSONB data column for this document type. Leads to faster
                querying, but does add overhead to storage and database writes
            </summary>
            <param name="configureIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.AddSubClass(System.Type,System.String)">
            <summary>
                Programmatically directs Marten to map this type to a hierarchy of types
            </summary>
            <param name="subclassType"></param>
            <param name="alias"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.AddSubClassHierarchy(Marten.MappedType[])">
            <summary>
                Programmatically directs Marten to map all the subclasses of <cref name="T" /> to a hierarchy of types
            </summary>
            <param name="allSubclassTypes">
                All the subclass types of <cref name="T" /> that you wish to map.
                You can use either params of <see cref="T:System.Type" /> or <see cref="T:Marten.MappedType" /> or a mix, since Type can implicitly
                convert to MappedType (without an alias)
            </param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.AddSubClassHierarchy">
            <summary>
                Programmatically directs Marten to map all the subclasses of <cref name="T" /> to a hierarchy of types.
                <c>Unadvised in projects with many types.</c>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.AddSubClass``1(System.String)">
            <summary>
                Add a sub class type to the top level document type so that Marten will store that document in the parent
                table storage
            </summary>
            <param name="alias"></param>
            <typeparam name="TSubclass"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.UseOptimisticConcurrency(System.Boolean)">
            <summary>
                Directs Marten to use the optimistic versioning checks upon updates
                to this document type
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.UseNumericRevisions(System.Boolean)">
            <summary>
            Directs Marten to use the numeric revisioning for this specific
            document type
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.SoftDeleted">
            <summary>
                Directs Marten to apply "soft deletes" to this document type
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.SoftDeletedWithIndex(System.Action{Marten.Schema.DocumentIndex})">
            <summary>
                Mark this document type as soft-deleted, with an index on the is_deleted column
            </summary>
            <param name="configure"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.DdlTemplate(System.String)">
            <summary>
                Direct this document type's DDL to be created with the named template
            </summary>
            <param name="templateName"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.MultiTenanted">
            <summary>
                Marks just this document type as being stored with conjoined multi-tenancy
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.SingleTenanted">
            <summary>
                Marks just this document type as being stored with single tenancy style
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.UseIdentityKey">
            <summary>
                Opt into the identity key generation strategy
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.Metadata(System.Action{Marten.MartenRegistry.DocumentMappingExpression{`0}.MetadataConfig})">
            <summary>
                Configure the metadata storage for only this document type
            </summary>
            <param name="configure"></param>
            <returns></returns>
        </member>
        <member name="P:Marten.MartenRegistry.DocumentMappingExpression`1.MetadataConfig.Version">
            <summary>
                The current version of this document in the database
            </summary>
        </member>
        <member name="P:Marten.MartenRegistry.DocumentMappingExpression`1.MetadataConfig.LastModified">
            <summary>
                Timestamp of the last time this document was modified
            </summary>
        </member>
        <member name="P:Marten.MartenRegistry.DocumentMappingExpression`1.MetadataConfig.CreatedAt">
            <summary>
                Optional metadata for the timestamp of when this document was created
            </summary>
        </member>
        <member name="P:Marten.MartenRegistry.DocumentMappingExpression`1.MetadataConfig.TenantId">
            <summary>
                The stored tenant id of this document
            </summary>
        </member>
        <member name="P:Marten.MartenRegistry.DocumentMappingExpression`1.MetadataConfig.IsSoftDeleted">
            <summary>
                If soft-deleted, whether or not the document is marked as deleted
            </summary>
        </member>
        <member name="P:Marten.MartenRegistry.DocumentMappingExpression`1.MetadataConfig.SoftDeletedAt">
            <summary>
                If soft-deleted, the time at which the document was marked as deleted
            </summary>
        </member>
        <member name="P:Marten.MartenRegistry.DocumentMappingExpression`1.MetadataConfig.DocumentType">
            <summary>
                If the document is part of a type hierarchy, this designates
                Marten's internal name for the sub type
            </summary>
        </member>
        <member name="P:Marten.MartenRegistry.DocumentMappingExpression`1.MetadataConfig.DotNetType">
            <summary>
                The full name of the .Net type that was persisted
            </summary>
        </member>
        <member name="P:Marten.MartenRegistry.DocumentMappingExpression`1.MetadataConfig.CorrelationId">
            <summary>
                Optional metadata describing the correlation id for a
                unit of work
            </summary>
        </member>
        <member name="P:Marten.MartenRegistry.DocumentMappingExpression`1.MetadataConfig.CausationId">
            <summary>
                Optional metadata describing the correlation id for a
                unit of work
            </summary>
        </member>
        <member name="P:Marten.MartenRegistry.DocumentMappingExpression`1.MetadataConfig.LastModifiedBy">
            <summary>
                Optional metadata describing the user name or
                process name for this unit of work
            </summary>
        </member>
        <member name="P:Marten.MartenRegistry.DocumentMappingExpression`1.MetadataConfig.Headers">
            <summary>
                Optional, user defined headers
            </summary>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.MetadataConfig.DisableInformationalFields">
            <summary>
                Turn off the informational metadata columns
                in storage like the last modified, version, and
                dot net type for leaner storage
            </summary>
        </member>
        <member name="P:Marten.MartenRegistry.DocumentMappingExpression`1.MetadataConfig.Column`1.Enabled">
            <summary>
                Is the metadata field enabled. Note that this can not
                be overridden in some cases like the "version" column
                when a document uses optimistic versioning
            </summary>
        </member>
        <member name="M:Marten.MartenRegistry.DocumentMappingExpression`1.MetadataConfig.Column`1.MapTo(System.Linq.Expressions.Expression{System.Func{`0,`1}})">
            <summary>
                Map this metadata information to the designated Field or Property
                on the document type. This will also enable the tracking column
                in the underlying database table
            </summary>
            <param name="memberExpression"></param>
        </member>
        <member name="T:Marten.MappedType">
            <summary>
                Configures hierarchical type mapping to its parent
            </summary>
        </member>
        <member name="P:Marten.MappedType.Type">
            <summary>
                The .Net Type
            </summary>
        </member>
        <member name="P:Marten.MappedType.Alias">
            <summary>
                String alias that will be used to persist or load the documents
                from the underlying database
            </summary>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.ConfigureMartenWithServices``1(Microsoft.Extensions.DependencyInjection.IServiceCollection)">
            <summary>
                Apply additional configuration to a Marten DocumentStore. This is applied *after*
                AddMarten(), but before the DocumentStore is initialized
            </summary>
            <param name="services"></param>
            <param name="configure"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.ConfigureMarten(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Action{Marten.StoreOptions})">
            <summary>
                Apply additional configuration to a Marten DocumentStore. This is applied *after*
                AddMarten(), but before the DocumentStore is initialized
            </summary>
            <param name="services"></param>
            <param name="configure"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.ConfigureMarten(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Action{System.IServiceProvider,Marten.StoreOptions})">
            <summary>
                Apply additional configuration to a Marten DocumentStore. This is applied *after*
                AddMarten(), but before the DocumentStore is initialized
            </summary>
            <param name="services"></param>
            <param name="configure"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Marten.MartenServiceCollectionExtensions.ConfigureMarten``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Action{System.IServiceProvider,Marten.StoreOptions})" -->
        <!-- Badly formed XML comment ignored for member "M:Marten.MartenServiceCollectionExtensions.ConfigureMarten``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Action{Marten.StoreOptions})" -->
        <member name="M:Marten.MartenServiceCollectionExtensions.AddMarten(Microsoft.Extensions.DependencyInjection.IServiceCollection)">
            <summary>
                Add Marten IDocumentStore, IDocumentSession, and IQuerySession service registrations
                to your application with the given Postgresql connection string and Marten
                defaults
            </summary>
            <remarks>
            You need to configure connection settings through DI, e.g. by calling `UseNpgsqlDataSource`
            and configuring `NpqsqlDataSource` with `AddNpgsqlDataSource` from `Npgsql.DependencyInjection`
            </remarks>
            <param name="services"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.AddMarten(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.String)">
            <summary>
                Add Marten IDocumentStore, IDocumentSession, and IQuerySession service registrations
                to your application with the given Postgresql connection string and Marten
                defaults
            </summary>
            <param name="services"></param>
            <param name="connectionString">The connection string to your application's Postgresql database</param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.AddMarten(Microsoft.Extensions.DependencyInjection.IServiceCollection,Marten.StoreOptions)">
            <summary>
                Add Marten IDocumentStore, IDocumentSession, and IQuerySession service registrations
                to your application using the configured StoreOptions
            </summary>
            <param name="services"></param>
            <param name="options">The Marten configuration for this application</param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.AddMarten(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Func{System.IServiceProvider,Marten.StoreOptions})">
            <summary>
                Add Marten IDocumentStore, IDocumentSession, and IQuerySession service registrations
                to your application by configuring a StoreOptions using services in your DI container
            </summary>
            <param name="optionSource">Func that will build out a StoreOptions with the applications IServiceProvider as the input</param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.AddMarten(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Action{Marten.StoreOptions})">
            <summary>
                Add Marten IDocumentStore, IDocumentSession, and IQuerySession service registrations
                to your application using the configured StoreOptions
            </summary>
            <param name="services"></param>
            <param name="configure"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.AddMartenStore``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Action{Marten.StoreOptions})">
            <summary>
                Add a secondary IDocumentStore service to the container using only
                an interface "T" that should directly inherit from IDocumentStore
            </summary>
            <param name="services"></param>
            <param name="configure"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.AddMartenStore``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Func{System.IServiceProvider,Marten.StoreOptions})">
            <summary>
                Add a secondary IDocumentStore service to the container using only
                an interface "T" that should directly inherit from IDocumentStore
            </summary>
            <param name="services"></param>
            <param name="configure"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.InitializeMartenWith``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,Marten.Schema.IInitialData[])">
            <summary>
                Adds initial data sets to the separate Marten store of type "T" and ensures that they will be
                executed upon IHost initialization
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.InitializeMartenWith``2(Microsoft.Extensions.DependencyInjection.IServiceCollection)">
            <summary>
                Registers type T as a singleton against IInitialData to be used in IHost activation
                to apply changes or at least actions against the as built IDocumentStore
            </summary>
            <typeparam name="TData">The type that implements IInitialData</typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.InitializeMartenWith(Microsoft.Extensions.DependencyInjection.IServiceCollection,Marten.Schema.IInitialData[])">
            <summary>
                Adds initial data sets to the Marten store and ensures that they will be
                executed upon IHost initialization
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.InitializeMartenWith``1(Microsoft.Extensions.DependencyInjection.IServiceCollection)">
            <summary>
                Registers type T as a singleton against IInitialData to be used in IHost activation
                to apply changes or at least actions against the as built IDocumentStore
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.MartenStoreExpression`1.OptimizeArtifactWorkflow">
            <summary>
                Adds the optimized artifact workflow to the store "T"
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.MartenStoreExpression`1.OptimizeArtifactWorkflow(System.String)">
            <summary>
                Adds the optimized artifact workflow to the store "T"
            </summary>
            <param name="developmentEnvironment"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.MartenStoreExpression`1.OptimizeArtifactWorkflow(JasperFx.CodeGeneration.TypeLoadMode)">
            <summary>
                Adds the optimized artifact workflow to the store "T"
            </summary>
            <param name="typeLoadMode"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.MartenStoreExpression`1.OptimizeArtifactWorkflow(JasperFx.CodeGeneration.TypeLoadMode,System.String)">
            <summary>
                Adds the optimized artifact workflow to the store "T"
            </summary>
            <param name="typeLoadMode"></param>
            <param name="developmentEnvironment"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.MartenStoreExpression`1.AddAsyncDaemon(Marten.Events.Daemon.Resiliency.DaemonMode)">
            <summary>
                Register the Async Daemon hosted service to continuously attempt to update asynchronous event projections
            </summary>
            <param name="mode"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.MartenStoreExpression`1.ApplyAllDatabaseChangesOnStartup">
            <summary>
                Adds a hosted service to your .Net application that will attempt to apply any detected database changes before the
                rest of the application starts running
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.MartenStoreExpression`1.InitializeWith(Marten.Schema.IInitialData[])">
            <summary>
                Adds initial data sets to the Marten store and ensures that they will be
                executed upon IHost initialization
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.MartenStoreExpression`1.InitializeWith``1">
            <summary>
                Registers type T as a singleton against IInitialData to be used in IHost activation
                to apply changes or at least actions against the as built IDocumentStore
            </summary>
            <typeparam name="TData">The type that implements IInitialData</typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.MartenStoreExpression`1.AddProjectionWithServices``1(Marten.Events.Projections.ProjectionLifecycle,Microsoft.Extensions.DependencyInjection.ServiceLifetime)">
            <summary>
            Add a projection to this application that requires IoC services. The projection itself will
            be created with the application's IoC container
            </summary>
            <param name="lifecycle">The projection lifecycle for Marten</param>
            <param name="lifetime">The IoC lifecycle for the projection instance. Note that the Transient lifetime will still be treated as Scoped</param>
            /// <typeparam name="TProjection">The type of projection to add</typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.MartenStoreExpression`1.AddProjectionWithServices``1(Marten.Events.Projections.ProjectionLifecycle,Microsoft.Extensions.DependencyInjection.ServiceLifetime,System.String)">
            <summary>
            Add a projection to this application that requires IoC services. The projection itself will
            be created with the application's IoC container
            </summary>
            <param name="lifecycle">The projection lifecycle for Marten</param>
            <param name="lifetime">The IoC lifecycle for the projection instance. Note that the Transient lifetime will still be treated as Scoped</param>
            <typeparam name="TProjection">The type of projection to add</typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.MartenStoreExpression`1.AddSubscriptionWithServices``1(Microsoft.Extensions.DependencyInjection.ServiceLifetime,System.Action{Marten.Subscriptions.ISubscriptionOptions})">
            <summary>
            Add a subscription to this Marten store that will require resolution
            from the application's IoC container in order to function correctly
            </summary>
            <param name="lifetime">IoC service lifetime</param>
            <param name="configure">Optional configuration of the subscription within Marten</param>
            <typeparam name="T">The type of projection to add</typeparam>
            <returns></returns>
        </member>
        <member name="P:Marten.MartenServiceCollectionExtensions.MartenConfigurationExpression.Services">
            <summary>
                Gets the IServiceCollection
            </summary>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.MartenConfigurationExpression.BuildSessionsWith``1(Microsoft.Extensions.DependencyInjection.ServiceLifetime)">
            <summary>
                Use an alternative strategy / configuration for opening IDocumentSession or IQuerySession
                objects in the application with a custom ISessionFactory type registered as a singleton
            </summary>
            <param name="lifetime">
                IoC service lifetime for the session factory. Default is Singleton, but use Scoped if you need
                to reference per-scope services
            </param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.MartenConfigurationExpression.ApplyAllDatabaseChangesOnStartup">
            <summary>
                Adds a hosted service to your .Net application that will attempt to apply any detected database changes before the
                rest of the application starts running
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.MartenConfigurationExpression.AssertDatabaseMatchesConfigurationOnStartup">
            <summary>
                Adds a hosted service to your .Net application that will assert that database matches configuration before the
                rest of the application starts running. Prevents the application from starting if database does not match
                configuration.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.MartenConfigurationExpression.AddAsyncDaemon(Marten.Events.Daemon.Resiliency.DaemonMode)">
            <summary>
                Register the Async Daemon hosted service to continuously attempt to update asynchronous event projections
            </summary>
            <param name="mode"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.MartenConfigurationExpression.UseLightweightSessions">
            <summary>
                Use lightweight sessions by default for the injected IDocumentSession objects. Equivalent to
                IDocumentStore.LightweightSession();
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.MartenConfigurationExpression.UseIdentitySessions">
            <summary>
                Use identity sessions by default for the injected IDocumentSession objects. Equivalent to
                IDocumentStore.IdentitySession();
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.MartenConfigurationExpression.UseDirtyTrackedSessions">
            <summary>
                Use dirty-tracked sessions by default for the injected IDocumentSession objects. Equivalent to
                IDocumentStore.DirtyTrackedSession();
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.MartenConfigurationExpression.UseNpgsqlDataSource(System.Object)">
            <summary>
            Use configured NpgsqlDataSource from DI container
            </summary>
            <param name="serviceKey">NpgsqlDataSource service key as registered in DI</param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.MartenConfigurationExpression.UseNpgsqlDataSource(System.Func{System.String,Npgsql.NpgsqlDataSourceBuilder},System.Object)">
            <summary>
            Use configured NpgsqlDataSource from DI container
            </summary>
            <param name="dataSourceBuilderFactory">configuration of the data source builder</param>
            <param name="serviceKey">NpgsqlDataSource service key as registered in DI</param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.MartenConfigurationExpression.OptimizeArtifactWorkflow">
            <summary>
                Adds the optimized artifact workflow to this store.
                See https://martendb.io/configuration/optimized_artifact_workflow.html for more information.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.MartenConfigurationExpression.OptimizeArtifactWorkflow(JasperFx.CodeGeneration.TypeLoadMode)">
            <summary>
                Adds the optimized artifact workflow to this store with ability to override the TypeLoadMode in "Production" mode.
                See https://martendb.io/configuration/optimized_artifact_workflow.html for more information.
            </summary>
            <param name="typeLoadMode"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.MartenConfigurationExpression.OptimizeArtifactWorkflow(System.String)">
            <summary>
                Adds the optimized artifact workflow to this store.
                See https://martendb.io/configuration/optimized_artifact_workflow.html for more information.
            </summary>
            <param name="developmentEnvironment"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.MartenConfigurationExpression.OptimizeArtifactWorkflow(JasperFx.CodeGeneration.TypeLoadMode,System.String)">
            <summary>
                Adds the optimized artifact workflow to this store with ability to override the TypeLoadMode in "Production" mode.
                See https://martendb.io/configuration/optimized_artifact_workflow.html for more information.
            </summary>
            <param name="typeLoadMode"></param>
            <param name="developmentEnvironment"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.MartenConfigurationExpression.InitializeWith(Marten.Schema.IInitialData[])">
            <summary>
                Adds initial data sets to the Marten store and ensures that they will be
                executed upon IHost initialization
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.MartenConfigurationExpression.InitializeWith``1">
            <summary>
                Registers type T as a singleton against IInitialData to be used in IHost activation
                to apply changes or at least actions against the as built IDocumentStore
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.MartenConfigurationExpression.AddProjectionWithServices``1(Marten.Events.Projections.ProjectionLifecycle,Microsoft.Extensions.DependencyInjection.ServiceLifetime)">
            <summary>
            Add a projection to this application that requires IoC services. The projection itself will
            be created with the application's IoC container
            </summary>
            <param name="lifecycle">The projection lifecycle for Marten</param>
            <param name="lifetime">The IoC lifecycle for the projection instance. Note that the Transient lifetime will still be treated as Scoped</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.MartenConfigurationExpression.AddProjectionWithServices``1(Marten.Events.Projections.ProjectionLifecycle,Microsoft.Extensions.DependencyInjection.ServiceLifetime,System.String)">
            <summary>
            Add a projection to this application that requires IoC services. The projection itself will
            be created with the application's IoC container
            </summary>
            <param name="lifecycle">The projection lifecycle for Marten</param>
            <param name="lifetime">The IoC lifecycle for the projection instance. Note that the Transient lifetime will still be treated as Scoped</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.MartenServiceCollectionExtensions.MartenConfigurationExpression.AddSubscriptionWithServices``1(Microsoft.Extensions.DependencyInjection.ServiceLifetime,System.Action{Marten.Subscriptions.ISubscriptionOptions})">
            <summary>
            Add a subscription to this Marten store that will require resolution
            from the application's IoC container in order to function correctly
            </summary>
            <param name="lifetime">IoC service lifetime</param>
            <param name="configure">Optional configuration of the subscription within Marten</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:Marten.IConfigureMarten">
            <summary>
                Mechanism to register additional Marten configuration that is applied after AddMarten()
                configuration, but before DocumentStore is initialized
            </summary>
        </member>
        <member name="T:Marten.IAsyncConfigureMarten">
            <summary>
                Mechanism to register additional Marten configuration that is applied after AddMarten()
                configuration, but before DocumentStore is initialized when you need to utilize some
            kind of asynchronous services like Microsoft's FeatureManagement feature to configure Marten
            </summary>
        </member>
        <member name="M:Marten.MasterTableMultiTenancyExtensions.ClearAllTenantDatabaseRecordsAsync(Microsoft.Extensions.Hosting.IHost)">
            <summary>
            Convenience method to clear all tenant database records
            if using Marten
            </summary>
            <param name="host"></param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Marten.MasterTableMultiTenancyExtensions.AddTenantDatabaseAsync(Microsoft.Extensions.Hosting.IHost,System.String,System.String)">
            <summary>
            Convenience method to add a new tenant database to the master tenant table at runtime
            </summary>
            <param name="host"></param>
            <param name="tenantId"></param>
            <param name="connectionString"></param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="T:Marten.Metadata.IRevisioned">
            <summary>
                Optionally implement this interface on your Marten document
                types to opt into optimistic concurrency with the version
                being tracked on the Version property using numeric revision values
            </summary>
        </member>
        <member name="P:Marten.Metadata.IRevisioned.Version">
            <summary>
                Marten's version for this document
            </summary>
        </member>
        <member name="T:Marten.Metadata.ISoftDeleted">
            <summary>
                Optionally implement this interface on your Marten document
                types to opt into "soft delete" mechanics with the deletion
                information tracked directly on the documents
            </summary>
        </member>
        <member name="P:Marten.Metadata.ISoftDeleted.Deleted">
            <summary>
                Has Marten marked this document as soft deleted
            </summary>
        </member>
        <member name="P:Marten.Metadata.ISoftDeleted.DeletedAt">
            <summary>
                When was this document marked as deleted by Marten
            </summary>
        </member>
        <member name="T:Marten.Metadata.ITenanted">
            <summary>
                Optionally implement this interface on your Marten document
                types to opt into conjoined tenancy and track the tenant id
                on the document itself
            </summary>
        </member>
        <member name="T:Marten.Metadata.ITracked">
            <summary>
                Optionally implement this interface to add correlation
                tracking to your Marten document type with the tracking
                information available on the documents themselves
            </summary>
        </member>
        <member name="P:Marten.Metadata.ITracked.CorrelationId">
            <summary>
                Metadata describing the correlation id for the
                last system activity to edit this document
            </summary>
        </member>
        <member name="P:Marten.Metadata.ITracked.CausationId">
            <summary>
                Metadata describing the causation id for the
                last system activity to edit this document
            </summary>
        </member>
        <member name="P:Marten.Metadata.ITracked.LastModifiedBy">
            <summary>
                Metadata describing the user who last modified
                this document
            </summary>
        </member>
        <member name="T:Marten.Metadata.IVersioned">
            <summary>
                Optionally implement this interface on your Marten document
                types to opt into optimistic concurrency with the version
                being tracked on the Version property
            </summary>
        </member>
        <member name="P:Marten.Metadata.IVersioned.Version">
            <summary>
                Marten's version for this document
            </summary>
        </member>
        <member name="T:Marten.Pagination.IPagedList`1">
            <summary>
                Interface for paged list
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Marten.Pagination.IPagedList`1.Item(System.Int32)">
            <summary>
                Return the paged query result
            </summary>
            <param name="index">Index to fetch item from paged query result</param>
            <returns>/returns item from paged query result</returns>
        </member>
        <member name="P:Marten.Pagination.IPagedList`1.Count">
            <summary>
                Return the number of records in the paged query result
            </summary>
        </member>
        <member name="P:Marten.Pagination.IPagedList`1.PageNumber">
            <summary>
                Gets current page number
            </summary>
        </member>
        <member name="P:Marten.Pagination.IPagedList`1.PageSize">
            <summary>
                Gets page size
            </summary>
        </member>
        <member name="P:Marten.Pagination.IPagedList`1.PageCount">
            <summary>
                Gets number of pages
            </summary>
        </member>
        <member name="P:Marten.Pagination.IPagedList`1.TotalItemCount">
            <summary>
                Gets the total number records
            </summary>
        </member>
        <member name="P:Marten.Pagination.IPagedList`1.HasPreviousPage">
            <summary>
                Gets a value indicating whether there is a previous page
            </summary>
        </member>
        <member name="P:Marten.Pagination.IPagedList`1.HasNextPage">
            <summary>
                Gets a value indicating whether there is next page
            </summary>
        </member>
        <member name="P:Marten.Pagination.IPagedList`1.IsFirstPage">
            <summary>
                Gets a value indicating whether the current page is first page
            </summary>
        </member>
        <member name="P:Marten.Pagination.IPagedList`1.IsLastPage">
            <summary>
                Gets a value indicating whether the current page is last page
            </summary>
        </member>
        <member name="P:Marten.Pagination.IPagedList`1.FirstItemOnPage">
            <summary>
                Gets one-based index of first item in current page
            </summary>
        </member>
        <member name="P:Marten.Pagination.IPagedList`1.LastItemOnPage">
            <summary>
                Gets one-based index of last item in current page
            </summary>
        </member>
        <member name="T:Marten.Pagination.PagedList`1">
            <summary>
                Class to return The async paged list from a paged query.
            </summary>
            <typeparam name="T">Document Type</typeparam>
        </member>
        <member name="P:Marten.Pagination.PagedList`1.Item(System.Int32)">
            <summary>
                Return the paged query result
            </summary>
            <param name="index">Index to fetch item from paged query result</param>
            <returns>/returns item from paged query result</returns>
        </member>
        <member name="P:Marten.Pagination.PagedList`1.Count">
            <summary>
                Return the number of records in the paged query result
            </summary>
        </member>
        <member name="M:Marten.Pagination.PagedList`1.GetEnumerator">
            <summary>
                Generic Enumerator
            </summary>
            <returns>Generic Enumerator of paged query result</returns>
        </member>
        <member name="M:Marten.Pagination.PagedList`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
                Enumerator
            </summary>
            <returns>Enumerator of paged query result</returns>
        </member>
        <member name="P:Marten.Pagination.PagedList`1.PageNumber">
            <summary>
                Gets current page number
            </summary>
        </member>
        <member name="P:Marten.Pagination.PagedList`1.PageSize">
            <summary>
                Gets page size
            </summary>
        </member>
        <member name="P:Marten.Pagination.PagedList`1.PageCount">
            <summary>
                Gets number of pages
            </summary>
        </member>
        <member name="P:Marten.Pagination.PagedList`1.TotalItemCount">
            <summary>
                Gets the total number records
            </summary>
        </member>
        <member name="P:Marten.Pagination.PagedList`1.HasPreviousPage">
            <summary>
                Gets a value indicating whether there is a previous page
            </summary>
        </member>
        <member name="P:Marten.Pagination.PagedList`1.HasNextPage">
            <summary>
                Gets a value indicating whether there is next page
            </summary>
        </member>
        <member name="P:Marten.Pagination.PagedList`1.IsFirstPage">
            <summary>
                Gets a value indicating whether the current page is first page
            </summary>
        </member>
        <member name="P:Marten.Pagination.PagedList`1.IsLastPage">
            <summary>
                Gets a value indicating whether the current page is last page
            </summary>
        </member>
        <member name="P:Marten.Pagination.PagedList`1.FirstItemOnPage">
            <summary>
                Gets one-based index of first item in current page
            </summary>
        </member>
        <member name="P:Marten.Pagination.PagedList`1.LastItemOnPage">
            <summary>
                Gets one-based index of last item in current page
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Marten.Pagination.PagedList`1.Create(System.Linq.IQueryable{`0},System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Marten.Pagination.PagedList`1.CreateAsync(System.Linq.IQueryable{`0},System.Int32,System.Int32,System.Threading.CancellationToken)" -->
        <member name="M:Marten.Pagination.PagedList`1.Init(System.Linq.IQueryable{`0},System.Int32,System.Int32)">
            <summary>
                Initializes a new instance of the <see cref="T:Marten.Pagination.PagedList`1" /> class.
            </summary>
            <param name="queryable">Query for which data has to be fetched</param>
            <param name="pageSize">Page size</param>
            <param name="totalItemCount">Total count of all records</param>
        </member>
        <member name="M:Marten.Pagination.PagedList`1.InitAsync(System.Linq.IQueryable{`0},System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
                Initializes a new instance of the <see cref="T:Marten.Pagination.PagedList`1" /> class.
            </summary>
            <param name="queryable">Query for which data has to be fetched</param>
            <param name="pageSize">Page size</param>
            <param name="totalItemCount">Total count of all records</param>
        </member>
        <member name="T:Marten.Pagination.PagedListQueryableExtensions">
            <summary>
                Extension methods on <see cref="T:Marten.Linq.IMartenQueryable`1" /> for performing paged queries
            </summary>
        </member>
        <member name="M:Marten.Pagination.PagedListQueryableExtensions.ToPagedList``1(System.Linq.IQueryable{``0},System.Int32,System.Int32)">
            <summary>
                Extension method to return a paged results
            </summary>
            <typeparam name="T">Document Type</typeparam>
            <param name="queryable">Extension point on <see cref="T:System.Linq.IQueryable`1" /></param>
            <param name="pageNumber">one based page number</param>
            <param name="pageSize">Page size</param>
            <returns>return paged result</returns>
        </member>
        <member name="M:Marten.Pagination.PagedListQueryableExtensions.ToPagedListAsync``1(System.Linq.IQueryable{``0},System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
                Async Extension method to return a paged results
            </summary>
            <typeparam name="T">Document Type</typeparam>
            <param name="queryable">Extension point on <see cref="T:System.Linq.IQueryable`1" /></param>
            <param name="pageNumber">One based page number</param>
            <param name="pageSize">Page size</param>
            <param name="token">Cancellation token</param>
            <returns>return paged result</returns>
        </member>
        <member name="M:Marten.Patching.IPatchExpression`1.Set``1(System.String,``0)">
            <summary>
            Set a single field or property value within the persisted JSON data
            </summary>
            <param name="name"></param>
            <param name="value"></param>
            <typeparam name="TValue"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Patching.IPatchExpression`1.Set``2(System.String,System.Linq.Expressions.Expression{System.Func{`0,``0}},``1)">
            <summary>
            Set a single field or property value within the persisted JSON data
            </summary>
            <typeparam name="TParent"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="name"></param>
            <param name="expression">Path to the parent location</param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Patching.IPatchExpression`1.Set``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},``0)">
            <summary>
            Set a single field or property value within the persisted JSON data
            </summary>
            <typeparam name="TValue"></typeparam>
            <param name="expression"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Patching.IPatchExpression`1.Duplicate``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Linq.Expressions.Expression{System.Func{`0,``0}}[])">
            <summary>
            Copy a single field or property value within the persisted JSON data to one or more destinations
            </summary>
            <typeparam name="TElement"></typeparam>
            <param name="expression"></param>
            <param name="destinations"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Patching.IPatchExpression`1.Increment(System.Linq.Expressions.Expression{System.Func{`0,System.Int32}},System.Int32)">
            <summary>
            Increment a single field or property by adding the increment value
            to the persisted value
            </summary>
            <param name="expression"></param>
            <param name="increment"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Patching.IPatchExpression`1.Increment(System.Linq.Expressions.Expression{System.Func{`0,System.Int64}},System.Int64)">
            <summary>
            Increment a single field or property by adding the increment value
            to the persisted value
            </summary>
            <param name="expression"></param>
            <param name="increment"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Patching.IPatchExpression`1.Increment(System.Linq.Expressions.Expression{System.Func{`0,System.Double}},System.Double)">
            <summary>
            Increment a single field or property by adding the increment value
            to the persisted value
            </summary>
            <param name="expression"></param>
            <param name="increment"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Patching.IPatchExpression`1.Increment(System.Linq.Expressions.Expression{System.Func{`0,System.Single}},System.Single)">
            <summary>
            Increment a single field or property by adding the increment value
            to the persisted value
            </summary>
            <param name="expression"></param>
            <param name="increment"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Patching.IPatchExpression`1.Append``1(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.IEnumerable{``0}}},``0)">
            <summary>
            Append an element to the end of a child collection on the persisted
            document
            </summary>
            <typeparam name="TElement"></typeparam>
            <param name="expression"></param>
            <param name="element"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Patching.IPatchExpression`1.AppendIfNotExists``1(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.IEnumerable{``0}}},``0)">
            <summary>
            Append an element to the end of a child collection on the persisted
            document if the element does not already exist
            </summary>
            <typeparam name="TElement"></typeparam>
            <param name="expression"></param>
            <param name="element"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Patching.IPatchExpression`1.Insert``1(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.IEnumerable{``0}}},``0,System.Nullable{System.Int32})">
            <summary>
            Insert an element at the designated index to a child collection on the persisted document
            </summary>
            <typeparam name="TElement"></typeparam>
            <param name="expression"></param>
            <param name="element"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Patching.IPatchExpression`1.InsertIfNotExists``1(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.IEnumerable{``0}}},``0,System.Nullable{System.Int32})">
            <summary>
            Insert an element at the designated index to a child collection on the persisted document
            if the value does not already exist at that index
            </summary>
            <typeparam name="TElement"></typeparam>
            <param name="expression"></param>
            <param name="element"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Patching.IPatchExpression`1.Remove``1(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.IEnumerable{``0}}},``0,Marten.Patching.RemoveAction)">
            <summary>
            Remove element from a child collection on the persisted document
            </summary>
            <typeparam name="TElement"></typeparam>
            <param name="expression"></param>
            <param name="element"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Patching.IPatchExpression`1.Rename(System.String,System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Rename a property or field in the persisted JSON document
            </summary>
            <param name="oldName"></param>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Patching.IPatchExpression`1.Delete(System.String)">
            <summary>
            Delete a removed property or field in the persisted JSON data
            </summary>
            <param name="name">Redundant property or field name</param>
            <returns></returns>
        </member>
        <member name="M:Marten.Patching.IPatchExpression`1.Delete``1(System.String,System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Delete a removed property or field in the persisted JSON data
            </summary>
            <typeparam name="TParent"></typeparam>
            <param name="name">Redundant property or field name</param>
            <param name="expression">Path to the parent location</param>
            <returns></returns>
        </member>
        <member name="M:Marten.Patching.IPatchExpression`1.Delete``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Delete an existing property or field in the persisted JSON data
            </summary>
            <typeparam name="TElement"></typeparam>
            <param name="expression">Path to the property or field to delete</param>
            <returns></returns>
        </member>
        <member name="M:Marten.Patching.PatchingExtensions.Patch``1(Marten.IDocumentOperations,System.Int32)">
            <summary>
            Patch a single document of type T with the given id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Patching.PatchingExtensions.Patch``1(Marten.IDocumentOperations,System.Int64)">
            <summary>
            Patch a single document of type T with the given id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Patching.PatchingExtensions.Patch``1(Marten.IDocumentOperations,System.String)">
            <summary>
            Patch a single document of type T with the given id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Patching.PatchingExtensions.Patch``1(Marten.IDocumentOperations,System.Guid)">
            <summary>
            Patch a single document of type T with the given id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Patching.PatchingExtensions.Patch``1(Marten.IDocumentOperations,System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Patch a single document of type T with the given id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <param name="where"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Patching.PatchingExtensions.Patch``1(Marten.IDocumentOperations,Weasel.Postgresql.SqlGeneration.ISqlFragment)">
            <summary>
            Patch multiple documents matching the supplied where fragment
            </summary>
            <typeparam name="T"></typeparam>
            <param name="fragment"></param>
            <returns></returns>
        </member>
        <member name="F:Marten.Patching.RemoveAction.RemoveFirst">
            <summary>
            Remove the first occurrence
            </summary>
        </member>
        <member name="F:Marten.Patching.RemoveAction.RemoveAll">
            <summary>
            Remove all occurrences
            </summary>
        </member>
        <member name="M:Marten.QueryableExtensions.Explain``1(System.Linq.IQueryable{``0},System.Action{Marten.Linq.IConfigureExplainExpressions})">
            <summary>
                Fetch the Postgresql QueryPlan for the Linq query
            </summary>
            <param name="queryable"></param>
            <param name="configureExplain"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.QueryableExtensions.ToListAsync``1(System.Linq.IQueryable{``0},System.Threading.CancellationToken)">
            <summary>
                Fetch results asynchronously to a read only list
            </summary>
            <param name="queryable"></param>
            <param name="token"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.QueryableExtensions.ToCommand``1(System.Linq.IQueryable{``0},Marten.Linq.FetchType)">
            <summary>
                Builds the database command that would be used to execute this Linq query
            </summary>
            <param name="queryable"></param>
            <param name="fetchType"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Marten.QueryableExtensions.Include``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.Action{``1})">
            <summary>
                Fetch a related document of type TInclude when executing the Linq query and
                call the supplied callback for each result
            </summary>
            <param name="queryable"></param>
            <param name="idSource"></param>
            <param name="callback"></param>
            <typeparam name="T"></typeparam>
            <typeparam name="TInclude"></typeparam>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Marten.QueryableExtensions.Include``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.Collections.Generic.IList{``1})" -->
        <member name="M:Marten.QueryableExtensions.Include``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.Collections.Generic.IDictionary{``1,``2})">
            <summary>
                Fetch related documents when executing the Linq query and store the related documents
                into the supplied dictionary
            </summary>
            <param name="queryable"></param>
            <param name="idSource"></param>
            <param name="dictionary"></param>
            <typeparam name="T"></typeparam>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TInclude"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.QueryableExtensions.Include``2(System.Linq.IQueryable{``0},System.Action{``1})">
            <summary>
                Also fetch related documents, and call the callback lambda for each
                related document. Follow this with <c>.On(idSource)</c> to specify how to
                map to this document.
            </summary>
            <param name="callback"></param>
            <typeparam name="T"></typeparam>
            <typeparam name="TInclude"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.QueryableExtensions.Include``2(System.Linq.IQueryable{``0},System.Collections.Generic.IList{``1})">
            <summary>
                Also fetch related documents, and add the related documents to
                the supplied list. Follow this with <c>.On(idSource)</c> to specify how to
                map to this document.
            </summary>
            <param name="idSource"></param>
            <param name="list"></param>
            <typeparam name="T"></typeparam>
            <typeparam name="TInclude"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.QueryableExtensions.Include``3(System.Linq.IQueryable{``0},System.Collections.Generic.IDictionary{``1,``2})">
            <summary>
                Also fetch related documents, and add the related documents to
                the supplied dictionary organized by the property mapped to the related
                document. Follow this with <c>.On(idSource)</c> to specify how to map to
                this document.
            </summary>
            <param name="idSource"></param>
            <param name="dictionary"></param>
            <typeparam name="T"></typeparam>
            <typeparam name="TInclude"></typeparam>
            <typeparam name="TKey"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.QueryableExtensions.Include``3(System.Linq.IQueryable{``0},System.Collections.Generic.IDictionary{``1,System.Collections.Generic.IList{``2}})">
            <summary>
                Also fetch related documents, and add the related documents to
                the supplied dictionary of lists organized by the property mapped to the
                related document. Follow this with <c>.On(idSource)</c> to specify how
                to map to this document.
            </summary>
            <param name="idSource"></param>
            <param name="dictionary"></param>
            <typeparam name="T"></typeparam>
            <typeparam name="TInclude"></typeparam>
            <typeparam name="TKey"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.QueryableExtensions.Include``3(System.Linq.IQueryable{``0},System.Collections.Generic.IDictionary{``1,System.Collections.Generic.List{``2}})">
            <summary>
                Also fetch related documents, and add the related documents to
                the supplied dictionary of lists organized by the property mapped to the
                related document. Follow this with <c>.On(idSource)</c> to specify how
                to map to this document.
            </summary>
            <param name="idSource"></param>
            <param name="dictionary"></param>
            <typeparam name="T"></typeparam>
            <typeparam name="TInclude"></typeparam>
            <typeparam name="TKey"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.QueryableExtensions.ToAsyncEnumerable``1(System.Linq.IQueryable{``0},System.Threading.CancellationToken)">
            <summary>
                Execute this query to an IAsyncEnumerable. This is valuable for reading
                and processing large result sets without having to keep the entire
                result set in memory
            </summary>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.QueryableExtensions.StreamJsonArray``1(System.Linq.IQueryable{``0},System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
                Write the raw persisted JSON for the Linq query directly to the destination stream
            </summary>
            <param name="destination"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.QueryableExtensions.OrderBy``1(System.Linq.IQueryable{``0},System.String[])">
            <summary>
                Order by multiple properties in ascending order i.e. "prop1", "prop2"
                or order by multiple properties with their respective sort order i.e. "prop1", "prop2 ASC|asc", "prop3 DESC|desc"
            </summary>
            <param name="queryable"></param>
            <param name="properties"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:Marten.QueryableExtensions.OrderBy``1(Marten.Services.BatchQuerying.IBatchedQueryable{``0},System.String[])">
            <summary>
                Order by multiple properties in ascending order i.e. "prop1", "prop2"
                or order by multiple properties with their respective sort order i.e. "prop1", "prop2 ASC|asc", "prop3 DESC|desc"
            </summary>
            <param name="queryable"></param>
            <param name="properties"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:Marten.QueryableExtensions.OrderBy``1(System.Linq.IQueryable{``0},System.String)">
            <summary>
                Order by a single property in ascending order
            </summary>
            <param name="queryable"></param>
            <param name="property"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.QueryableExtensions.OrderBy``1(System.Linq.IQueryable{``0},System.String,System.StringComparer)">
            <summary>
            Order by a single property name or [property name] [asc/desc] and a StringComparer value
            </summary>
            <param name="queryable"></param>
            <param name="property"></param>
            <param name="comparer"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.QueryableExtensions.OrderBy``1(Marten.Services.BatchQuerying.IBatchedQueryable{``0},System.String)">
            <summary>
                Order by a single property in ascending order
            </summary>
            <param name="queryable"></param>
            <param name="property"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.QueryableExtensions.OrderByDescending``1(System.Linq.IQueryable{``0},System.String)">
            <summary>
                Order by a single property in descending order
            </summary>
            <param name="queryable"></param>
            <param name="property"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.QueryableExtensions.OrderByDescending``1(Marten.Services.BatchQuerying.IBatchedQueryable{``0},System.String)">
            <summary>
                Order by a single property in descending order
            </summary>
            <param name="queryable"></param>
            <param name="property"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.QueryableExtensions.ThenBy``1(System.Linq.IOrderedQueryable{``0},System.String)">
            <summary>
                Chain another order by using a single property in ascending order
            </summary>
            <param name="queryable"></param>
            <param name="property"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.QueryableExtensions.ThenBy``1(Marten.Services.BatchQuerying.IBatchedOrderedQueryable{``0},System.String)">
            <summary>
                Chain another order by using a single property in ascending order
            </summary>
            <param name="queryable"></param>
            <param name="property"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.QueryableExtensions.ThenByDescending``1(System.Linq.IOrderedQueryable{``0},System.String)">
            <summary>
                Chain another order by using a single property in descending order
            </summary>
            <param name="queryable"></param>
            <param name="property"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.QueryableExtensions.ThenByDescending``1(Marten.Services.BatchQuerying.IBatchedOrderedQueryable{``0},System.String)">
            <summary>
                Chain another order by using a single property in descending order
            </summary>
            <param name="queryable"></param>
            <param name="property"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.QueryableExtensions.OrderBySql``1(System.Linq.IQueryable{``0},System.String)">
            <summary>
            Supply literal SQL fragments to be placed in the generated SQL for this LINQ query.
            You can supply the "desc" suffix here
            </summary>
            <param name="queryable"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.QueryableExtensions.ThenBySql``1(System.Linq.IQueryable{``0},System.String)">
            <summary>
            Supply literal SQL fragments to be placed in the generated SQL for this LINQ query
            You can supply the "desc" suffix here
            </summary>
            <param name="queryable"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.QueryableExtensions.Stats``1(System.Linq.IQueryable{``0},Marten.Linq.QueryStatistics@)">
            <summary>
                Retrieve the total number of persisted rows in the database that match this
                query. Useful for server side paging.
            </summary>
            <param name="stats"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.QueryableExtensions.ExplicitSql``1(System.Object,System.String)">
            <summary>
            For usage in LINQ Select() transforms by Marten to use user-supplied SQL for
            transformations
            </summary>
            <param name="target"></param>
            <param name="sql"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.QuerySessionExtensions.Query(Marten.IQuerySession,System.Type,System.String,System.Object[])">
            <summary>
                Query by a user-supplied .Net document type and user-supplied SQL
            </summary>
            <param name="session"></param>
            <param name="type"></param>
            <param name="sql"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.QuerySessionExtensions.QueryAsync(Marten.IQuerySession,System.Type,System.String,System.Threading.CancellationToken,System.Object[])">
            <summary>
                Query by a user-supplied .Net document type and user-supplied SQL
            </summary>
            <param name="session"></param>
            <param name="type"></param>
            <param name="sql"></param>
            <param name="token"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedFetcher`1.Count">
            <summary>
                Return a count of all the documents of type "T"
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedFetcher`1.Count(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
                Return a count of all the documents of type "T" that match the query
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedFetcher`1.Any">
            <summary>
                Where for the existence of any documents of type "T" matching the query
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedFetcher`1.Any(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
                Where for the existence of any documents of type "T"
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedFetcher`1.First(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
                Find the first document of type "T" matching this query. Will throw an exception if there are no matching documents
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedFetcher`1.FirstOrDefault">
            <summary>
                Find the first document of type "T" that matches the query. Will return null if no documents match.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedFetcher`1.Single">
            <summary>
                Returns the single document of type "T" matching this query. Will
                throw an exception if the results are null or contain more than one
                document
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedFetcher`1.Single(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
                Returns the single document of type "T" matching this query. Will
                throw an exception if the results are null or contain more than one
                document
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedFetcher`1.SingleOrDefault">
            <summary>
                Returns the single document of type "T" matching this query or null. Will
                throw an exception if the results contain more than one
                document
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedFetcher`1.SingleOrDefault(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
                Returns the single document of type "T" matching this query or null. Will
                throw an exception if the results contain more than one
                document
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchEvents.Load(System.Guid)">
            <summary>
                Load a single event with all of its metadata
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchEvents.FetchStreamState(System.Guid)">
            <summary>
                Load the high level metadata about a single event stream
            </summary>
            <param name="streamId"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchEvents.FetchStreamState(System.String)">
            <summary>
                Load the high level metadata about a single event stream
            </summary>
            <param name="streamKey"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchEvents.FetchStream(System.Guid,System.Int64,System.Nullable{System.DateTime},System.Int64)">
            <summary>
                Fetch all the events for a single event stream
            </summary>
            <param name="streamId"></param>
            <param name="version">If set, queries for events up to and including this version</param>
            <param name="timestamp">If set, queries for events captured on or before this timestamp</param>
            <param name="fromVersion">If set, queries for events on or from this version</param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchEvents.FetchStream(System.String,System.Int64,System.Nullable{System.DateTime},System.Int64)">
            <summary>
                Fetch all the events for a single event stream
            </summary>
            <param name="streamKey"></param>
            <param name="version">If set, queries for events up to and including this version</param>
            <param name="timestamp">If set, queries for events captured on or before this timestamp</param>
            <param name="fromVersion">If set, queries for events on or from this version</param>
            <returns></returns>
        </member>
        <member name="P:Marten.Services.BatchQuerying.IBatchedQuery.Events">
            <summary>
                Access to event store specific query mechanisms
            </summary>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQuery.Load``1(System.String)">
            <summary>
                Load a single document of Type "T" by id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQuery.Load``1(System.Int32)">
            <summary>
                Load a single document of Type "T" by id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQuery.Load``1(System.Int64)">
            <summary>
                Load a single document of Type "T" by id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQuery.Load``1(System.Guid)">
            <summary>
                Load a single document of Type "T" by id
            </summary>
            <typeparam name="T"></typeparam>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQuery.LoadMany``1">
            <summary>
                Load a one or more documents of Type "T" by id's
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQuery.Query``1(System.String,System.Object[])">
            <summary>
                Execute a user provided query against "T"
            </summary>
            <typeparam name="T"></typeparam>
            <param name="sql"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQuery.Execute(System.Threading.CancellationToken)">
            <summary>
                Execute this batched query
            </summary>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQuery.Query``1">
            <summary>
                Where for documents of type "T" by Linq expression
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQuery.Query``2(Marten.Linq.ICompiledQuery{``0,``1})">
            <summary>
                Execute a compiled query as part of the batch query
            </summary>
            <typeparam name="TDoc"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="query"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQuery.ExecuteSynchronously">
            <summary>
                Force the batched query to execute synchronously
            </summary>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQueryable`1.Stats(Marten.Linq.QueryStatistics@)">
            <summary>
                Retrieve the total number of persisted rows in the database that match this
                query. Useful for server side paging.
            </summary>
            <param name="stats"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQueryable`1.Include``1(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Action{``0})">
            <summary>
                Also fetch related documents, and call the callback lambda for each
                related document
            </summary>
            <param name="idSource"></param>
            <param name="callback"></param>
            <typeparam name="TInclude"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQueryable`1.Include``1(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Collections.Generic.IList{``0})">
            <summary>
                Also fetch related documents, and add the related documents to
                the supplied list
            </summary>
            <param name="idSource"></param>
            <param name="list"></param>
            <typeparam name="TInclude"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQueryable`1.Include``2(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Collections.Generic.IDictionary{``1,``0})">
            <summary>
                Also fetch related documents, and add the related documents to
                the supplied dictionary organized by the identity of the related document
            </summary>
            <param name="idSource"></param>
            <param name="dictionary"></param>
            <typeparam name="TInclude"></typeparam>
            <typeparam name="TKey"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQueryable`1.Include``1(System.Action{``0})">
            <summary>
                Also fetch related documents, and call the callback lambda for each
                related document. Follow this with <c>.On(idSource)</c> to specify how to
                map to this document.
            </summary>
            <param name="callback"></param>
            <typeparam name="TInclude"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQueryable`1.Include``1(System.Collections.Generic.IList{``0})">
            <summary>
                Also fetch related documents, and add the related documents to
                the supplied list. Follow this with <c>.On(idSource)</c> to specify how to
                map to this document.
            </summary>
            <param name="idSource"></param>
            <param name="list"></param>
            <typeparam name="TInclude"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQueryable`1.Include``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
                Also fetch related documents, and add the related documents to
                the supplied dictionary organized by the property mapped to the related
                document. Follow this with <c>.On(idSource)</c> to specify how to map to
                this document.
            </summary>
            <param name="idSource"></param>
            <param name="dictionary"></param>
            <typeparam name="TInclude"></typeparam>
            <typeparam name="TKey"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQueryable`1.Include``2(System.Collections.Generic.IDictionary{``0,System.Collections.Generic.IList{``1}})">
            <summary>
                Also fetch related documents, and add the related documents to
                the supplied dictionary of lists organized by the property mapped to the
                related document. Follow this with <c>.On(idSource)</c> to specify how
                to map to this document.
            </summary>
            <param name="idSource"></param>
            <param name="dictionary"></param>
            <typeparam name="TInclude"></typeparam>
            <typeparam name="TKey"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQueryable`1.Include``2(System.Collections.Generic.IDictionary{``0,System.Collections.Generic.List{``1}})">
            <summary>
                Also fetch related documents, and add the related documents to
                the supplied dictionary of lists organized by the property mapped to the
                related document. Follow this with <c>.On(idSource)</c> to specify how
                to map to this document.
            </summary>
            <param name="idSource"></param>
            <param name="dictionary"></param>
            <typeparam name="TInclude"></typeparam>
            <typeparam name="TKey"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQueryableIncludeBuilder`2.On(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Specify which property to use to map to the identity of the related document.
            </summary>
            <param name="idSource"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQueryableIncludeBuilder`2.On(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Linq.Expressions.Expression{System.Func{`1,System.Boolean}})">
            <summary>
            Specify which property to use to map to the identity of the related document.
            </summary>
            <param name="idSource"></param>
            <param name="filter">Limit the included documents fetched from the server</param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQueryableIncludeBuilder`2.On``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Linq.Expressions.Expression{System.Func{`1,``0}})">
            <summary>
            Specify which property on the queried document to map with, and the property
            on the related document to map to.
            </summary>
            <param name="idSource"></param>
            <param name="idMapping"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQueryableIncludeBuilder`2.On``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Linq.Expressions.Expression{System.Func{`1,``0}},System.Linq.Expressions.Expression{System.Func{`1,System.Boolean}})">
            <summary>
            Specify which property on the queried document to map with, and the property
            on the related document to map to.
            </summary>
            <param name="idSource"></param>
            <param name="idMapping"></param>
            <param name="filter">Limit the included documents fetched from the server</param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQueryableIncludeBuilder`3.On(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Specify which property to use to map to the identity of the related document.
            </summary>
            <param name="idSource"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQueryableIncludeBuilder`3.On(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Linq.Expressions.Expression{System.Func{`2,System.Boolean}})">
            <summary>
            Specify which property to use to map to the identity of the related document.
            </summary>
            <param name="idSource"></param>
            <param name="filter">Limit the included documents fetched from the server</param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQueryableIncludeBuilder`3.On(System.Linq.Expressions.Expression{System.Func{`0,`1}},System.Linq.Expressions.Expression{System.Func{`2,`1}})">
            <summary>
            Specify which property on the queried document to map with, and the property
            on the related document to map to.
            </summary>
            <param name="idSource"></param>
            <param name="idMapping"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQueryableIncludeBuilder`3.On(System.Linq.Expressions.Expression{System.Func{`0,`1}},System.Linq.Expressions.Expression{System.Func{`2,`1}},System.Linq.Expressions.Expression{System.Func{`2,System.Boolean}})">
            <summary>
            Specify which property on the queried document to map with, and the property
            on the related document to map to.
            </summary>
            <param name="idSource"></param>
            <param name="idMapping"></param>
            <param name="filter">Limit the included documents fetched from the server</param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQueryableIncludeBuilder`3.On``1(System.Linq.Expressions.Expression{System.Func{`0,System.Nullable{``0}}},System.Linq.Expressions.Expression{System.Func{`2,System.Nullable{``0}}})">
            <summary>
            Specify which property on the queried document to map with, and the property
            on the related document to map to.
            </summary>
            <param name="idSource"></param>
            <param name="idMapping"></param>
            <typeparam name="TId">The key type, as a value-type</typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchedQueryableIncludeBuilder`3.On``1(System.Linq.Expressions.Expression{System.Func{`0,System.Nullable{``0}}},System.Linq.Expressions.Expression{System.Func{`2,System.Nullable{``0}}},System.Linq.Expressions.Expression{System.Func{`2,System.Boolean}})">
            <summary>
            Specify which property on the queried document to map with, and the property
            on the related document to map to.
            </summary>
            <param name="idSource"></param>
            <param name="idMapping"></param>
            <param name="filter">Limit the included documents fetched from the server</param>
            <typeparam name="TId">The key type, as a value-type</typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchLoadByKeys`1.ById``1(``0[])">
            <summary>
                Load multiple documents by an array of keys
            </summary>
            <param name="keys"></param>
            <typeparam name="TKey"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.BatchQuerying.IBatchLoadByKeys`1.ByIdList``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
                Load multiple documents by a list of keys
            </summary>
            <param name="keys"></param>
            <typeparam name="TKey"></typeparam>
            <returns></returns>
        </member>
        <member name="F:Marten.Services.CommandRunnerMode.Transactional">
            <summary>
                Marten controls the transactional boundary
            </summary>
        </member>
        <member name="F:Marten.Services.CommandRunnerMode.External">
            <summary>
                Implies that some other process is controlling the transaction boundaries
            </summary>
        </member>
        <member name="M:Marten.Services.Diagnostics.PreviewCommand``2(Marten.Linq.ICompiledQuery{``0,``1},Marten.DocumentTracking)">
            <summary>
                Preview the database command that will be executed for this compiled query
                object
            </summary>
            <typeparam name="TDoc"></typeparam>
            <typeparam name="TReturn"></typeparam>
            <param name="query"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.Diagnostics.ExplainPlan``2(Marten.Linq.ICompiledQuery{``0,``1})">
            <summary>
                Find the Postgresql EXPLAIN PLAN for this compiled query
            </summary>
            <typeparam name="TDoc"></typeparam>
            <typeparam name="TReturn"></typeparam>
            <param name="query"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.Diagnostics.GetPostgresVersion">
            <summary>
                Method to fetch Postgres server version
            </summary>
            <returns>Returns version</returns>
        </member>
        <member name="M:Marten.Services.ISessionWorkTracker.PurgeOperations``2(``1)">
            <summary>
            Remove all outstanding operations for the designated document
            </summary>
            <param name="id"></param>
            <typeparam name="T"></typeparam>
            <typeparam name="TId"></typeparam>
        </member>
        <member name="M:Marten.Services.IUnitOfWork.Deletions">
            <summary>
                All of the pending deletions that will be processed
                when this session is committed
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.IUnitOfWork.DeletionsFor``1">
            <summary>
                All the pending deletions of documents of type T that will be processed
                when this session is committed
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.IUnitOfWork.DeletionsFor(System.Type)">
            <summary>
                All the pending deletions of documents of type documentType that will be processed
                when this session is committed
            </summary>
            <param name="documentType"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.IUnitOfWork.Updates">
            <summary>
                All the documents that will be updated when this session is committed
                This is inclusive of both Upsert and Updates
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.IUnitOfWork.Inserts">
            <summary>
                All of the documents that will be inserted when this session is committed
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.IUnitOfWork.UpdatesFor``1">
            <summary>
                All the documents of type T that will be updated when this session is committed.
                This is inclusive of both Upsert and Updates
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.IUnitOfWork.InsertsFor``1">
            <summary>
                All the documents of type T that will be inserted when this session is committed
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.IUnitOfWork.AllChangedFor``1">
            <summary>
                All of the documents of type T that will be inserted or updated when this session
                is committed
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.IUnitOfWork.Streams">
            <summary>
                All of the pending events for the event store in this unit of work
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.IUnitOfWork.Operations">
            <summary>
                All the storage operations that will be executed when this session is committed
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.IUnitOfWork.OperationsFor``1">
            <summary>
                All the storage operations that will be executed for documents of type T when this
                session is committed
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.IUnitOfWork.OperationsFor(System.Type)">
            <summary>
                All the storage operations that will be executed for documents of type T when this
                session is committed
            </summary>
            <param name="documentType"></param>
            <returns></returns>
        </member>
        <member name="T:Marten.Services.Json.JsonNetCollectionToArrayJsonConverter">
            <summary>
                Serialize collection type property to JSON array using a custom Newtonsoft.Json JsonConverter
                Note that without using custom `JsonConverter`, `Newtonsoft.Json` stores it as $type and $value.
                Or you may need to resort to `Newtonsoft.Json.TypeNameHandling.None` which has its own side-effects
            </summary>
        </member>
        <member name="T:Marten.Services.Json.SystemObjectNewtonsoftCompatibleConverter">
            <summary>
                Taken from:
                https://github.com/dotnet/runtime/blob/3e4a06c0e90e65c0ad514d8e2a9f93cb584d775a/src/libraries/System.Text.Json/tests/Serialization/CustomConverterTests.Object.cs#L267
                A converter that converts System.Object similar to Newtonsoft's JSON.Net.
                Only primitives are the same; arrays and objects do not result in the same types.
            </summary>
        </member>
        <member name="T:Marten.Services.Json.JsonSerializerExtensions">
            <summary>
                This class is intended as a sample for supporting the <see langword="dynamic" /> feature.
            </summary>
            <remarks>
                It requires a reference to the "System.Linq.Expressions" assembly.
            </remarks>
        </member>
        <member name="M:Marten.Services.Json.JsonSerializerExtensions.EnableDynamicTypes(System.Text.Json.JsonSerializerOptions)">
            <summary>
                Enable support for the <see langword="dynamic" /> feature.
                Changes the default handling for types specified as <see cref="T:System.Object" /> from deserializing as
                <see cref="T:System.Text.Json.JsonElement" /> to instead deserializing as the one of the
                <see cref="T:Marten.Services.Json.JsonSerializerExtensions.JsonDynamicType" />-derived types including:
                <see cref="T:Marten.Services.Json.JsonSerializerExtensions.JsonDynamicObject" />,
                <see cref="T:Marten.Services.Json.JsonSerializerExtensions.JsonDynamicArray" />,
                <see cref="T:Marten.Services.Json.JsonSerializerExtensions.JsonDynamicString" />,
                <see cref="T:Marten.Services.Json.JsonSerializerExtensions.JsonDynamicNumber" /> and
                <see cref="T:Marten.Services.Json.JsonSerializerExtensions.JsonDynamicBoolean" />.
            </summary>
            <remarks>
                When deserializing <see cref="F:System.Text.Json.JsonTokenType.StartObject" />, <see cref="T:Marten.Services.Json.JsonSerializerExtensions.JsonDynamicObject" />
                is returned which implements <see cref="!:System.Collections.IDictionary&lt;string, object&gt;" />.
                When deserializing <see cref="F:System.Text.Json.JsonTokenType.StartArray" />,
                <see cref="!:System.Collections.IList&lt;object&gt;" />
                is returned which implements <see cref="!:System.Collections.IList&lt;object&gt;" />.
                When deserializing <see cref="F:System.Text.Json.JsonTokenType.String" />, <see cref="T:Marten.Services.Json.JsonSerializerExtensions.JsonDynamicString" />
                is returned and supports an implicit cast to <see cref="T:System.String" />.
                An explicit cast or assignment to other types, such as <see cref="!:System.Text.Json.JsonTokenType.DateTime" />,
                is supported provided there is a custom converter for that Type.
                When deserializing <see cref="F:System.Text.Json.JsonTokenType.Number" />, <see cref="T:Marten.Services.Json.JsonSerializerExtensions.JsonDynamicNumber" /> is
                returned.
                An explicit cast or assignment is required to the appropriate number type, such as <see cref="T:System.Decimal" /> or
                <see cref="T:System.Int64" />.
                When deserializing <see cref="F:System.Text.Json.JsonTokenType.True" /> and
                <see cref="F:System.Text.Json.JsonTokenType.False" />,
                <see cref="!:JsonDynamicBool" /> is returned and supports an implicit cast to <see cref="T:System.Boolean" />.
                An explicit cast or assignment to other types is supported provided there is a custom converter for that type.
                When deserializing <see cref="F:System.Text.Json.JsonTokenType.Null" />, <see langword="null" /> is returned.
            </remarks>
        </member>
        <member name="T:Marten.Services.Json.JsonSerializerExtensions.JsonDynamicType">
            <summary>
                The base class for all dynamic types supported by the serializer.
            </summary>
        </member>
        <member name="T:Marten.Services.Json.JsonSerializerExtensions.JsonDynamicString">
            <summary>
                Supports dynamic strings.
            </summary>
        </member>
        <member name="T:Marten.Services.Json.JsonSerializerExtensions.JsonDynamicNumber">
            <summary>
                Supports dynamic numbers.
            </summary>
        </member>
        <member name="T:Marten.Services.Json.JsonSerializerExtensions.JsonDynamicBoolean">
            <summary>
                Supports dynamic booleans.
            </summary>
        </member>
        <member name="T:Marten.Services.Json.JsonSerializerExtensions.JsonDynamicObject">
            <summary>
                Supports dynamic objects.
            </summary>
        </member>
        <member name="T:Marten.Services.Json.JsonSerializerExtensions.JsonDynamicArray">
            <summary>
                Supports dynamic arrays.
            </summary>
        </member>
        <member name="T:Marten.Services.Json.JsonSerializerExtensions.DynamicObjectConverter">
            <summary>
                Supports deserialization of all <see cref="T:System.Object" />-declared types, supporting <see langword="dynamic" />.
                supports serialization of all <see cref="T:Marten.Services.Json.JsonSerializerExtensions.JsonDynamicType" />-derived types.
            </summary>
        </member>
        <member name="T:Marten.Services.Json.Transformations.IEventUpcaster">
            <summary>
                <para>
                    Interface <c>IEventUpcaster</c> defines the general event payload transformation API.
                    Upcasting is a process of transforming the old JSON schema into the new one.
                    You can use it to handle the event schema versioning/migration.
                    By implementing it, you tell that for specific event type name, you'd like to get the new CLR event type.
                </para>
                <para>
                    As Marten supports sync and async API, you must also provide the transformation methods.
                    They provide the default serializer that you can use for JSON transformations as a parameter.
                    It also provides <see cref="T:System.Data.Common.DbDataReader">DbDataReader</see> together with index in which JSON payload should
                    be read.
                </para>
                <para>
                    Use
                    <c>
                        <see cref="M:Marten.Events.IEventStoreOptions.Upcast(System.Type,System.String,Marten.Services.Json.Transformations.JsonTransformation)">store.options.Upcast</see>
                    </c>
                    method to register upcaster implementation
                    and tell Marten that you'd like to use it.
                </para>
                <para>
                    We recommend to depend on the built-in <c>IEventUpcaster</c> implementations.
                    Custom implementations should only happen if you need to do something highly specific to your use case.
                    See more in
                    <a href="https://martendb.io/events/versioning.html##upcasting-advanced-payload-transformations">documentation</a>
                </para>
            </summary>
        </member>
        <member name="P:Marten.Services.Json.Transformations.IEventUpcaster.EventTypeName">
            <summary>
                Event type name that you would like to transform
            </summary>
        </member>
        <member name="P:Marten.Services.Json.Transformations.IEventUpcaster.EventType">
            <summary>
                The new CLR event type you are mapping to
            </summary>
        </member>
        <member name="M:Marten.Services.Json.Transformations.IEventUpcaster.FromDbDataReader(Marten.ISerializer,System.Data.Common.DbDataReader,System.Int32)">
            <summary>
                <para>
                    Method defines the event JSON payload transformation. It "upcasts" one event schema into another.
                    You can use it to handle the event schema versioning/migration.
                </para>
                <para>
                    <b>WARNING:</b> this method will only be called in <b>sync</b> API.
                    Define <see cref="M:Marten.Services.Json.Transformations.IEventUpcaster.FromDbDataReaderAsync(Marten.ISerializer,System.Data.Common.DbDataReader,System.Int32,System.Threading.CancellationToken)" /> for the async one
                </para>
            </summary>
            <param name="serializer">Default serializer that you can use for JSON transformations as a parameter</param>
            <param name="dbDataReader"><see cref="T:System.Data.Common.DbDataReader">DbDataReader</see> to get the JSON payload from</param>
            <param name="index">Column index in which JSON payload should be read</param>
            <returns>Deserialized and transformed object of the CLR type defined in <see cref="P:Marten.Services.Json.Transformations.IEventUpcaster.EventType"></see></returns>
        </member>
        <member name="M:Marten.Services.Json.Transformations.IEventUpcaster.FromDbDataReaderAsync(Marten.ISerializer,System.Data.Common.DbDataReader,System.Int32,System.Threading.CancellationToken)">
            <summary>
                <para>
                    Method defines the event JSON payload transformation. It "upcasts" one event schema into another.
                    You can use it to handle the event schema versioning/migration.
                </para>
                <para>
                    <b>WARNING:</b> this method will only be called in <b>async</b> API.
                    Define <see cref="M:Marten.Services.Json.Transformations.IEventUpcaster.FromDbDataReader(Marten.ISerializer,System.Data.Common.DbDataReader,System.Int32)" /> for the sync one
                </para>
            </summary>
            <param name="serializer">Default serializer that you can use for JSON transformations as a parameter</param>
            <param name="dbDataReader"><see cref="T:System.Data.Common.DbDataReader">DbDataReader</see> to get the JSON payload from</param>
            <param name="index">Column index in which JSON payload should be read</param>
            <param name="ct">Cancellation token</param>
            <returns>Deserialized and transformed object of the CLR type defined in <see cref="P:Marten.Services.Json.Transformations.IEventUpcaster.EventType"></see></returns>
        </member>
        <member name="T:Marten.Services.Json.Transformations.EventUpcaster">
            <summary>
                <para>
                    Base implementation of <see cref="T:Marten.Services.Json.Transformations.IEventUpcaster">IEventUpcaster</see> transforming JSON payload.
                    Upcasting is a process of transforming the old JSON schema into the new one.
                    You can use it to handle the event schema versioning/migration.
                    By deriving from it, you tell that for specific event type name, you'd like to get the new CLR event type.
                    The default event type name mapping will be used, unless you override <see cref="P:Marten.Services.Json.Transformations.EventUpcaster.EventTypeName" /> property
                </para>
                <para>
                    As Marten supports sync and async API, you must also provide the transformation methods.
                    They provide the default serializer that you can use for JSON transformations as a parameter.
                    It also provides <see cref="T:System.Data.Common.DbDataReader">DbDataReader</see> together with index in which JSON payload should
                    be read.
                </para>
                <para>
                    You should at least implement sync <see cref="M:Marten.Services.Json.Transformations.EventUpcaster.FromDbDataReader(Marten.ISerializer,System.Data.Common.DbDataReader,System.Int32)" />.
                    By default <see cref="M:Marten.Services.Json.Transformations.EventUpcaster.FromDbDataReaderAsync(Marten.ISerializer,System.Data.Common.DbDataReader,System.Int32,System.Threading.CancellationToken)" /> calls sync method internally. You can override the default
                    behavior.
                </para>
                <para>
                    Use
                    <c>
                        <see cref="M:Marten.Events.IEventStoreOptions.Upcast(System.Type,System.String,Marten.Services.Json.Transformations.JsonTransformation)">store.options.Upcast</see>
                    </c>
                    method to register upcaster implementation
                    and tell Marten that you'd like to use it.
                </para>
                <para>
                    We recommend to depend on the built-in <c>EventUpcaster</c> implementations.
                    Custom implementations should only happen if you need to do something highly specific to your use case.
                    See more in
                    <a href="https://martendb.io/events/versioning.html#upcasting-advanced-payload-transformations">documentation</a>
                </para>
            </summary>
        </member>
        <member name="P:Marten.Services.Json.Transformations.EventUpcaster.EventTypeName">
            <summary>
                Event type name that you would like to transform. By default it uses the default convention
            </summary>
        </member>
        <member name="T:Marten.Services.Json.Transformations.EventUpcaster`1">
            <summary>
                <para>
                    Base implementation of <see cref="T:Marten.Services.Json.Transformations.EventUpcaster">EventUpcaster</see> transforming JSON payload into generic
                    event type.
                    Upcasting is a process of transforming the old JSON schema into the new one.
                    You can use it to handle the event schema versioning/migration.
                    By deriving from it, you tell that for specific event type name, you'd like to get the new CLR event type.
                    The default event type name mapping will be used based on <c>TEvent</c> type, unless you override
                    <see cref="!:EventTypeName" /> property
                </para>
                <para>
                    As Marten supports sync and async API, you must also provide the transformation methods.
                    They provide the default serializer that you can use for JSON transformations as a parameter.
                    It also provides <see cref="T:System.Data.Common.DbDataReader">DbDataReader</see> together with index in which JSON payload should
                    be read.
                </para>
                <para>
                    You should at least implement sync <see cref="!:FromDbDataReader" />.
                    By default <see cref="!:FromDbDataReaderAsync" /> calls sync method internally. You can override the default
                    behavior.
                </para>
                <para>
                    Use
                    <c>
                        <see cref="M:Marten.Events.IEventStoreOptions.Upcast(System.Type,System.String,Marten.Services.Json.Transformations.JsonTransformation)">store.options.Upcast</see>
                    </c>
                    method to register upcaster implementation
                    and tell Marten that you'd like to use it.
                </para>
                <para>
                    We recommend to depend on the built-in <c>EventUpcaster</c> implementations.
                    Custom implementations should only happen if you need to do something highly specific to your use case.
                    See more in
                    <a href="https://martendb.io/events/versioning.html#upcasting-advanced-payload-transformations">documentation</a>
                </para>
            </summary>
            <typeparam name="TEvent">Mapped CLR event type</typeparam>
        </member>
        <member name="T:Marten.Services.Json.Transformations.EventUpcaster`2">
            <summary>
                <para>
                    Base implementation of <see cref="T:Marten.Services.Json.Transformations.IEventUpcaster" /> transforming JSON payload from one CLR type to the other.
                    Upcasting is a process of transforming the old JSON schema into the new one.
                    You can use it to handle the event schema versioning/migration.
                    By deriving from it, you tell that for specific event type name, you'd like to get the new CLR event type.
                    The default event type name mapping will be used based on <c>TOldEvent</c> type, unless you override
                    <see cref="P:Marten.Services.Json.Transformations.EventUpcaster`2.EventTypeName" /> property
                </para>
                <para>
                    You need to provide the implementation of <see cref="M:Marten.Services.Json.Transformations.EventUpcaster`2.Upcast(`0)" /> method.
                    It should contain the logic transforming event payload from <c>TOldEvent</c> to <c>TEvent</c>.
                    This logic will be both run in sync and async API.
                </para>
                <para>
                    If you need to use async code in your transformation, derive from
                    <see cref="T:Marten.Services.Json.Transformations.AsyncOnlyEventUpcaster`2" /> instead
                </para>
                <para>
                    Use
                    <c>
                        <see cref="M:Marten.Events.IEventStoreOptions.Upcast(System.Type,System.String,Marten.Services.Json.Transformations.JsonTransformation)">store.options.Upcast</see>
                    </c>
                    method to register upcaster implementation
                    and tell Marten that you'd like to use it.
                </para>
            </summary>
            <example>
                Example implementation:
                <code lang="csharp">
            public class ShoppingCartOpenedUpcaster:
                 EventUpcaster&#60;ShoppingCartOpened, ShoppingCartInitializedWithStatus&#62;
            {
                 protected override ShoppingCartInitializedWithStatus Upcast(
                     ShoppingCartOpened oldEvent) =>
                     new ShoppingCartInitializedWithStatus(
                         oldEvent.ShoppingCartId,
                         new Client(oldEvent.ClientId),
                         ShoppingCartStatus.Opened
                     );
            }
            </code>
                Example registration:
                <code lang="csharp">
            storeOptions.Events.Upcast&#60;ShoppingCartOpenedUpcaster&#62;();
            </code>
            </example>
            <typeparam name="TEvent">Mapped CLR event type</typeparam>
            <typeparam name="TOldEvent">Old CLR event type</typeparam>
        </member>
        <member name="M:Marten.Services.Json.Transformations.EventUpcaster`2.Upcast(`0)">
            <summary>
                <para>
                    Method defines the event JSON payload transformation. It "upcasts" one event schema into another.
                    You can use it to handle the event schema versioning/migration.
                </para>
                <para>
                    By defining it, you tell that instead of the old CLR type, for the specific event type name,
                    you'd like to get the new CLR event type.
                    Function takes the deserialized object of the old event type and returns the new, mapped one.
                </para>
                <para>
                    Internally it uses default deserialization and event type mapping for old CLR type
                    and calls the mapping function.
                    In your application code, you should use only the new event type in the aggregation and projection logic.
                    See more in
                    <a href="https://martendb.io/events/versioning.html#transformation-with-clr-types-will-look-like-this-1">documentation</a>
                </para>
            </summary>
            <example>
                Example implementation:
                <code lang="csharp">
            protected override ShoppingCartInitializedWithStatus Upcast(
                ShoppingCartOpened oldEvent) =>
                new ShoppingCartInitializedWithStatus(
                    oldEvent.ShoppingCartId,
                    new Client(oldEvent.ClientId),
                    ShoppingCartStatus.Opened
                );
            </code>
            </example>
            <param name="oldEvent">Deserialized object of the <c>TOldEvent</c> type, to be transformed into <c>TEvent</c></param>
            <returns>Instance of the <c>TEvent</c> transformed from <c>oldEvent</c>.</returns>
        </member>
        <member name="T:Marten.Services.Json.Transformations.AsyncOnlyEventUpcaster`2">
            <summary>
                <para>
                    Base implementation of <see cref="T:Marten.Services.Json.Transformations.IEventUpcaster" /> transforming asynchronously JSON payload from one CLR type
                    to the other.
                    Upcasting is a process of transforming the old JSON schema into the new one.
                    You can use it to handle the event schema versioning/migration.
                    By deriving from it, you tell that for specific event type name, you'd like to get the new CLR event type.
                    The default event type name mapping will be used based on <c>TOldEvent</c> type, unless you override
                    <see cref="P:Marten.Services.Json.Transformations.AsyncOnlyEventUpcaster`2.EventTypeName" /> property
                </para>
                <para>
                    You need to provide the implementation of <see cref="M:Marten.Services.Json.Transformations.AsyncOnlyEventUpcaster`2.UpcastAsync(`0,System.Threading.CancellationToken)" /> method.
                    It should contain the logic transforming event payload from <c>TOldEvent</c> to <c>TEvent</c>.
                </para>
                <para>
                    <b>WARNING:</b> <c>UpcastAsync</c> method is called each type old event is read from database and deserialized.
                    <c>AsyncOnlyEventUpcaster</c> will only be run in the async API and throw exception when run in sync method
                    calls.
                    We discourage to run resource consuming methods here. It might end up with N+1 performance issue.
                    Best is to use sync transformation instead and deriving from <see cref="T:Marten.Services.Json.Transformations.EventUpcaster`2" />
                </para>
                <para>
                    Use
                    <c>
                        <see cref="M:Marten.Events.IEventStoreOptions.Upcast(System.Type,System.String,Marten.Services.Json.Transformations.JsonTransformation)">store.options.Upcast</see>
                    </c>
                    method to register upcaster implementation
                    and tell Marten that you'd like to use it.
                </para>
            </summary>
            <example>
                Example implementation:
                <code lang="csharp">
            public class ShoppingCartOpenedAsyncOnlyUpcaster:
                    AsyncOnlyEventUpcaster&#60;ShoppingCartOpened, ShoppingCartInitializedWithStatus&#62;
            {
                private readonly IClientRepository _clientRepository;
            
                public ShoppingCartOpenedAsyncOnlyUpcaster(IClientRepository clientRepository) =>
                    _clientRepository = clientRepository;
            
                protected override async Task&#60;ShoppingCartInitializedWithStatus&#62; UpcastAsync(
                    ShoppingCartOpened oldEvent,
                    CancellationToken ct
                )
                {
                    var clientName = await _clientRepository.GetClientName(oldEvent.ClientId, ct);
            
                    return new ShoppingCartInitializedWithStatus(
                        oldEvent.ShoppingCartId,
                        new Client(oldEvent.ClientId, clientName),
                        ShoppingCartStatus.Opened
                    );
                }
            }
            </code>
                Example registration:
                <code lang="csharp">
            storeOptions.Events.Upcast&#60;ShoppingCartOpenedAsyncOnlyUpcaster&#62;();
            </code>
            </example>
            <typeparam name="TEvent">Mapped CLR event type</typeparam>
            <typeparam name="TOldEvent">Old CLR event type</typeparam>
            <exception cref="T:Marten.Exceptions.MartenException">when upcaster is called in sync API</exception>
        </member>
        <member name="M:Marten.Services.Json.Transformations.AsyncOnlyEventUpcaster`2.UpcastAsync(`0,System.Threading.CancellationToken)">
            <summary>
                <para>
                    Method defines the asynchronous event JSON payload transformation. It "upcasts" one event schema into another.
                    You can use it to handle the event schema versioning/migration.
                </para>
                <para>
                    By defining it, you tell that instead of the old CLR type, for the specific event type name,
                    you'd like to get the new CLR event type.
                    Function takes the deserialized object of the old event type and returns the new, mapped one.
                </para>
                <para>
                    Internally it uses default deserialization and event type mapping for old CLR type
                    and calls the mapping function.
                    In your application code, you should use only the new event type in the aggregation and projection logic.
                    See more in
                    <a href="https://martendb.io/events/versioning.html#upcasting-advanced-payload-transformations">documentation</a>
                </para>
                <para>
                    <b>WARNING!</b> <c>UpcastAsync</c> method is called each type old event is read from database and deserialized.
                    <c>AsyncOnlyEventUpcaster</c> will only be run in the async API and throw exception when run in sync method
                    calls.
                    We discourage to run resource consuming methods here. It might end up with N+1 performance issue.
                    Best is to use sync transformation instead and deriving from <see cref="T:Marten.Services.Json.Transformations.EventUpcaster`2" />
                </para>
            </summary>
            <example>
                Example implementation:
                <code lang="csharp">
            protected override async Task&#60;ShoppingCartInitializedWithStatus&#62; UpcastAsync(
                ShoppingCartOpened oldEvent,
                CancellationToken ct
            )
            {
                var clientName = await _clientRepository.GetClientName(oldEvent.ClientId, ct);
            
                return new ShoppingCartInitializedWithStatus(
                    oldEvent.ShoppingCartId,
                    new Client(oldEvent.ClientId, clientName),
                    ShoppingCartStatus.Opened
                );
            }
            </code>
            </example>
            <param name="oldEvent">Deserialized object of the <c>TOldEvent</c> type, to be transformed into <c>TEvent</c></param>
            <param name="ct">Cancellation token</param>
            <returns>Instance of the <c>TEvent</c> transformed from <c>oldEvent</c>.</returns>
            <exception cref="T:Marten.Exceptions.MartenException">when provided transformation is called in sync API</exception>
        </member>
        <member name="T:Marten.Services.Json.Transformations.JsonNet.EventUpcaster`1">
            <summary>
                <para>
                    Base implementation of <a href="https://www.newtonsoft.com/json">Json.Net</a>
                    <see cref="T:Marten.Services.Json.Transformations.IEventUpcaster" /> transforming JSON payload from one CLR type to the other.
                    Upcasting is a process of transforming the old JSON schema into the new one.
                    You can use it to handle the event schema versioning/migration.
                    By deriving from it, you tell that for specific event type name, you'd like to get the new CLR event type.
                    The default event type name mapping will be used based on <c>TEvent</c> type, unless you override
                    <see cref="!:EventTypeName" /> property
                </para>
                <para>
                    You need to provide the implementation of <see cref="M:Marten.Services.Json.Transformations.JsonNet.EventUpcaster`1.Upcast(Newtonsoft.Json.Linq.JObject)" /> method.
                    It should contain the logic transforming event payload from
                    <a href="https://www.newtonsoft.com/json/help/html/queryinglinqtojson.htm">Json.Net JObject</a> to
                    <c>TEvent</c>.
                    This logic will be both run in sync and async API.
                </para>
                <para>
                    Compared to the <see cref="T:Marten.Services.Json.Transformations.EventUpcaster`2" /> it allows to do more
                    performant processing.
                    <c>JObject</c>can help you to reduce the number of allocation and memory pressure.
                    By using this implementation, you also don't need to keep the old CLR type in the codebase. Yet, implementation
                    is a bit more tedious.
                </para>
                <para>
                    If you need to use async code in your transformation, derive from
                    <see cref="T:Marten.Services.Json.Transformations.JsonNet.AsyncOnlyEventUpcaster`1" /> instead
                </para>
                <para>
                    Use
                    <c>
                        <see cref="M:Marten.Events.IEventStoreOptions.Upcast(System.Type,System.String,Marten.Services.Json.Transformations.JsonTransformation)">store.options.Upcast</see>
                    </c>
                    method to register upcaster implementation
                    and tell Marten that you'd like to use it.
                </para>
            </summary>
            <example>
                Example implementation:
                <code lang="csharp">
            public class ShoppingCartOpenedUpcaster:
                EventUpcaster&#60;ShoppingCartInitializedWithStatus&#62;
            {
                protected override ShoppingCartInitializedWithStatus Upcast(JObject oldEvent) =>
                    new ShoppingCartInitializedWithStatus(
                        (Guid)oldEvent["ShoppingCartId"]!,
                        new Client(
                            (Guid)oldEvent["ClientId"]!
                        ),
                        ShoppingCartStatus.Opened
                    );
            }
            </code>
                Example registration:
                <code lang="csharp">
            storeOptions.Events.Upcast&#60;ShoppingCartOpenedUpcaster&#62;();
            </code>
            </example>
            <typeparam name="TEvent">Mapped CLR event type</typeparam>
        </member>
        <member name="M:Marten.Services.Json.Transformations.JsonNet.EventUpcaster`1.Upcast(Newtonsoft.Json.Linq.JObject)">
            <summary>
                <para>
                    Method defines the event JSON payload transformation using
                    <a href="https://www.newtonsoft.com/json">Json.Net</a>.
                    It "upcasts" one event schema into another.
                    You can use it to handle the event schema versioning/migration.
                </para>
                <para>
                    By defining it, you tell that instead of the old CLR type, for the specific event type name,
                    you'd like to get the new CLR event type.
                    Function takes the
                    <a href="https://www.newtonsoft.com/json/help/html/queryinglinqtojson.htm">Json.Net JObject</a>
                    and returns the new, mapped one of type <c>TEvent</c>.
                </para>
                <para>
                    In your application code, you should use only the new event type in the aggregation and projection logic.
                    See more in
                    <a href="https://martendb.io/events/versioning.htmll#raw-json-transformation-with-json-net-1">documentation</a>
                </para>
            </summary>
            <example>
                Example implementation:
                <code lang="csharp">
            protected override ShoppingCartInitializedWithStatus Upcast(JObject oldEvent) =>
                new ShoppingCartInitializedWithStatus(
                    (Guid)oldEvent["ShoppingCartId"]!,
                    new Client(
                        (Guid)oldEvent["ClientId"]!
                    ),
                    ShoppingCartStatus.Opened
                );
            </code>
            </example>
            <param name="oldEvent">
                JSON payload represented by
                <a href="https://www.newtonsoft.com/json/help/html/queryinglinqtojson.htm">Json.Net JObject</a>,
                to be transformed into <c>TEvent</c>
            </param>
            <returns>Instance of the <c>TEvent</c> transformed from <c>oldEvent</c>.</returns>
        </member>
        <member name="T:Marten.Services.Json.Transformations.JsonNet.AsyncOnlyEventUpcaster`1">
            <summary>
                <para>
                    Base implementation of <a href="https://www.newtonsoft.com/json">Json.Net</a>
                    <see cref="T:Marten.Services.Json.Transformations.IEventUpcaster" /> transforming asynchronously JSON payload from one CLR type to the other.
                    Upcasting is a process of transforming the old JSON schema into the new one.
                    You can use it to handle the event schema versioning/migration.
                    By deriving from it, you tell that for specific event type name, you'd like to get the new CLR event type.
                    The default event type name mapping will be used based on <c>TEvent</c> type, unless you override
                    <see cref="!:EventTypeName" /> property
                </para>
                <para>
                    You need to provide the implementation of <see cref="M:Marten.Services.Json.Transformations.JsonNet.AsyncOnlyEventUpcaster`1.UpcastAsync(Newtonsoft.Json.Linq.JObject,System.Threading.CancellationToken)" /> method.
                    It should contain the logic transforming event payload
                    <a href="https://www.newtonsoft.com/json/help/html/queryinglinqtojson.htm">Json.Net JObject</a> to
                    <c>TEvent</c>.
                </para>
                <para>
                    Compared to the <see cref="T:Marten.Services.Json.Transformations.EventUpcaster`2" /> it allows to do more
                    performant processing.
                    <c>JObject</c>can help you to reduce the number of allocation and memory pressure.
                    By using this implementation, you also don't need to keep the old CLR type in the codebase. Yet, implementation
                    is a bit more tedious.
                </para>
                <para>
                    <b>WARNING:</b> <c>UpcastAsync</c> method is called each type old event is read from database and deserialized.
                    <c>AsyncOnlyEventUpcaster</c> will only be run in the async API and throw exception when run in sync method
                    calls.
                    We discourage to run resource consuming methods here. It might end up with N+1 performance issue.
                    Best is to use sync transformation instead and deriving from <see cref="T:Marten.Services.Json.Transformations.JsonNet.EventUpcaster`1" />
                </para>
                <para>
                    Use
                    <c>
                        <see cref="M:Marten.Events.IEventStoreOptions.Upcast(System.Type,System.String,Marten.Services.Json.Transformations.JsonTransformation)">store.options.Upcast</see>
                    </c>
                    method to register upcaster implementation
                    and tell Marten that you'd like to use it.
                </para>
            </summary>
            <example>
                Example implementation:
                <code lang="csharp">
            public class ShoppingCartOpenedAsyncOnlyUpcaster:
                AsyncOnlyEventUpcaster&#60;ShoppingCartInitializedWithStatus&#62;
            {
                private readonly IClientRepository _clientRepository;
            
                public ShoppingCartOpenedAsyncOnlyUpcaster(IClientRepository clientRepository) =>
                    _clientRepository = clientRepository;
            
                protected override async Task&#60;ShoppingCartInitializedWithStatus&#62; UpcastAsync(
                    JObject oldEvent,
                    CancellationToken ct
                )
                {
                    var clientId = (Guid)oldEvent["ClientId"]!;
                    var clientName = await _clientRepository.GetClientName(clientId, ct);
            
                    return new ShoppingCartInitializedWithStatus(
                        (Guid)oldEvent["ShoppingCartId"]!,
                        new Client(clientId, clientName),
                        ShoppingCartStatus.Opened
                    );
                }
            }
            </code>
                Example registration:
                <code lang="csharp">
            storeOptions.Events.Upcast&#60;ShoppingCartOpenedUpcaster&#62;();
            </code>
            </example>
            <typeparam name="TEvent">Mapped CLR event type</typeparam>
            <exception cref="T:Marten.Exceptions.MartenException">when upcaster is called in sync API</exception>
        </member>
        <member name="M:Marten.Services.Json.Transformations.JsonNet.AsyncOnlyEventUpcaster`1.UpcastAsync(Newtonsoft.Json.Linq.JObject,System.Threading.CancellationToken)">
            <summary>
                <para>
                    Method defines the async event JSON payload transformation using
                    <a href="https://www.newtonsoft.com/json">Json.Net</a>.
                    It "upcasts" one event schema into another. It "upcasts" one event schema into another.
                    You can use it to handle the event schema versioning/migration.
                </para>
                <para>
                    By defining it, you tell that instead of the old CLR type, for the specific event type name,
                    you'd like to get the new CLR event type.
                    Provided function takes the deserialized object of the old event type and returns the new, mapped one.
                </para>
                <para>
                    In your application code, you should use only the new event type in the aggregation and projection logic.
                    See more in
                    <a href="https://martendb.io/events/versioning.htmll#class-with-raw-json-transformation-with-json-net">documentation</a>
                </para>
                <para>
                    <b>WARNING!</b> <c>UpcastAsync</c> method is called each type old event is read from database and deserialized.
                    <c>AsyncOnlyEventUpcaster</c> will only be run in the async API and throw exception when run in sync method
                    calls.
                    We discourage to run resource consuming methods here. It might end up with N+1 performance issue.
                    Best is to use sync transformation instead and deriving from <see cref="T:Marten.Services.Json.Transformations.JsonNet.EventUpcaster`1" />
                </para>
            </summary>
            <example>
                Example implementation:
                <code lang="csharp">
            protected override async Task&#60;ShoppingCartInitializedWithStatus&#62; UpcastAsync(
                JObject oldEvent,
                CancellationToken ct
            )
            {
                var clientId = (Guid)oldEvent["ClientId"]!;
                var clientName = await _clientRepository.GetClientName(clientId, ct);
            
                return new ShoppingCartInitializedWithStatus(
                    (Guid)oldEvent["ShoppingCartId"]!,
                    new Client(clientId, clientName),
                    ShoppingCartStatus.Opened
                );
            }
            </code>
            </example>
            <param name="oldEvent">
                JSON payload represented by
                <a href="https://www.newtonsoft.com/json/help/html/queryinglinqtojson.htm">Json.Net JObject</a>,
                to be transformed into <c>TEvent</c>
            </param>
            <param name="ct">Cancellation token</param>
            <returns>Instance of the <c>TEvent</c> transformed from <c>oldEvent</c>.</returns>
            <exception cref="T:Marten.Exceptions.MartenException">when provided transformation is called in sync API</exception>
        </member>
        <member name="M:Marten.Services.Json.Transformations.JsonNet.JsonTransformations.Upcast``1(System.Func{Newtonsoft.Json.Linq.JObject,``0})">
            <summary>
                Wrapper for Json.NET raw JSON payload upcast function registration
            </summary>
            <param name="transform">JSON payload transformation</param>
            <typeparam name="TEvent">Mapped CLR event type</typeparam>
            <returns><see cref="T:Marten.Services.Json.Transformations.JsonTransformation" /> with upcasting definition</returns>
        </member>
        <member name="M:Marten.Services.Json.Transformations.JsonNet.JsonTransformations.AsyncOnlyUpcast``1(System.Func{Newtonsoft.Json.Linq.JObject,System.Threading.CancellationToken,System.Threading.Tasks.Task{``0}})">
            <summary>
                Wrapper for Json.NET async only raw JSON payload upcast function registration
            </summary>
            <param name="transform">JSON payload transformation</param>
            <typeparam name="TEvent">Mapped CLR event type</typeparam>
            <returns><see cref="T:Marten.Services.Json.Transformations.JsonTransformation" /> with upcasting definition</returns>
            <exception cref="T:Marten.Exceptions.MartenException">when upcaster is called in sync API</exception>
        </member>
        <member name="T:Marten.Services.Json.Transformations.JsonTransformation">
            <summary>
                Defines JSON payload transformation API. This is currently used for internal, low level processing.
                If you want to use it explicitly, check first
                <a href="https://martendb.io/events/versioning.html#namespace-migration">Event Versioning documentation</a>.
            </summary>
        </member>
        <member name="T:Marten.Services.Json.Transformations.SystemTextJson.EventUpcaster`1">
            <summary>
                <para>
                    Base implementation of
                    <a href="https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-overview">System.Text.Json</a>
                    <see cref="T:Marten.Services.Json.Transformations.IEventUpcaster" /> transforming JSON payload from one CLR type to the other.
                    Upcasting is a process of transforming the old JSON schema into the new one.
                    You can use it to handle the event schema versioning/migration.
                    By deriving from it, you tell that for specific event type name, you'd like to get the new CLR event type.
                    The default event type name mapping will be used based on <c>TEvent</c> type, unless you override
                    <see cref="!:EventTypeName" /> property
                </para>
                <para>
                    You need to provide the implementation of <see cref="M:Marten.Services.Json.Transformations.SystemTextJson.EventUpcaster`1.Upcast(System.Text.Json.JsonDocument)" /> method.
                    It should contain the logic transforming event payload from
                    <a href="https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-overview">
                        System.Text.Json
                        JsonDocument
                    </a>
                    to <c>TEvent</c>.
                    This logic will be both run in sync and async API.
                </para>
                <para>
                    Compared to the <see cref="T:Marten.Services.Json.Transformations.EventUpcaster`2" /> it allows to do more
                    performant processing.
                    <c>JObject</c>can help you to reduce the number of allocation and memory pressure.
                    By using this implementation, you also don't need to keep the old CLR type in the codebase. Yet, implementation
                    is a bit more tedious.
                </para>
                <para>
                    If you need to use async code in your transformation, derive from
                    <see cref="T:Marten.Services.Json.Transformations.SystemTextJson.AsyncOnlyEventUpcaster`1" /> instead
                </para>
                <para>
                    Use
                    <c>
                        <see cref="M:Marten.Events.IEventStoreOptions.Upcast(System.Type,System.String,Marten.Services.Json.Transformations.JsonTransformation)">store.options.Upcast</see>
                    </c>
                    method to register upcaster implementation
                    and tell Marten that you'd like to use it.
                </para>
            </summary>
            <example>
                Example implementation:
                <code lang="csharp">
            public class ShoppingCartOpenedUpcaster:
                EventUpcaster&#60;ShoppingCartInitializedWithStatus&#62;
            {
                protected override ShoppingCartInitializedWithStatus Upcast(JsonDocument oldEventJson)
                {
                    var oldEvent = oldEventJson.RootElement;
            
                    return new ShoppingCartInitializedWithStatus(
                        oldEvent.GetProperty("ShoppingCartId").GetGuid(),
                        new Client(
                            oldEvent.GetProperty("ClientId").GetGuid()
                        ),
                        ShoppingCartStatus.Opened
                    );
                }
            }
            </code>
                Example registration:
                <code lang="csharp">
            storeOptions.Events.Upcast&#60;ShoppingCartOpenedUpcaster&#62;();
            </code>
            </example>
            <typeparam name="TEvent">Mapped CLR event type</typeparam>
        </member>
        <member name="M:Marten.Services.Json.Transformations.SystemTextJson.EventUpcaster`1.Upcast(System.Text.Json.JsonDocument)">
            <summary>
                <para>
                    Method defines the event JSON payload transformation using
                    <a href="https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-overview">System.Text.Json</a>
                    .
                    It "upcasts" one event schema into another.
                    You can use it to handle the event schema versioning/migration.
                </para>
                <para>
                    By defining it, you tell that instead of the old CLR type, for the specific event type name,
                    you'd like to get the new CLR event type.
                    Function takes the
                    <a href="https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-overview">
                        System.Text.Json
                        JsonDocument
                    </a>
                    and returns the new, mapped one of type <c>TEvent</c>.
                </para>
                <para>
                    In your application code, you should use only the new event type in the aggregation and projection logic.
                    See more in
                    <a href="https://martendb.io/events/versioning.html#raw-json-transformation-with-system-text-json-1">documentation</a>
                </para>
            </summary>
            <example>
                Example implementation:
                <code lang="csharp">
            protected override ShoppingCartInitializedWithStatus Upcast(JsonDocument oldEventJson)
            {
                var oldEvent = oldEventJson.RootElement;
            
                return new ShoppingCartInitializedWithStatus(
                    oldEvent.GetProperty("ShoppingCartId").GetGuid(),
                    new Client(
                        oldEvent.GetProperty("ClientId").GetGuid()
                    ),
                    ShoppingCartStatus.Opened
                );
            }
            </code>
            </example>
            <param name="oldEvent">
                JSON payload represented by
                <a href="https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-overview">
                    System.Text.Json
                    JsonDocument
                </a>
                ,
                to be transformed into <c>TEvent</c>
            </param>
            <returns>Instance of the <c>TEvent</c> transformed from <c>oldEvent</c>.</returns>
        </member>
        <member name="T:Marten.Services.Json.Transformations.SystemTextJson.AsyncOnlyEventUpcaster`1">
            <summary>
                <para>
                    Base implementation of
                    <a href="https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-overview">System.Text.Json</a>
                    <see cref="T:Marten.Services.Json.Transformations.IEventUpcaster" /> transforming asynchronously JSON payload from one CLR type to the other.
                    Upcasting is a process of transforming the old JSON schema into the new one.
                    You can use it to handle the event schema versioning/migration.
                    By deriving from it, you tell that for specific event type name, you'd like to get the new CLR event type.
                    The default event type name mapping will be used based on <c>TEvent</c> type, unless you override
                    <see cref="!:EventTypeName" /> property
                </para>
                <para>
                    You need to provide the implementation of <see cref="M:Marten.Services.Json.Transformations.SystemTextJson.AsyncOnlyEventUpcaster`1.UpcastAsync(System.Text.Json.JsonDocument,System.Threading.CancellationToken)" /> method.
                    It should contain the logic transforming event payload
                    <a href="https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-overview">
                        System.Text.Json
                        JsonDocument
                    </a>
                    to <c>TEvent</c>.
                </para>
                <para>
                    Compared to the <see cref="T:Marten.Services.Json.Transformations.EventUpcaster`2" /> it allows to do more
                    performant processing.
                    <c>JObject</c>can help you to reduce the number of allocation and memory pressure.
                    By using this implementation, you also don't need to keep the old CLR type in the codebase. Yet, implementation
                    is a bit more tedious.
                </para>
                <para>
                    <b>WARNING:</b> <c>UpcastAsync</c> method is called each type old event is read from database and deserialized.
                    <c>AsyncOnlyEventUpcaster</c> will only be run in the async API and throw exception when run in sync method
                    calls.
                    We discourage to run resource consuming methods here. It might end up with N+1 performance issue.
                    Best is to use sync transformation instead and deriving from <see cref="T:Marten.Services.Json.Transformations.SystemTextJson.EventUpcaster`1" />
                </para>
                <para>
                    Use
                    <c>
                        <see cref="M:Marten.Events.IEventStoreOptions.Upcast(System.Type,System.String,Marten.Services.Json.Transformations.JsonTransformation)">store.options.Upcast</see>
                    </c>
                    method to register upcaster implementation
                    and tell Marten that you'd like to use it.
                </para>
            </summary>
            <example>
                Example implementation:
                <code lang="csharp">
            public class ShoppingCartOpenedAsyncOnlyUpcaster:
                AsyncOnlyEventUpcaster&#60;ShoppingCartInitializedWithStatus&#62;
            {
                private readonly IClientRepository _clientRepository;
            
                public ShoppingCartOpenedAsyncOnlyUpcaster(IClientRepository clientRepository) =>
                    _clientRepository = clientRepository;
            
                protected override async Task&#60;ShoppingCartInitializedWithStatus&#62; UpcastAsync(
                    JsonDocument oldEventJson, CancellationToken ct
                )
                {
                    var oldEvent = oldEventJson.RootElement;
            
                    var clientId = oldEvent.GetProperty("ClientId").GetGuid();
            
                    var clientName = await _clientRepository.GetClientName(clientId, ct);
            
                    return new ShoppingCartInitializedWithStatus(
                        oldEvent.GetProperty("ShoppingCartId").GetGuid(),
                        new Client(clientId, clientName),
                        ShoppingCartStatus.Opened
                    );
                }
            }
            </code>
                Example registration:
                <code lang="csharp">
            storeOptions.Events.Upcast&#60;ShoppingCartOpenedUpcaster&#62;();
            </code>
            </example>
            <typeparam name="TEvent">Mapped CLR event type</typeparam>
            <exception cref="T:Marten.Exceptions.MartenException">when upcaster is called in sync API</exception>
        </member>
        <member name="M:Marten.Services.Json.Transformations.SystemTextJson.AsyncOnlyEventUpcaster`1.UpcastAsync(System.Text.Json.JsonDocument,System.Threading.CancellationToken)">
            <summary>
                <para>
                    Method defines the async event JSON payload transformation using
                    <a href="https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-overview">System.Text.Json</a>
                    .
                    It "upcasts" one event schema into another. It "upcasts" one event schema into another.
                    You can use it to handle the event schema versioning/migration.
                </para>
                <para>
                    By defining it, you tell that instead of the old CLR type, for the specific event type name,
                    you'd like to get the new CLR event type.
                    Provided function takes the deserialized object of the old event type and returns the new, mapped one.
                </para>
                <para>
                    In your application code, you should use only the new event type in the aggregation and projection logic.
                    See more in
                    <a href="https://martendb.io/events/versioning.htmll#class-with-raw-json-transformation-with-system-text-json">documentation</a>
                </para>
                <para>
                    <b>WARNING!</b> <c>UpcastAsync</c> method is called each type old event is read from database and deserialized.
                    <c>AsyncOnlyEventUpcaster</c> will only be run in the async API and throw exception when run in sync method
                    calls.
                    We discourage to run resource consuming methods here. It might end up with N+1 performance issue.
                    Best is to use sync transformation instead and deriving from <see cref="T:Marten.Services.Json.Transformations.SystemTextJson.EventUpcaster`1" />
                </para>
            </summary>
            <example>
                Example implementation:
                <code lang="csharp">
            protected override async Task&#60;ShoppingCartInitializedWithStatus&#62; UpcastAsync(
                JsonDocument oldEventJson, CancellationToken ct
            )
            {
                var oldEvent = oldEventJson.RootElement;
            
                var clientId = oldEvent.GetProperty("ClientId").GetGuid();
            
                var clientName = await _clientRepository.GetClientName(clientId, ct);
            
                return new ShoppingCartInitializedWithStatus(
                    oldEvent.GetProperty("ShoppingCartId").GetGuid(),
                    new Client(clientId, clientName),
                    ShoppingCartStatus.Opened
                );
            }
            </code>
            </example>
            <param name="oldEvent">
                JSON payload represented by
                <a href="https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-overview">
                    System.Text.Json
                    JsonDocument
                </a>
                ,
                to be transformed into <c>TEvent</c>
            </param>
            <param name="ct">Cancellation token</param>
            <returns>Instance of the <c>TEvent</c> transformed from <c>oldEvent</c>.</returns>
            <exception cref="T:Marten.Exceptions.MartenException">when provided transformation is called in sync API</exception>
        </member>
        <member name="M:Marten.Services.Json.Transformations.SystemTextJson.JsonTransformations.Upcast``1(System.Func{System.Text.Json.JsonDocument,``0})">
            <summary>
                Wrapper for System.Text.Json raw JSON payload upcast function registration
            </summary>
            <param name="transform">JSON payload transformation</param>
            <typeparam name="TEvent">Mapped CLR event type</typeparam>
            <returns><see cref="T:Marten.Services.Json.Transformations.JsonTransformation" /> with upcasting definition</returns>
        </member>
        <member name="M:Marten.Services.Json.Transformations.SystemTextJson.JsonTransformations.AsyncOnlyUpcast``1(System.Func{System.Text.Json.JsonDocument,System.Threading.CancellationToken,System.Threading.Tasks.Task{``0}})">
            <summary>
                Wrapper for System.Text.Json async only raw JSON payload upcast function registration
            </summary>
            <param name="transform">JSON payload transformation</param>
            <typeparam name="TEvent">Mapped CLR event type</typeparam>
            <returns><see cref="T:Marten.Services.Json.Transformations.JsonTransformation" /> with upcasting definition</returns>
            <exception cref="T:Marten.Exceptions.MartenException">when upcaster is called in sync API</exception>
        </member>
        <member name="T:Marten.Services.JsonNetSerializer">
            <summary>
                Serialization with Newtonsoft.Json
            </summary>
        </member>
        <member name="P:Marten.Services.JsonNetSerializer.CollectionStorage">
            <summary>
                Specify whether collections should be stored as json arrays (without type names)
            </summary>
        </member>
        <member name="P:Marten.Services.JsonNetSerializer.NonPublicMembersStorage">
            <summary>
                Specify whether non public members should be used during deserialization
            </summary>
        </member>
        <member name="P:Marten.Services.JsonNetSerializer.EnumStorage">
            <summary>
                Specify whether .Net Enum values should be stored as integers or strings
                within the Json document. Default is AsInteger.
            </summary>
        </member>
        <member name="P:Marten.Services.JsonNetSerializer.Casing">
            <summary>
                Specify whether properties in the JSON document should use Camel or Pascal casing.
            </summary>
        </member>
        <member name="M:Marten.Services.JsonNetSerializer.Customize(System.Action{Newtonsoft.Json.JsonSerializer})">
            <summary>
                Customize the inner Newtonsoft formatter.
            </summary>
            <param name="configure"></param>
        </member>
        <member name="M:Marten.Services.JsonNetSerializer.Configure(System.Action{Newtonsoft.Json.JsonSerializerSettings})">
            <summary>
            Configure the <see cref="T:Newtonsoft.Json.JsonSerializerSettings"/> of the Newtonsoft serializer.
            </summary>
            <param name="configure"></param>
        </member>
        <member name="T:Marten.Services.NoDataReturnedCall">
            <summary>
                Marker interface telling Marten not
                to advance the results for callbacks
            </summary>
        </member>
        <member name="F:Marten.Services.TrackLevel.None">
            <summary>
            No Open Telemetry tracking
            </summary>
        </member>
        <member name="F:Marten.Services.TrackLevel.Normal">
            <summary>
            Normal level of Open Telemetry tracking
            </summary>
        </member>
        <member name="F:Marten.Services.TrackLevel.Verbose">
            <summary>
            Very verbose event tracking, only suitable for debugging or performance tuning
            </summary>
        </member>
        <member name="P:Marten.Services.OpenTelemetryOptions.TrackConnections">
            <summary>
            Used to track OpenTelemetry events for opening an connection or exceptions on a connection, for example when a command or data reader has been executed. This defaults to false.
            </summary>
        </member>
        <member name="M:Marten.Services.OpenTelemetryOptions.ExportCounterOnChangeSets``1(System.String,System.String,System.Action{System.Diagnostics.Metrics.Counter{``0},Marten.Services.IChangeSet})">
            <summary>
            Add a custom counter that will be applied after a DocumentSession is committed
            </summary>
            <param name="name"></param>
            <param name="units"></param>
            <param name="recordAction"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Marten.Services.OpenTelemetryOptions.TrackEventCounters">
            <summary>
            Direct Marten to export counters on the events being appended
            </summary>
        </member>
        <member name="F:Marten.Services.SessionOptions.Listeners">
            <summary>
                Add, remove, or reorder local session listeners
            </summary>
        </member>
        <member name="P:Marten.Services.SessionOptions.Tracking">
            <summary>
            Define the type of session document tracking you'd like to open.
            We recommend using lightweight session, and this is the default.<br/>
            Read more in documentation: https://martendb.io/documents/sessions.html.
            </summary>
        </member>
        <member name="P:Marten.Services.SessionOptions.Timeout">
            <summary>
                If not specified, sessions default to Npgsql command timeout (30 seconds)
            </summary>
        </member>
        <member name="P:Marten.Services.SessionOptions.IsolationLevel">
            <summary>
                Default to IsolationLevel.ReadCommitted
            </summary>
        </member>
        <member name="P:Marten.Services.SessionOptions.TenantId">
            <summary>
                Override the tenant id for the requested session
            </summary>
        </member>
        <member name="P:Marten.Services.SessionOptions.ConcurrencyChecks">
            <summary>
                Use to enable or disable optimistic concurrency for just this session
            </summary>
        </member>
        <member name="P:Marten.Services.SessionOptions.Connection">
            <summary>
                Optional mechanism to open a session with an existing connection
            </summary>
        </member>
        <member name="P:Marten.Services.SessionOptions.Transaction">
            <summary>
                Optional mechanism to open a session with an existing transaction
            </summary>
        </member>
        <member name="P:Marten.Services.SessionOptions.OwnsTransactionLifecycle">
            <summary>
                Default is true. If false, Marten will issue commands on IDocumentSession.SaveChanges/SaveChangesAsync,
                but will **not** commit the transaction
            </summary>
        </member>
        <member name="P:Marten.Services.SessionOptions.DotNetTransaction">
            <summary>
                Enlist the session in this transaction
            </summary>
        </member>
        <member name="P:Marten.Services.SessionOptions.AllowAnyTenant">
            <summary>
                If set to true, this allows a session to be opened for "any"
                tenant even if the StoreOptions.Advanced.DefaultTenantUsageEnabled is disabled normally
                in this DocumentStore
            </summary>
        </member>
        <member name="M:Marten.Services.SessionOptions.ForConnectionString(System.String)">
            <summary>
                Create a new session options for the supplied connection string
            </summary>
            <param name="connectionString"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.SessionOptions.ForDatabase(Marten.Storage.IMartenDatabase)">
            <summary>
                Create a session for all tenants within the supplied database
            </summary>
            <param name="database"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.SessionOptions.ForDatabase(System.String,Marten.Storage.IMartenDatabase)">
            <summary>
                Create a session for tenant within the supplied database
            </summary>
            <param name="tenantId"></param>
            <param name="database"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.SessionOptions.WithTracking(Marten.DocumentTracking)">
            <summary>
                Override the document tracking
            </summary>
            <param name="tracking"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.SessionOptions.ListenAt(Marten.IDocumentSessionListener)">
            <summary>
                Add a single document session listener
            </summary>
            <param name="listener"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.SessionOptions.ForTransaction(Npgsql.NpgsqlTransaction,System.Boolean)">
            <summary>
                Enlist in the native Npgsql transaction and direct the session
                *not* to own the transactional lifecycle
            </summary>
            <param name="transaction"></param>
            <param name="shouldAutoCommit">
                Optionally specify whether Marten should commit this transaction when SaveChanges() is
                called.
            </param>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.SessionOptions.ForCurrentTransaction">
            <summary>
                Create a new session options object using the current, ambient
                transaction scope. NOTE THAT MARTEN'S AUTOMATIC DATABASE MIGRATIONS
                DO NOT WORK USING THIS OPTION
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.Services.SessionOptions.EnlistInAmbientTransactionScope">
            <summary>
                Enlist the session in the current, ambient transaction scope
            </summary>
        </member>
        <member name="F:Marten.Services.ConcurrencyChecks.Enabled">
            <summary>
                Optimistic concurrency checks are enforced (Default)
            </summary>
        </member>
        <member name="F:Marten.Services.ConcurrencyChecks.Disabled">
            <summary>
                Optimistic concurrency checks are disabled for this session
            </summary>
        </member>
        <member name="T:Marten.Services.SystemTextJsonSerializer">
            <summary>
                Serializer based on System.Text.Json
            </summary>
        </member>
        <member name="P:Marten.Services.SystemTextJsonSerializer.EnumStorage">
            <inheritdoc />
        </member>
        <member name="P:Marten.Services.SystemTextJsonSerializer.Casing">
            <inheritdoc />
        </member>
        <member name="M:Marten.Services.SystemTextJsonSerializer.Customize(System.Action{System.Text.Json.JsonSerializerOptions})">
            <summary>
                Customize the inner System.Text.Json formatter.
            </summary>
            <param name="configure"></param>
        </member>
        <member name="M:Marten.Services.SystemTextJsonSerializer.Configure(System.Action{System.Text.Json.JsonSerializerOptions})">
            <summary>
             Configure the <see cref="T:System.Text.Json.JsonSerializerOptions"/> of the System.Text.Json serializer.
            </summary>
            <param name="configure"></param>
        </member>
        <member name="T:Marten.Services.VersionTracker">
            <summary>
                Used internally by Marten to track document versions
            </summary>
        </member>
        <member name="T:Marten.Storage.IMartenDatabase">
            <summary>
                Governs the database structure and migration path for a single Marten database
            </summary>
        </member>
        <member name="P:Marten.Storage.IMartenDatabase.Sequences">
            <summary>
                Used to create new Hilo sequences
            </summary>
        </member>
        <member name="P:Marten.Storage.IMartenDatabase.Tracker">
            <summary>
                *If* a projection daemon has been started for this database, this
                is the ShardStateTracker for the running daemon. This is useful in testing
                scenarios
            </summary>
        </member>
        <member name="M:Marten.Storage.IMartenDatabase.EnsureStorageExists(System.Type)">
            <summary>
                Ensures that the IDocumentStorage object for a document type is ready
                and also attempts to update the database schema for any detected changes
            </summary>
            <param name="documentType"></param>
        </member>
        <member name="M:Marten.Storage.IMartenDatabase.EnsureStorageExistsAsync(System.Type,System.Threading.CancellationToken)">
            <summary>
                Ensures that the IDocumentStorage object for a document type is ready
                and also attempts to update the database schema for any detected changes
            </summary>
            <param name="featureType"></param>
            <param name="??????"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Storage.IMartenDatabase.ResetHiloSequenceFloor``1(System.Int64)">
            <summary>
                Set the minimum sequence number for a Hilo sequence for a specific document type
                to the specified floor. Useful for migrating data between databases
            </summary>
            <typeparam name="T"></typeparam>
            <param name="floor"></param>
        </member>
        <member name="M:Marten.Storage.IMartenDatabase.SchemaTables(System.Threading.CancellationToken)">
            <summary>
                Fetch a list of the existing tables in the database
            </summary>
            <param name="database"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Storage.IMartenDatabase.FetchEventStoreStatistics(System.Threading.CancellationToken)">
            <summary>
                Fetch the current size of the event store tables, including the current value
                of the event sequence number
            </summary>
            <param name="tenantId">
                Specify the database containing this tenant id. If omitted, this method uses the default
                database
            </param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Storage.IMartenDatabase.AllProjectionProgress(System.Threading.CancellationToken)">
            <summary>
                Check the current progress of all asynchronous projections
            </summary>
            <param name="token"></param>
            <param name="tenantId">
                Specify the database containing this tenant id. If omitted, this method uses the default
                database
            </param>
            <returns></returns>
        </member>
        <member name="M:Marten.Storage.IMartenDatabase.ProjectionProgressFor(Marten.Events.Daemon.ShardName,System.Threading.CancellationToken)">
            <summary>
                Check the current progress of a single projection or projection shard
            </summary>
            <param name="tenantId">
                Specify the database containing this tenant id. If omitted, this method uses the default
                database
            </param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Storage.IMartenDatabase.FindEventStoreFloorAtTimeAsync(System.DateTimeOffset,System.Threading.CancellationToken)">
            <summary>
            Find the position of the event store sequence just below the supplied timestamp. Will
            return null if there are no events below that time threshold
            </summary>
            <param name="timestamp"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="T:Marten.Storage.ITenancyWithMasterDatabase">
            <summary>
            Marks a tenancy model as having a master database
            </summary>
        </member>
        <member name="T:Marten.Storage.ITenancy">
            <summary>
                Pluggable interface for Marten multi-tenancy by database
            </summary>
        </member>
        <member name="P:Marten.Storage.ITenancy.Default">
            <summary>
                The default tenant. This can be null.
            </summary>
        </member>
        <member name="P:Marten.Storage.ITenancy.Cleaner">
            <summary>
                A composite document cleaner for the entire collection of databases
            </summary>
        </member>
        <member name="M:Marten.Storage.ITenancy.GetTenant(System.String)">
            <summary>
                Retrieve or create a Tenant for the tenant id.
            </summary>
            <param name="tenantId"></param>
            <exception cref="T:Marten.Storage.UnknownTenantIdException"></exception>
            <returns></returns>
        </member>
        <member name="M:Marten.Storage.ITenancy.GetTenantAsync(System.String)">
            <summary>
                Retrieve or create a tenant for the tenant id
            </summary>
            <param name="tenantId"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Storage.ITenancy.FindOrCreateDatabase(System.String)">
            <summary>
                Find or create the named database
            </summary>
            <param name="tenantIdOrDatabaseIdentifier"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Storage.ITenancy.IsTenantStoredInCurrentDatabase(Marten.Storage.IMartenDatabase,System.String)">
            <summary>
             Asserts that the requested tenant id is part of the current database
            </summary>
            <param name="database"></param>
            <param name="tenantId"></param>
        </member>
        <member name="M:Marten.Storage.MartenDatabase.ResetHiloSequenceFloor``1(System.Int64)">
            <summary>
                Set the minimum sequence number for a Hilo sequence for a specific document type
                to the specified floor. Useful for migrating data between databases
            </summary>
            <typeparam name="T"></typeparam>
            <param name="floor"></param>
        </member>
        <member name="M:Marten.Storage.MartenDatabase.FetchEventStoreStatistics(System.Threading.CancellationToken)">
            <summary>
                Fetch the current size of the event store tables, including the current value
                of the event sequence number
            </summary>
            <param name="tenantId">
                Specify the database containing this tenant id. If omitted, this method uses the default
                database
            </param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Storage.MartenDatabase.AllProjectionProgress(System.Threading.CancellationToken)">
            <summary>
                Check the current progress of all asynchronous projections
            </summary>
            <param name="token"></param>
            <param name="tenantId">
                Specify the database containing this tenant id. If omitted, this method uses the default
                database
            </param>
            <returns></returns>
        </member>
        <member name="M:Marten.Storage.MartenDatabase.ProjectionProgressFor(Marten.Events.Daemon.ShardName,System.Threading.CancellationToken)">
            <summary>
                Check the current progress of a single projection or projection shard
            </summary>
            <param name="tenantId">
                Specify the database containing this tenant id. If omitted, this method uses the default
                database
            </param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="P:Marten.Storage.MartenDatabase.Tracker">
            <summary>
                *If* a projection daemon has been started for this database, this
                is the ShardStateTracker for the running daemon. This is useful in testing
                scenarios
            </summary>
        </member>
        <member name="P:Marten.Storage.MasterTableTenancyOptions.ConnectionString">
            <summary>
                The connection string of the master database holding the tenant table
            </summary>
        </member>
        <member name="P:Marten.Storage.MasterTableTenancyOptions.DataSource">
            <summary>
                A configured data source for managing the tenancy
            </summary>
        </member>
        <member name="P:Marten.Storage.MasterTableTenancyOptions.SchemaName">
            <summary>
                If specified, override the database schema name for the tenants table
                Default is "public"
            </summary>
        </member>
        <member name="P:Marten.Storage.MasterTableTenancyOptions.ApplicationName">
            <summary>
                Set an application name in the connection strings strictly for diagnostics
            </summary>
        </member>
        <member name="P:Marten.Storage.MasterTableTenancyOptions.AutoCreate">
            <summary>
                If set, this will override the AutoCreate setting for just the master tenancy table
            </summary>
        </member>
        <member name="M:Marten.Storage.MasterTableTenancyOptions.RegisterDatabase(System.String,System.String)">
            <summary>
                For the sake of testing, seed the master tenancy table with a tenant
                database
            </summary>
            <param name="tenantId"></param>
            <param name="connectionString"></param>
        </member>
        <member name="P:Marten.Storage.Metadata.DocumentMetadata.Id">
            <summary>
                The identity of the document
            </summary>
        </member>
        <member name="P:Marten.Storage.Metadata.DocumentMetadata.CreatedAt">
            <summary>
                Timestamp of when this document was created
            </summary>
        </member>
        <member name="P:Marten.Storage.Metadata.DocumentMetadata.CurrentVersion">
            <summary>
                The current version of this document in the database
            </summary>
        </member>
        <member name="P:Marten.Storage.Metadata.DocumentMetadata.CurrentRevision">
            <summary>
                The current version of this document in the database if using numeric revisions
            </summary>
        </member>
        <member name="P:Marten.Storage.Metadata.DocumentMetadata.LastModified">
            <summary>
                Timestamp of the last time this document was modified
            </summary>
        </member>
        <member name="P:Marten.Storage.Metadata.DocumentMetadata.DotNetType">
            <summary>
                The full name of the .Net type that was persisted
            </summary>
        </member>
        <member name="P:Marten.Storage.Metadata.DocumentMetadata.DocumentType">
            <summary>
                If the document is part of a type hierarchy, this designates
                Marten's internal name for the sub type
            </summary>
        </member>
        <member name="P:Marten.Storage.Metadata.DocumentMetadata.Deleted">
            <summary>
                If soft-deleted, whether or not the document is marked as deleted
            </summary>
        </member>
        <member name="P:Marten.Storage.Metadata.DocumentMetadata.DeletedAt">
            <summary>
                If soft-deleted, the time at which the document was marked as deleted
            </summary>
        </member>
        <member name="P:Marten.Storage.Metadata.DocumentMetadata.TenantId">
            <summary>
                The stored tenant id of this document
            </summary>
        </member>
        <member name="P:Marten.Storage.Metadata.DocumentMetadata.CausationId">
            <summary>
                Optional metadata describing the causation id for this
                unit of work
            </summary>
        </member>
        <member name="P:Marten.Storage.Metadata.DocumentMetadata.CorrelationId">
            <summary>
                Optional metadata describing the correlation id for this
                unit of work
            </summary>
        </member>
        <member name="P:Marten.Storage.Metadata.DocumentMetadata.LastModifiedBy">
            <summary>
                Optional metadata describing the user name or
                process name for this unit of work
            </summary>
        </member>
        <member name="P:Marten.Storage.Metadata.DocumentMetadata.Headers">
            <summary>
                Optional, user defined headers
            </summary>
        </member>
        <member name="P:Marten.Storage.Metadata.MetadataColumn.Enabled">
            <summary>
                Is this metadata column enabled?
            </summary>
        </member>
        <member name="M:Marten.Storage.ISingleServerMultiTenancy.WithTenants(System.String[])">
            <summary>
                Use to seed tenant database names for Marten database management
            </summary>
            <param name="tenantIds"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Storage.ISingleServerMultiTenancy.InDatabaseNamed(System.String)">
            <summary>
                Add the previous tenantIds to the named database
            </summary>
            <param name="databaseName"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Storage.IStaticMultiTenancy.AddMultipleTenantDatabase(System.String,System.String)">
            <summary>
                Register a database that will hold data for multiple conjoined tenants
            </summary>
            <param name="connectionString"></param>
            <param name="databaseIdentifier">
                A descriptive name for this database. If omitted, this will be derived from the
                connection string
            </param>
            <returns></returns>
        </member>
        <member name="M:Marten.Storage.StaticMultiTenancy.AddMultipleTenantDatabase(System.String,System.String)">
            <summary>
                Register a database that will hold data for multiple conjoined tenants
            </summary>
            <param name="connectionString"></param>
            <param name="databaseIdentifier">
                A descriptive name for this database. If omitted, this will be derived from the
                connection string
            </param>
            <returns></returns>
        </member>
        <member name="M:Marten.Storage.StaticMultiTenancy.DatabaseExpression.ForTenants(System.String[])">
            <summary>
                Tells Marten that the designated tenant ids are stored in the current database
            </summary>
            <param name="tenantIds"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Storage.IDatabaseExpression.ForTenants(System.String[])">
            <summary>
                Tells Marten that the designated tenant ids are stored in the current database
            </summary>
            <param name="tenantIds"></param>
            <returns></returns>
        </member>
        <member name="P:Marten.Storage.StorageFeatures.ExtendedSchemaObjects">
            <summary>
                Additional Postgresql tables, functions, or sequences to be managed by this DocumentStore
            </summary>
        </member>
        <member name="M:Marten.Storage.StorageFeatures.Add(Weasel.Core.Migrations.IFeatureSchema)">
            <summary>
                Register custom storage features
            </summary>
            <param name="feature"></param>
        </member>
        <member name="M:Marten.Storage.StorageFeatures.Add``1">
            <summary>
                Register custom storage features by type. Type must have either a no-arg, public
                constructor or a constructor that takes in a single StoreOptions parameter
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Marten.Storage.StorageFeatures.FindFeature(System.Type)">
            <summary>
                Retrieve an IFeatureSchema for the designated type
            </summary>
            <param name="featureType"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Storage.StorageFeatures.IncludeDocumentMappingBuilders(Marten.Storage.StorageFeatures)">
            <summary>
                Used to support MartenRegistry.Include()
            </summary>
            <param name="includedStorage"></param>
        </member>
        <member name="F:Marten.Storage.TenancyStyle.Single">
            <summary>
                No multi-tenancy, the default mode
            </summary>
        </member>
        <member name="F:Marten.Storage.TenancyStyle.Conjoined">
            <summary>
                Multi-tenanted within the same database/schema through a tenant id
            </summary>
        </member>
        <member name="F:Marten.TenantIdStyle.CaseSensitive">
            <summary>
            Use the tenant id as is wherever it is supplied
            </summary>
        </member>
        <member name="F:Marten.TenantIdStyle.ForceUpperCase">
            <summary>
            Quietly convert all supplied tenant identifiers to all upper case to prevent
            any possible issues with case sensitive tenant id mismatches
            </summary>
        </member>
        <member name="F:Marten.TenantIdStyle.ForceLowerCase">
            <summary>
            Quietly convert all supplied tenant identifiers to all lower case to prevent
            any possible issues with case sensitive tenant id mismatches
            </summary>
        </member>
        <member name="T:Marten.StoreOptions">
            <summary>
                StoreOptions supplies all the necessary configuration
                necessary to customize and bootstrap a working
                DocumentStore
            </summary>
        </member>
        <member name="F:Marten.StoreOptions.InitialData">
            <summary>
                Register "initial data loads" that will be applied to the DocumentStore when it is
                bootstrapped
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.TenantIdStyle">
            <summary>
            Configure tenant id behavior within this Marten DocumentStore
            </summary>
        </member>
        <member name="F:Marten.StoreOptions.Listeners">
            <summary>
                Add, remove, or reorder global session listeners
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.OpenTelemetry">
            <summary>
            Used to enable or disable Marten's OpenTelemetry features for just this session.
            </summary>
        </member>
        <member name="F:Marten.StoreOptions.Schema">
            <summary>
                Modify the document and event store database mappings for indexes and searching options
            </summary>
        </member>
        <member name="F:Marten.StoreOptions.AutoCreateSchemaObjects">
            <summary>
                Whether or Marten should attempt to create any missing database schema objects at runtime. This
                property is "CreateOrUpdate" by default for more efficient development, but can be set to lower values for production usage.
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.DisableNpgsqlLogging">
            <summary>
            Npgsql logging is absurdly noisy, you may want to disable the logging. Default is false
            </summary>
        </member>
        <member name="M:Marten.StoreOptions.ConfigurePolly(System.Action{Polly.ResiliencePipelineBuilder})">
            <summary>
            Configure and override the Polly error handling policies for this DocumentStore
            </summary>
            <param name="configure"></param>
        </member>
        <member name="M:Marten.StoreOptions.ExtendPolly(System.Action{Polly.ResiliencePipelineBuilder})">
            <summary>
            Extend default error handling policies for this DocumentStore.
            Any user supplied policies will take precedence over the default policies.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Marten.StoreOptions.UseStickyConnectionLifetimes" -->
        <member name="P:Marten.StoreOptions.ResiliencePipeline">
            <summary>
            Polly policies for retries within Marten command execution
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.ApplyChangesLockId">
            <summary>
                Advisory lock id is used by the ApplyChangesOnStartup() option to serialize access to making
                schema changes from multiple application nodes
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.ShouldApplyChangesOnStartup">
            <summary>
                Used internally by the MartenActivator
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.ShouldAssertDatabaseMatchesConfigurationOnStartup">
            <summary>
                Used internally by the MartenActivator
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.Projections">
            <summary>
                Configuration for all event store projections
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.GeneratedCodeMode">
            <summary>
                Direct Marten to either generate code at runtime (Dynamic), or attempt to load types from the entry assembly
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.Storage">
            <summary>
                Access to adding custom schema features to this Marten-enabled Postgresql database
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.Advanced">
            <summary>
                Advanced configuration options for this DocumentStore
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.Events">
            <summary>
                Configuration of event streams and projections
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.Linq">
            <summary>
                Extension point to add custom Linq query parsers
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.Policies">
            <summary>
                Apply conventional policies to how documents are mapped
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.DatabaseSchemaName">
            <summary>
                Sets the database default schema name used to store the documents.
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.NameDataLength">
            <summary>
                Used to validate database object name lengths against Postgresql's NAMEDATALEN property to avoid
                Marten getting confused when comparing database schemas against the configuration. See
                https://www.postgresql.org/docs/current/static/sql-syntax-lexical.html
                for more information. This does NOT adjust NAMEDATALEN for you.
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.EnumStorage">
            <summary>
                Gets Enum values stored as either integers or strings. This is configured on your ISerializer
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.UpdateBatchSize">
            <summary>
                Sets the batch size for updating or deleting documents in IDocumentSession.SaveChanges() /
                IUnitOfWork.ApplyChanges()
            </summary>
        </member>
        <member name="M:Marten.StoreOptions.Serializer">
            <summary>
                Retrieve the currently configured serializer
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.StoreOptions.Logger">
            <summary>
                Retrieve the currently configured logger for this DocumentStore
            </summary>
            <returns></returns>
        </member>
        <member name="P:Marten.StoreOptions.Tenancy">
            <summary>
                Get or set the tenancy model for this DocumentStore
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Marten.StoreOptions.CreateDatabasesForTenants(System.Action{Marten.Schema.IDatabaseCreationExpressions})" -->
        <member name="M:Marten.StoreOptions.DataSourceFactory(Weasel.Postgresql.Connections.INpgsqlDataSourceFactory,System.String)">
            <summary>
                Sets custom `NpgsqlDataSource` factory to manage database connections
            </summary>
            <param name="dataSourceFactory"></param>
            <param name="connectionString"></param>
        </member>
        <member name="M:Marten.StoreOptions.Connection(System.String)">
            <summary>
                Supply the connection string to the Postgresql database
            </summary>
            <param name="connectionString"></param>
        </member>
        <member name="M:Marten.StoreOptions.Connection(System.Func{System.String})">
            <summary>
                Supply a source for the connection string to a Postgresql database
            </summary>
            <param name="connectionSource"></param>
        </member>
        <member name="M:Marten.StoreOptions.Connection(System.Func{Npgsql.NpgsqlConnection})">
            <summary>
                Supply a mechanism for resolving an NpgsqlConnection object to
                the Postgresql database
            </summary>
            <param name="source"></param>
        </member>
        <member name="M:Marten.StoreOptions.Connection(Npgsql.NpgsqlDataSource)">
            <summary>
                Supply a mechanism for resolving an NpgsqlConnection object based on the NpgsqlDataSource
            </summary>
            <remarks>
                When doing that you need to handle data source disposal.
            </remarks>
            <param name="dataSource"></param>
        </member>
        <member name="M:Marten.StoreOptions.Connection(System.Func{System.String,Npgsql.NpgsqlDataSourceBuilder},Npgsql.NpgsqlDataSource)">
            <summary>
                Supply a mechanism for resolving an NpgsqlConnection object based on the NpgsqlDataSource
            </summary>
            <remarks>
                When doing that you need to handle data source disposal.
            </remarks>
            <param name="dataSourceBuilderFactory"></param>
            <param name="dataSource"></param>
        </member>
        <member name="M:Marten.StoreOptions.Serializer(Marten.ISerializer)">
            <summary>
                Override the JSON serialization by ISerializer type
            </summary>
            <param name="serializer"></param>
        </member>
        <member name="M:Marten.StoreOptions.UseDefaultSerialization(Weasel.Core.EnumStorage,Marten.Casing,Marten.CollectionStorage,Marten.NonPublicMembersStorage,Marten.Services.Json.SerializerType)">
            <summary>
                Configure the default serializer settings
            </summary>
            <param name="enumStorage"></param>
            <param name="casing">Casing style to be used in serialization</param>
            <param name="collectionStorage">Allow to set collection storage as raw arrays (without explicit types)</param>
            <param name="nonPublicMembersStorage">Allow non public members to be used during deserialization</param>
        </member>
        <member name="M:Marten.StoreOptions.UseNewtonsoftForSerialization(Weasel.Core.EnumStorage,Marten.Casing,Marten.CollectionStorage,Marten.NonPublicMembersStorage,System.Action{Newtonsoft.Json.JsonSerializerSettings})">
            <summary>
                Configure the Newtonsoft serializer settings
            </summary>
            <param name="enumStorage">Enum storage style</param>
            <param name="casing">Casing style to be used in serialization</param>
            <param name="collectionStorage">Allow to set collection storage as raw arrays (without explicit types)</param>
            <param name="nonPublicMembersStorage">Allow non public members to be used during deserialization</param>
        </member>
        <member name="M:Marten.StoreOptions.UseSystemTextJsonForSerialization(Weasel.Core.EnumStorage,Marten.Casing,System.Action{System.Text.Json.JsonSerializerOptions})">
            <summary>
                Configure the System.Text.Json serializer settings
            </summary>
            <param name="enumStorage">Enum storage style</param>
            <param name="casing">Casing style to be used in serialization</param>
        </member>
        <member name="M:Marten.StoreOptions.UseSystemTextJsonForSerialization(System.Text.Json.JsonSerializerOptions,Weasel.Core.EnumStorage,Marten.Casing,System.Action{System.Text.Json.JsonSerializerOptions})">
            <summary>
                Configure the System.Text.Json serializer settings
            </summary>
            <param name="options">The base settings.</param>
            <param name="enumStorage">Enum storage style</param>
            <param name="casing">Casing style to be used in serialization</param>
        </member>
        <member name="M:Marten.StoreOptions.Serializer``1">
            <summary>
                Override the JSON serialization by an ISerializer of type "T"
            </summary>
            <typeparam name="T">The ISerializer type</typeparam>
        </member>
        <member name="M:Marten.StoreOptions.Logger(Marten.IMartenLogger)">
            <summary>
                Replace the Marten logging strategy
            </summary>
            <param name="logger"></param>
        </member>
        <member name="M:Marten.StoreOptions.Validate">
            <summary>
                Validate that minimal options to initialize a document store have been specified
            </summary>
        </member>
        <member name="M:Marten.StoreOptions.SetApplicationProject(System.Reflection.Assembly,System.String)">
            <summary>
                Meant for testing scenarios to "help" .Net understand where the IHostEnvironment for the
                Host. You may have to specify the relative path to the entry project folder from the AppContext.BaseDirectory
            </summary>
            <param name="services"></param>
            <param name="assembly"></param>
            <param name="hintPath"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.StoreOptions.MultiTenantedWithSingleServer(System.String,System.Action{Marten.Storage.ISingleServerMultiTenancy})">
            <summary>
                Opt into a multi-tenancy per database strategy where all databases
                are on the same Postgresql server instance
            </summary>
            <param name="masterConnectionString"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.StoreOptions.MultiTenantedDatabases(System.Action{Marten.Storage.IStaticMultiTenancy})">
            <summary>
                Opt into multi-tenancy per database strategy where all the
                databases and tenants have to be statically configured at
                bootstrapping time
            </summary>
            <param name="configure"></param>
        </member>
        <member name="M:Marten.StoreOptions.PoliciesExpression.OnDocuments``1">
            <summary>
                Add a pre-built Marten document policy
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Marten.StoreOptions.PoliciesExpression.OnDocuments(Marten.IDocumentPolicy)">
            <summary>
                Add a pre-built Marten document policy
            </summary>
            <param name="policy"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.StoreOptions.PoliciesExpression.ForAllDocuments(System.Action{Marten.Schema.DocumentMapping})">
            <summary>
                Apply configuration to the persistence of all Marten document
                types
            </summary>
            <param name="configure"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.StoreOptions.PoliciesExpression.AllDocumentsAreMultiTenanted">
            <summary>
                Unless explicitly marked otherwise, all documents should
                use conjoined multi-tenancy
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.StoreOptions.PoliciesExpression.AllDocumentsSoftDeleted">
            <summary>
                Unless explicitly marked otherwise, all documents should
                be soft-deleted
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.StoreOptions.PoliciesExpression.DisableInformationalFields">
            <summary>
                Turn off the informational metadata columns
                in storage like the last modified, version, and
                dot net type for leaner storage
            </summary>
        </member>
        <member name="M:Marten.StoreOptions.PoliciesExpression.AllDocumentsEnforceOptimisticConcurrency">
            <summary>
                All document types will have optimistic concurrency checks
            </summary>
            <returns></returns>
        </member>
        <member name="M:Marten.StoreOptions.MultiTenantedDatabasesWithMasterDatabaseTable(System.String,System.String)">
            <summary>
            Multi-tenancy strategy where the tenant database connection strings are defined in a table
            named "mt_tenant_databases"
            </summary>
            <param name="connectionString">A connection string to the database that will hold the tenant database lookup table </param>
            <param name="schemaName">If specified, override the schema name where the tenant database lookup table wil be</param>
        </member>
        <member name="M:Marten.StoreOptions.MultiTenantedDatabasesWithMasterDatabaseTable(System.Action{Marten.Storage.MasterTableTenancyOptions})">
            <summary>
            Multi-tenancy strategy where the tenant database connection strings are defined in a table
            named "mt_tenant_databases"
            </summary>
            <param name="configure"></param>
        </member>
        <member name="P:Marten.StoreOptions.ApplicationAssembly">
            <summary>
                The main application assembly. By default this is the entry assembly for the application,
                but you may need to change this in testing scenarios
            </summary>
        </member>
        <member name="P:Marten.StoreOptions.GeneratedCodeOutputPath">
            <summary>
                Root folder where generated code should be placed. By default, this is the IHostEnvironment.ContentRootPath
            </summary>
        </member>
        <member name="M:Marten.StoreOptions.RegisterDocumentType``1">
            <summary>
                Force Marten to create document mappings for type T
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Marten.StoreOptions.RegisterDocumentType(System.Type)">
            <summary>
                Force Marten to create a document mapping for the document type
            </summary>
            <param name="documentType"></param>
        </member>
        <member name="M:Marten.StoreOptions.AutoRegister(System.Action{Marten.StoreOptions.MartenAssemblyScanner})">
            <summary>
            Scan the application assembly and any other supplied assemblies to
            discover compiled query types, event types by supplied filters, or
            any type decorated with a MartenAttribute
            </summary>
            <param name="configure">Configure the automatic type discovery</param>
        </member>
        <member name="M:Marten.StoreOptions.AutoRegister">
            <summary>
            Scan the application assembly to
            discover compiled query types or
            any type decorated with a MartenAttribute
            </summary>
        </member>
        <member name="M:Marten.StoreOptions.RegisterDocumentTypes(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
                Force Marten to create document mappings for all the given document types
            </summary>
            <param name="documentTypes"></param>
        </member>
        <member name="M:Marten.StoreOptions.RegisterCompiledQueryType(System.Type)">
            <summary>
                Register a compiled query type for the "generate ahead" code generation strategy
            </summary>
            <param name="queryType"></param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Marten.StoreOptions.MartenAssemblyScanner.Assembly(System.Reflection.Assembly)">
            <summary>
            Which assemblies in addition to the StoreOptions.ApplicationAssembly should
            be scanned for potential Marten registrations?
            </summary>
            <param name="assembly"></param>
        </member>
        <member name="M:Marten.StoreOptions.MartenAssemblyScanner.EventsMatch(System.Func{System.Type,System.Boolean})">
            <summary>
            Use your own logic to tell Marten which types are event types!
            </summary>
            <param name="filter"></param>
        </member>
        <member name="M:Marten.StoreOptions.MartenAssemblyScanner.EventsImplement``1">
            <summary>
            Find and register any event types that implement the supplied
            interface or base class
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Marten.StoreOptions.MartenAssemblyScanner.EventsImplement(System.Type)">
            <summary>
            Find and register any event types that implement the supplied
            interface or base class
            </summary>
            <param name="type"></param>
        </member>
        <member name="P:Marten.IReadOnlyAdvancedOptions.DuplicatedFieldEnumStorage">
            <summary>
                Sets Enum values stored as either integers or strings for DuplicatedField.
            </summary>
        </member>
        <member name="P:Marten.IReadOnlyAdvancedOptions.HiloSequenceDefaults">
            <summary>
                Global default parameters for Hilo sequences within the DocumentStore. Can be overridden per document
                type as well
            </summary>
        </member>
        <member name="P:Marten.IReadOnlyAdvancedOptions.DefaultTenantUsageEnabled">
            <summary>
                Option to enable or disable usage of default tenant when using multi-tenanted documents
            </summary>
        </member>
        <member name="P:Marten.MultiHostSettings.ReadSessionPreference">
            <summary>
            Sets the target session attributes for read-only sessions. Defaults to <see cref="F:Npgsql.TargetSessionAttributes.Primary"/>
            </summary>
        </member>
        <member name="P:Marten.MultiHostSettings.WriteSessionPreference">
            <summary>
            Sets the target session attributes for write sessions. Defaults to <see cref="F:Npgsql.TargetSessionAttributes.Primary"/>
            </summary>
        </member>
        <member name="M:Marten.AdvancedOptions.ModifySerializer(System.Action{Marten.ISerializer})">
            <summary>
            Register configurations to the ISerializer that will be applied at the last
            second to the application's serializer settings. This was meant for Marten
            add ons
            </summary>
            <param name="configure"></param>
        </member>
        <member name="P:Marten.AdvancedOptions.HiloSequenceDefaults">
            <summary>
                Global default parameters for Hilo sequences within the DocumentStore. Can be overridden per document
                type as well
            </summary>
        </member>
        <member name="P:Marten.AdvancedOptions.Migrator">
            <summary>
                Allows you to modify how the DDL for document tables and upsert functions is
                written
            </summary>
        </member>
        <member name="P:Marten.AdvancedOptions.MultiHostSettings">
            <summary>
            Configuration options when using a <see cref="T:Npgsql.NpgsqlMultiHostDataSource"/>
            </summary>
        </member>
        <member name="P:Marten.AdvancedOptions.DuplicatedFieldUseTimestampWithoutTimeZoneForDateTime">
            <summary>
                Decides if `timestamp without time zone` database type should be used for `DateTime` DuplicatedField.
            </summary>
        </member>
        <member name="P:Marten.AdvancedOptions.DuplicatedFieldEnumStorage">
            <summary>
                Sets Enum values stored as either integers or strings for DuplicatedField.
            </summary>
        </member>
        <member name="P:Marten.AdvancedOptions.DefaultTenantUsageEnabled">
            <summary>
                Option to enable or disable usage of default tenant when using multi-tenanted documents
            </summary>
        </member>
        <member name="T:Marten.Subscriptions.ISubscription">
            <summary>
            Basic abstraction for custom subscriptions to Marten events through the async daemon. Use this in
            order to do custom processing against an ordered stream of the events
            </summary>
        </member>
        <member name="M:Marten.Subscriptions.ISubscription.ProcessEventsAsync(Marten.Events.Daemon.Internals.EventRange,Marten.Events.Daemon.ISubscriptionController,Marten.IDocumentOperations,System.Threading.CancellationToken)">
            <summary>
            Processes a page of events at a time
            </summary>
            <param name="page"></param>
            <param name="controller">Use to log dead letter events that are skipped or to stop the subscription from processing based on an exception</param>
            <param name="operations">Access to Marten queries and writes that will be committed with the progress update for this subscription</param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="T:Marten.Subscriptions.SubscriptionBase">
            <summary>
            Base class for custom subscriptions for Marten event data
            </summary>
        </member>
        <member name="M:Marten.Subscriptions.SubscriptionBase.ProcessEventsAsync(Marten.Events.Daemon.Internals.EventRange,Marten.Events.Daemon.ISubscriptionController,Marten.IDocumentOperations,System.Threading.CancellationToken)">
            <summary>
            How to process events
            </summary>
            <param name="page"></param>
            <param name="controller"></param>
            <param name="operations"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Marten.Subscriptions.SubscriptionBase.buildSubscription(Marten.DocumentStore)">
            <summary>
            Build the actual subscription object. By default, this just returns itself
            </summary>
            <param name="store"></param>
            <returns></returns>
        </member>
        <member name="P:Marten.Subscriptions.SubscriptionBase.SubscriptionName">
            <summary>
            Descriptive name for Marten progress tracking and rebuild/replays
            </summary>
        </member>
        <member name="P:Marten.Subscriptions.SubscriptionBase.SubscriptionVersion">
            <summary>
            If this value is greater than 1, it will be treated as an all new subscription and will played from zero
            when deployed
            </summary>
        </member>
        <member name="P:Marten.Subscriptions.SubscriptionBase.Options">
            <summary>
            Fine tune the behavior of this subscription at runtime
            </summary>
        </member>
        <member name="M:EventStoreOptionsExtensions.MapEventTypeWithNameSuffix``1(Marten.Events.IEventStoreOptions,System.String,System.String)">
            <summary>
                Maps CLR event type as particular event type name and suffix. This is useful for event type migration.
                See more in <a href="https://martendb.io/events/versioning.html#event-type-name-migration">documentation</a>
            </summary>
            <param name="options">Event store options</param>
            <param name="eventTypeName">Event type name</param>
            <param name="suffix">Event type name suffix</param>
            <typeparam name="TEvent">Mapped CLR event type</typeparam>
        </member>
        <member name="M:EventStoreOptionsExtensions.MapEventTypeWithNameSuffix``1(Marten.Events.IEventStoreOptions,System.String)">
            <summary>
                Maps CLR event type as particular event type name and suffix. This is useful for event type migration.
                See more in <a href="https://martendb.io/events/versioning.html#event-type-name-migration">documentation</a>
            </summary>
            <param name="options">Event store options</param>
            <param name="suffix">Event type name suffix</param>
            <typeparam name="TEvent">Mapped CLR event type</typeparam>
        </member>
        <member name="M:EventStoreOptionsExtensions.MapEventTypeWithSchemaVersion``1(Marten.Events.IEventStoreOptions,System.UInt32)">
            <summary>
                Maps CLR event type as particular event type name and suffix. This is useful for event type migration.
                See more in <a href="https://martendb.io/events/versioning.html#event-type-name-migration">documentation</a>
            </summary>
            <param name="options">Event store options</param>
            <param name="eventTypeName">Event type name</param>
            <param name="schemaVersion">Event schema version</param>
            <typeparam name="TEvent">Mapped CLR event type</typeparam>
        </member>
        <member name="M:EventStoreOptionsExtensions.MapEventTypeWithSchemaVersion``1(Marten.Events.IEventStoreOptions,System.String,System.UInt32)">
            <summary>
                Maps CLR event type as particular event type name and suffix. This is useful for event type migration.
                See more in <a href="https://martendb.io/events/versioning.html#event-type-name-migration">documentation</a>
            </summary>
            <param name="options">Event store options</param>
            <param name="eventTypeName">Event type name</param>
            <param name="schemaVersion">Event schema version</param>
            <typeparam name="TEvent">Mapped CLR event type</typeparam>
        </member>
        <member name="M:EventStoreOptionsExtensions.Upcast``1(Marten.Events.IEventStoreOptions,Marten.Services.Json.Transformations.JsonTransformation)">
            <summary>
                <para>
                    Method defines the JSON payload transformation. It "upcasts" one event schema into another.
                    You can use it to handle the event schema versioning/migration.
                </para>
                <para>
                    By calling it, you tell that you'd like to get the particular CLR event type.
                    Event type name will be used from the default <c>TEvent</c> mapping.
                    JSON transformation defines the custom mapping from JSON string to the CLR object.
                </para>
                <para>
                    When you define it, default deserialization for the particular event type won't be used.
                    See more in
                    <a href="https://martendb.io/events/versioning.html#raw-json-transformation-with-json-net">documentation</a>
                </para>
            </summary>
            <param name="options">Event store options</param>
            <param name="eventTypeName">Event type name</param>
            <param name="jsonTransformation">Event payload transformation</param>
            <typeparam name="TEvent">Mapped CLR event type</typeparam>
            <returns>Event store options, to allow fluent definition</returns>
        </member>
        <member name="M:EventStoreOptionsExtensions.Upcast(Marten.Events.IEventStoreOptions,System.Type,Marten.Services.Json.Transformations.JsonTransformation)">
            <summary>
                <para>
                    Method defines the event JSON payload transformation. It "upcasts" one event schema into another.
                    You can use it to handle the event schema versioning/migration.
                </para>
                <para>
                    By calling it, you tell that you'd like to get the particular CLR event type.
                    Event type name will be used from the default <see cref="!:eventType" /> mapping.
                    JSON transformation defines the custom mapping from JSON string to the CLR object.
                </para>
                <para>
                    When you define it, default deserialization for the particular event type won't be used.
                    See more in
                    <a href="https://martendb.io/events/versioning.html#raw-json-transformation-with-json-net">documentation</a>
                </para>
            </summary>
            <param name="options">Event store options</param>
            <param name="eventType">Mapped CLR event type</param>
            <param name="jsonTransformation">Event payload transformation</param>
            <returns>Event store options, to allow fluent definition</returns>
        </member>
        <member name="M:EventStoreOptionsExtensions.Upcast``1(Marten.Events.IEventStoreOptions,System.UInt32,Marten.Services.Json.Transformations.JsonTransformation)">
            <summary>
                <para>
                    Method defines the JSON payload transformation. It "upcasts" one event schema version into another.
                    You can use it to handle the event schema versioning/migration.
                </para>
                <para>
                    By calling it, you tell that for provided event type name, you'd like to get the particular CLR event type.
                    JSON transformation defines the custom mapping from JSON string to the CLR object.
                </para>
                <para>
                    When you define it, default deserialization for the particular event type won't be used.
                    See more in
                    <a href="https://martendb.io/events/versioning.html#raw-json-transformation-with-json-net">documentation</a>
                </para>
            </summary>
            <param name="options">Event store options</param>
            <param name="schemaVersion">Event schema version</param>
            <param name="jsonTransformation">Event payload transformation</param>
            <typeparam name="TEvent">Mapped CLR event type</typeparam>
            <returns>Event store options, to allow fluent definition</returns>
        </member>
        <member name="M:EventStoreOptionsExtensions.Upcast(Marten.Events.IEventStoreOptions,System.Type,System.UInt32,Marten.Services.Json.Transformations.JsonTransformation)">
            <summary>
                <para>
                    Method defines the event JSON payload transformation. It "upcasts" one event schema version into another.
                    You can use it to handle the event schema versioning/migration.
                </para>
                <para>
                    By calling it, you tell that for provided event type name, you'd like to get the particular CLR event type.
                    JSON transformation defines the custom mapping from JSON string to the CLR object.
                </para>
                <para>
                    When you define it, default deserialization for the particular event type won't be used.
                    See more in
                    <a href="https://martendb.io/events/versioning.html#raw-json-transformation-with-json-net">documentation</a>
                </para>
            </summary>
            <param name="options">Event store options</param>
            <param name="eventType">Mapped CLR event type</param>
            <param name="schemaVersion">Event schema version</param>
            <param name="jsonTransformation">Event payload transformation</param>
            <returns>Event store options, to allow fluent definition</returns>
        </member>
        <member name="M:EventStoreOptionsExtensions.Upcast``2(Marten.Events.IEventStoreOptions,System.UInt32,System.Func{``0,``1})">
            <summary>
                <para>
                    Method defines the event JSON payload transformation. It "upcasts" one event schema version into another.
                    You can use it to handle the event schema versioning/migration.
                </para>
                <para>
                    By calling it, you tell that instead of the old CLR type, for the specific event type name,
                    you'd like to get the new CLR event type.
                    Provided function takes the deserialized object of the old event type and returns the new, mapped one.
                </para>
                <para>
                    Internally it uses default deserialization and event type mapping for old CLR type
                    and calls the mapping function.
                    In your application code, you should use only the new event type in the aggregation and projection logic.
                    See more in
                    <a href="https://martendb.io/events/versioning.html#transformation-with-clr-types-will-look-like-this">documentation</a>
                </para>
            </summary>
            <param name="options">Event store options</param>
            <param name="schemaVersion">Event schema version</param>
            <param name="upcast">Event payload transformation, upcasting object of old CLR event type into the new one</param>
            <typeparam name="TOldEvent">Old CLR event type</typeparam>
            <typeparam name="TEvent">New CLR event type</typeparam>
            <returns>Event store options, to allow fluent definition</returns>
        </member>
        <member name="M:EventStoreOptionsExtensions.Upcast``2(Marten.Events.IEventStoreOptions,System.UInt32,System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task{``1}})">
            <summary>
                <para>
                    Method defines the event JSON payload transformation. It "upcasts" one event schema version into another.
                    You can use it to handle the event schema versioning/migration.
                </para>
                <para>
                    By calling it, you tell that instead of the old CLR type, for the specific event type name,
                    you'd like to get the new CLR event type.
                    Provided function takes the deserialized object of the old event type and returns the new, mapped one.
                </para>
                <para>
                    Internally it uses default deserialization and event type mapping for old CLR type
                    and calls the mapping function.
                    In your application code, you should use only the new event type in the aggregation and projection logic
                    See more in <a href="https://martendb.io/events/versioning.html#function-with-clr-types">documentation</a>
                </para>
                <para>
                    <b>WARNING!</b> Transformation will only be run in the async API and throw exceptions when run in sync method
                    calls.
                </para>
            </summary>
            <param name="options">Event store options</param>
            <param name="schemaVersion">Event schema version</param>
            <param name="upcastAsync">
                Async only event payload transformation, upcasting object of old CLR event type into the new
                one
            </param>
            <typeparam name="TOldEvent">Old CLR event type</typeparam>
            <typeparam name="TEvent">New CLR event type</typeparam>
            <returns>Event store options, to allow fluent definition</returns>
            <exception cref="T:Marten.Exceptions.MartenException">when provided transformation is called in sync API</exception>
        </member>
    </members>
</doc>
