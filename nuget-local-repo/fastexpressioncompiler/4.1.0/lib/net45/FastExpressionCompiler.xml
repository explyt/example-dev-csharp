<?xml version="1.0"?>
<doc>
    <assembly>
        <name>FastExpressionCompiler</name>
    </assembly>
    <members>
        <member name="T:FastExpressionCompiler.CompilerFlags">
            <summary>The flags for the compiler</summary>
        </member>
        <member name="F:FastExpressionCompiler.CompilerFlags.Default">
            <summary>The default flags: Invocation lambda is inlined, no debug info</summary>
        </member>
        <member name="F:FastExpressionCompiler.CompilerFlags.NoInvocationLambdaInlining">
            <summary>Prevents the inlining of the lambda in the Invocation expression to optimize for the multiple same lambda compiled once</summary>
        </member>
        <member name="F:FastExpressionCompiler.CompilerFlags.EnableDelegateDebugInfo">
            <summary>Adds the Expression, ExpressionString, and CSharpString to the delegate closure for the debugging inspection</summary>
        </member>
        <member name="F:FastExpressionCompiler.CompilerFlags.ThrowOnNotSupportedExpression">
            <summary>When the flag is set then instead of the returning `null` the specific exception is thrown*346</summary>
        </member>
        <member name="T:FastExpressionCompiler.NotSupportedExpressionException">
            <summary>FEC Not Supported exception</summary>
        </member>
        <member name="F:FastExpressionCompiler.NotSupportedExpressionException.Reason">
            <summary>The reason</summary>
        </member>
        <member name="M:FastExpressionCompiler.NotSupportedExpressionException.#ctor(FastExpressionCompiler.ExpressionCompiler.Result)">
            <summary>Constructor</summary>
        </member>
        <member name="M:FastExpressionCompiler.NotSupportedExpressionException.#ctor(FastExpressionCompiler.ExpressionCompiler.Result,System.String)">
            <summary>Constructor</summary>
        </member>
        <member name="T:FastExpressionCompiler.IDelegateDebugInfo">
            <summary>The interface is implemented by the compiled delegate Target if `CompilerFlags.EnableDelegateDebugInfo` is set.</summary>
        </member>
        <member name="P:FastExpressionCompiler.IDelegateDebugInfo.Expression">
            <summary>The lambda expression object that was compiled to the delegate</summary>
        </member>
        <member name="P:FastExpressionCompiler.IDelegateDebugInfo.ExpressionString">
            <summary>The lambda expression construction syntax C# code</summary>
        </member>
        <member name="P:FastExpressionCompiler.IDelegateDebugInfo.CSharpString">
            <summary>The equivalent C# code of the lambda expression</summary>
        </member>
        <member name="T:FastExpressionCompiler.ExpressionCompiler">
            <summary>Compiles expression to delegate ~20 times faster than Expression.Compile.
            Partial to extend with your things when used as source file.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``1(System.Linq.Expressions.LambdaExpression,System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to TDelegate type. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFastToIL(System.Linq.Expressions.LambdaExpression,System.Reflection.Emit.ILGenerator,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles a static method to the passed IL Generator.
            Could be used as alternative for `CompileToMethod` like this <code><![CDATA[funcExpr.CompileFastToIL(methodBuilder.GetILGenerator())]]></code>.
            Check `IssueTests.Issue179_Add_something_like_LambdaExpression_CompileToMethod.cs` for example.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast(System.Linq.Expressions.LambdaExpression,System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileSys``1(System.Linq.Expressions.Expression{``0})">
            <summary>Unifies Compile for System.Linq.Expressions and FEC.LightExpression</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileSys(System.Linq.Expressions.LambdaExpression)">
            <summary>Unifies Compile for System.Linq.Expressions and FEC.LightExpression</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``1(System.Linq.Expressions.Expression{``0},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to TDelegate type. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``1(System.Linq.Expressions.Expression{System.Func{``0}},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``2(System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``3(System.Linq.Expressions.Expression{System.Func{``0,``1,``2}},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to TDelegate type. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``4(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3}},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``5(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4}},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to TDelegate type. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``6(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4,``5}},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``7(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4,``5,``6}},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast(System.Linq.Expressions.Expression{System.Action},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``1(System.Linq.Expressions.Expression{System.Action{``0}},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``2(System.Linq.Expressions.Expression{System.Action{``0,``1}},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``3(System.Linq.Expressions.Expression{System.Action{``0,``1,``2}},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``4(System.Linq.Expressions.Expression{System.Action{``0,``1,``2,``3}},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``5(System.Linq.Expressions.Expression{System.Action{``0,``1,``2,``3,``4}},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``6(System.Linq.Expressions.Expression{System.Action{``0,``1,``2,``3,``4,``5}},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.TryCompile``1(System.Linq.Expressions.LambdaExpression,FastExpressionCompiler.CompilerFlags)">
            <summary>Tries to compile lambda expression to <typeparamref name="TDelegate"/></summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.TryCompileWithPreCreatedClosure``1(System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.ConstantExpression[])">
            <summary>Tries to compile lambda expression to <typeparamref name="TDelegate"/> 
            with the provided closure object and constant expressions (or lack there of) -
            Constant expression should be the in order of Fields in closure object!
            Note 1: Use it on your own risk - FEC won't verify the expression is compile-able with passed closure, it is up to you!
            Note 2: The expression with NESTED LAMBDA IS NOT SUPPORTED!
            Note 3: `Label` and `GoTo` are not supported in this case, because they need first round to collect out-of-order labels</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.TryCompileWithPreCreatedClosure``1(System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.ConstantExpression[],FastExpressionCompiler.CompilerFlags)">
            <summary>Tries to compile lambda expression to <typeparamref name="TDelegate"/> 
            with the provided closure object and constant expressions (or lack there of)</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.TryCompileWithoutClosure``1(System.Linq.Expressions.LambdaExpression,FastExpressionCompiler.CompilerFlags)">
            <summary>Tries to compile expression to "static" delegate, skipping the step of collecting the closure object.</summary>
        </member>
        <member name="T:FastExpressionCompiler.ExpressionCompiler.NestedLambdaInfo">
            <summary>Collects the lambda info for the compilation</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.NestedLambdaInfo.Lambda">
            <summary>Compiled lambda</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.NestedLambdaInfo.NestedLambdas">
            <summary>The nested lambdas and their info</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.NestedLambdaInfo.LambdaExpression">
            <summary>The lambda expression</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.NestedLambdaInfo.NonPassedParameters">
            <summary>Parameters not passed through lambda parameter list But used inside lambda body.
            The top expression should Not contain not passed parameters.</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.NestedLambdaInfo.LambdaVarIndex">
            <summary>Index of the compiled lambda in the parent lambda closure array</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.NestedLambdaInfo.NonPassedParamsVarIndex">
            <summary>Index of the variable which store the non-passed variables array before passing it to the closure constructor.
            It used to assign the closed variables from the outside of the nested lambda</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.NestedLambdaInfo.GetLambdaType">
            <summary>Returns the type of lambda</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.NestedLambdaInfo.HasTheSameLambdaExpression(System.Linq.Expressions.LambdaExpression)">
            <summary>Compares 2 lambda expressions for equality</summary>
        </member>
        <member name="T:FastExpressionCompiler.ExpressionCompiler.ClosureInfo">
            Track the info required to build a closure object + some context information not directly related to closure.
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ClosureInfo.LastEmitIsAddress">
            <summary>Tracks that the last emit was an address</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ClosureInfo._varInBlockMap">
            <summary>Tracks the use of the variables in the blocks stack per variable, 
            (uint) contains (ushort) BlockIndex in the upper bits and (ushort) VarIndex in the lower bits.
            to determine if variable is the local variable and in what block it's defined</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ClosureInfo.Labels">
            Map the Labels to their Targets
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ClosureInfo.Constants">
            Constant expressions to find an index (by reference) of constant expression from compiled expression.
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ClosureInfo.ConstantUsageThenVarIndex">
            Constant usage count and variable index.
            It is a separate collection from the Constants because we directly convert later into the closure array
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ClosureInfo.NonPassedParameters">
            <summary>Parameters not passed through lambda parameter list But used inside lambda body.
            The top expression should Not contain not passed parameters.</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ClosureInfo.NestedLambdas">
            <summary>The nested lambdas and their info</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.ClosureInfo.#ctor(FastExpressionCompiler.ExpressionCompiler.ClosureStatus)">
            <summary>Populates the info</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.ClosureInfo.#ctor(FastExpressionCompiler.ExpressionCompiler.ClosureStatus,System.Object[])">
            <summary>Populates info directly with provided closure object and constants.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.ClosureInfo.PushBlockWithVars(System.Linq.Expressions.ParameterExpression)">
            Local variable index is not known in the collecting phase when we only need to decide if ParameterExpression is an actual parameter or variable
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.IsClosureBoundConstant(System.Object,System.Type)">
            Helps to identify constants as the one to be put into the Closure
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.Result.NotSupported_NewArrayInit_MultidimensionalArray">
            <summary>Multi-dimensional array initializer is not supported</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.Result.NotSupported_Quote">
            <summary>Quote is not supported</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.Result.NotSupported_Dynamic">
            <summary>Dynamic is not supported</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.Result.NotSupported_RuntimeVariables">
            <summary>RuntimeVariables is not supported</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.Result.NotSupported_MemberInit_MemberBinding">
            <summary>MemberInit MemberBinding is not supported</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.Result.NotSupported_MemberInit_ListBinding">
            <summary>MemberInit ListBinding is not supported</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.Result.NotSupported_Try_GotoReturnToTheFollowupLabel">
            <summary>Goto of the Return kind from the TryCatch is not supported</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.Result.NotSupported_Assign_Target">
            <summary>Not supported assignment target</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.Result.NotSupported_TypeEqual">
            <summary>TypeEqual is not supported </summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.TryCollectBoundConstants(FastExpressionCompiler.ExpressionCompiler.ClosureInfo@,System.Linq.Expressions.Expression,System.Collections.Generic.IReadOnlyList{System.Linq.Expressions.ParameterExpression},FastExpressionCompiler.ExpressionCompiler.NestedLambdaInfo,FastExpressionCompiler.ImTools.SmallList{FastExpressionCompiler.ExpressionCompiler.NestedLambdaInfo}@,FastExpressionCompiler.CompilerFlags)">
            <summary>Wraps the call to `TryCollectInfo` for the compatibility and provide the root place to check the returned error code.
            Imprtant: The method collects the info from the nested lambdas up-front and de-duplicates the lambdas as well.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.TryCollectInfo(FastExpressionCompiler.ExpressionCompiler.ClosureInfo@,System.Linq.Expressions.Expression,System.Collections.Generic.IReadOnlyList{System.Linq.Expressions.ParameterExpression},FastExpressionCompiler.ExpressionCompiler.NestedLambdaInfo,FastExpressionCompiler.ImTools.SmallList{FastExpressionCompiler.ExpressionCompiler.NestedLambdaInfo}@,FastExpressionCompiler.CompilerFlags)">
            <summary>Collects the information about closure constants, nested lambdas, non-passed parameters, goto labels and variables in blocks.
            Returns `OK` result if everything is fine and other result for error.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.TryGetDebugInfo``1(``0)">
            <summary>Return IDelegateDebugInfo if the delegate is fast compiled with `CompilerFlags.EnableDelegateDebugInfo` flag</summary>
        </member>
        <member name="T:FastExpressionCompiler.ExpressionCompiler.ParentFlags">
            The minimal context-aware flags set by parent
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.Empty">
            Default is no flags
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.IgnoreResult">
            The result of expression is ignored and maybe popped out
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.Call">
            Some parent is the call expression
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.MemberAccess">
            Any Parent Expression is a MemberExpression
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.Arithmetic">
            Some arithmetic operation
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.Coalesce">
            Subject
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.InstanceAccess">
            Expression with instance object (method call or member access or array access)
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.DupIt">
            Subject
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.TryCatch">
            Subject
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.InstanceCall">
            Combination`of InstanceAccess and Call
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.Ctor">
            Constructor
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.CtorCall">
            Constructor call
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.IndexAccess">
            Indexer
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.InlinedLambdaInvoke">
            Invoking the inlined lambda (the default System.Expression behavior)
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.AssignmentLeftValue">
            <summary>Indicate if the part AT LEAST participates in the assignment on the left side, 
            it may also participate in the right side, e.g. ++x.Bar</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.AssignmentRightValue">
            <summary>Indicates the ONLY right value of assignment, e.g. `p` in `foo.Bar += p` </summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.AssignmentByRef">
            <summary>Assigning the ref of the right value to the left, e.g. in `var a = ref b[1]` we are passing this flag for the `ref b[1]`</summary>
        </member>
        <member name="T:FastExpressionCompiler.ExpressionCompiler.EmittingVisitor">
            <summary>Supports emitting of selected expressions, e.g. lambdaExpr are not supported yet.
            When emitter find not supported expression it will return false from <see cref="M:FastExpressionCompiler.ExpressionCompiler.EmittingVisitor.TryEmit(System.Linq.Expressions.Expression,System.Collections.Generic.IReadOnlyList{System.Linq.Expressions.ParameterExpression},System.Reflection.Emit.ILGenerator,FastExpressionCompiler.ExpressionCompiler.ClosureInfo@,FastExpressionCompiler.CompilerFlags,FastExpressionCompiler.ExpressionCompiler.ParentFlags,System.Int32)"/>, so I could fallback
            to normal and slow Expression.Compile.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.EmittingVisitor.EmitMethodCallOrVirtualCall(System.Reflection.Emit.ILGenerator,System.Reflection.MethodInfo)">
            Get the advantage of the optimized specialized EmitCall method
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.EmittingVisitor.EmitMethodCallCheckForNull(System.Reflection.Emit.ILGenerator,System.Reflection.MethodInfo)">
            Same as EmitMethodCall which checks the method for null first, and returns false if it is null. 
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.EmittingVisitor.EmitMethodCallOrVirtualCallCheckForNull(System.Reflection.Emit.ILGenerator,System.Reflection.MethodInfo)">
            Same as EmitMethodCallOrVirtualCall which checks the method for null first, and returns false if it is null. 
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.EmittingVisitor.EmitLoadConstantInt(System.Reflection.Emit.ILGenerator,System.Int32)">
            Efficiently emit the int constant
        </member>
        <member name="T:FastExpressionCompiler.ILGeneratorHacks">
            <summary>Reflecting the internal methods to access the more performant for defining the local variable</summary>
        </member>
        <member name="M:FastExpressionCompiler.ILGeneratorHacks.GetNextLocalVarIndex(System.Reflection.Emit.ILGenerator,System.Type)">
            <summary>Efficiently returns the next variable index, hopefully without unnecessary allocations.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ToExpressionPrinter.ToExpressionString(System.Linq.Expressions.Expression,FastExpressionCompiler.CodePrinter.ObjectToCode)">
            <summary>
            Prints the expression in its constructing syntax - 
            helpful to get the expression from the debug session and put into it the code for the test.
            </summary>
        </member>
        <member name="M:FastExpressionCompiler.ToExpressionPrinter.ToExpressionString(System.Linq.Expressions.Expression,System.Collections.Generic.List{System.Linq.Expressions.ParameterExpression}@,System.Collections.Generic.List{System.Linq.Expressions.Expression}@,System.Collections.Generic.List{System.Linq.Expressions.LabelTarget}@,System.Boolean,System.Func{System.Type,System.String,System.String},System.Int32,FastExpressionCompiler.CodePrinter.ObjectToCode)">
            <summary>
            Prints the expression in its constructing syntax - 
            helpful to get the expression from the debug session and put into it the code for the test.
            In addition, returns the gathered expressions, parameters ad labels. 
            </summary>
        </member>
        <member name="T:FastExpressionCompiler.ToCSharpPrinter">
            <summary>Converts the expression into the valid C# code representation</summary>
        </member>
        <member name="M:FastExpressionCompiler.ToCSharpPrinter.ToCSharpString(System.Linq.Expressions.Expression)">
            <summary>Tries hard to convert the expression into the valid C# code</summary>
        </member>
        <member name="M:FastExpressionCompiler.ToCSharpPrinter.ToCSharpString(System.Linq.Expressions.Expression,FastExpressionCompiler.CodePrinter.ObjectToCode)">
            <summary>Tries hard to convert the expression into the valid C# code</summary>
        </member>
        <member name="M:FastExpressionCompiler.ToCSharpPrinter.ToCSharpString(System.Linq.Expressions.Expression,System.Text.StringBuilder,System.Int32,System.Boolean,System.Func{System.Type,System.String,System.String},System.Int32,FastExpressionCompiler.CodePrinter.ObjectToCode)">
            <summary>Tries hard to convert the expression into the valid C# code</summary>
        </member>
        <member name="T:FastExpressionCompiler.ToCSharpPrinter.EnclosedIn">
            <summary>Indicates the expression container</summary>
        </member>
        <member name="F:FastExpressionCompiler.ToCSharpPrinter.EnclosedIn.Whatever">
            <summary>Does not matter for the output - the default value</summary>
        </member>
        <member name="F:FastExpressionCompiler.ToCSharpPrinter.EnclosedIn.IfTest">
            <summary>The test part of the If expression</summary>
        </member>
        <member name="F:FastExpressionCompiler.ToCSharpPrinter.EnclosedIn.Block">
            <summary>The `if (test)` part</summary>
        </member>
        <member name="F:FastExpressionCompiler.ToCSharpPrinter.EnclosedIn.LambdaBody">
            <summary>The lambda</summary>
        </member>
        <member name="F:FastExpressionCompiler.ToCSharpPrinter.EnclosedIn.Return">
            <summary>Return expression</summary>
        </member>
        <member name="F:FastExpressionCompiler.ToCSharpPrinter.EnclosedIn.AvoidParens">
            <summary>Instructs the client code to avoid parenthesis for the generated C# code, e.g. if we have as single argument in a method</summary>
        </member>
        <member name="M:FastExpressionCompiler.CodePrinter.ToCode(System.Type,System.Boolean,System.Func{System.Type,System.String,System.String},System.Boolean)">
            <summary>Converts the <paramref name="type"/> into the proper C# representation.</summary>
        </member>
        <member name="M:FastExpressionCompiler.CodePrinter.ToCode(System.Boolean)">
            <summary>Prints valid C# Boolean</summary>
        </member>
        <member name="M:FastExpressionCompiler.CodePrinter.ToCode(System.String)">
            <summary>Prints valid C# String escaping the things</summary>
        </member>
        <member name="M:FastExpressionCompiler.CodePrinter.ToEnumValueCode(System.Type,System.Object,System.Boolean,System.Func{System.Type,System.String,System.String})">
            <summary>Prints valid C# Enum literal</summary>
        </member>
        <member name="T:FastExpressionCompiler.CodePrinter.ObjectToCode">
            <summary>Custom handler for output the object in valid C#. Note, the `printGenericTypeArgs` is excluded because it cannot be a open-generic object.
            This handler is also used to allow user to fully control a Constant expression output</summary>
        </member>
        <member name="F:FastExpressionCompiler.CodePrinter.DefaultNotRecognizedToCode">
            <summary>Outputs the `default(Type)` for the unknown constant with the comment message</summary>
        </member>
        <member name="M:FastExpressionCompiler.CodePrinter.ToCommaSeparatedCode(System.Collections.IEnumerable,FastExpressionCompiler.CodePrinter.ObjectToCode,System.Boolean,System.Func{System.Type,System.String,System.String})">
            <summary>Prints many code items as the array initializer.</summary>
        </member>
        <member name="M:FastExpressionCompiler.CodePrinter.ToArrayInitializerCode(System.Collections.IEnumerable,System.Type,FastExpressionCompiler.CodePrinter.ObjectToCode,System.Boolean,System.Func{System.Type,System.String,System.String})">
            <summary>Prints many code items as array initializer.</summary>
        </member>
        <member name="M:FastExpressionCompiler.CodePrinter.ToCode(System.Object,FastExpressionCompiler.CodePrinter.ObjectToCode,System.Boolean,System.Func{System.Type,System.String,System.String})">
            <summary>
            Prints a valid C# for known <paramref name="x"/>,
            otherwise uses passed <paramref name="notRecognizedToCode"/> or falls back to `ToString()`.
            </summary>
        </member>
        <member name="M:FastExpressionCompiler.CodePrinter.CountLambdas(System.String)">
            <summary>Helper method to find the number of lambdas in the C# `code` string</summary>
        </member>
        <member name="T:FastExpressionCompiler.ImTools.SmallList`1">
            <summary>Wrapper for the array and count</summary>
        </member>
        <member name="F:FastExpressionCompiler.ImTools.SmallList`1.Items">
            <summary>Array of items</summary>
        </member>
        <member name="F:FastExpressionCompiler.ImTools.SmallList`1.Count">
            <summary>The count of used items</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList`1.#ctor(`0[],System.Int32)">
            <summary>Creating this stuff</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList`1.#ctor(`0[])">
            <summary>Creates the wrapper out of the items</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList`1.Pop">
            <summary>Popping candy</summary>
        </member>
        <member name="T:FastExpressionCompiler.ImTools.SmallList">
            <summary>SmallList module he-he</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.AppendDefaultToNotNullItemsAndGetRef``1(``0[]@,System.Int32)">
            <summary>Appends the new default item at the end of the items. Assumes that `index lte items.Length`! 
            `items` should be not null</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.AppendDefaultAndGetRef``1(``0[]@,System.Int32,System.Int32)">
            <summary>Appends the new default item at the end of the items. Assumes that `index lte items.Length`, `items` may be null</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.GetSurePresentItemRef``1(FastExpressionCompiler.ImTools.SmallList{``0}@,System.Int32)">
            <summary>Returns surely present item ref by its index</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.Append``1(FastExpressionCompiler.ImTools.SmallList{``0}@,System.Int32)">
            <summary>Appends the new default item to the list and returns ref to it for write or read</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.Append``1(FastExpressionCompiler.ImTools.SmallList{``0}@,``0@,System.Int32)">
            <summary>Appends the new item to the list</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.TryGetIndex``2(FastExpressionCompiler.ImTools.SmallList{``0}@,``0,``1)">
            <summary>Looks for the item in the list and return its index if found or -1 for the absent item</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.GetIndexOrAppend``2(FastExpressionCompiler.ImTools.SmallList{``0}@,``0@,``1)">
            <summary>Returns the ref of the found item or appends the item to the end of the list, and returns ref to it</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.GetSurePresentItemRef``1(FastExpressionCompiler.ImTools.SmallList4{``0}@,System.Int32)">
            <summary>Returns surely present item ref by its index</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.GetLastSurePresentItem``1(FastExpressionCompiler.ImTools.SmallList4{``0}@)">
            <summary>Returns last present item ref, assumes that the list is not empty!</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.NotFound``1(FastExpressionCompiler.ImTools.SmallList4{``0}@)">
            <summary>Returns the ref to tombstone indicating the missing item.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.AppendDefaultAndGetRef``1(FastExpressionCompiler.ImTools.SmallList4{``0}@)">
            <summary>Appends the default item to the end of the list and returns the reference to it.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.TryGetIndex``2(FastExpressionCompiler.ImTools.SmallList4{``0}@,``0,``1)">
            <summary>Looks for the item in the list and return its index if found or -1 for the absent item</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.GetIndexOrAppend``2(FastExpressionCompiler.ImTools.SmallList4{``0}@,``0@,``1)">
            <summary>Returns the ref of the found item or appends the item to the end of the list, and returns ref to it</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.GetSurePresentItemRef``1(FastExpressionCompiler.ImTools.SmallList2{``0}@,System.Int32)">
            <summary>Returns surely present item ref by its index</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.GetLastSurePresentItem``1(FastExpressionCompiler.ImTools.SmallList2{``0}@)">
            <summary>Returns last present item ref, assumes that the list is not empty!</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.NotFound``1(FastExpressionCompiler.ImTools.SmallList2{``0}@)">
            <summary>Returns the ref to tombstone indicating the missing item.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.AppendDefaultAndGetRef``1(FastExpressionCompiler.ImTools.SmallList2{``0}@)">
            <summary>Appends the default item to the end of the list and returns the reference to it.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.TryGetIndex``2(FastExpressionCompiler.ImTools.SmallList2{``0}@,``0,``1)">
            <summary>Looks for the item in the list and return its index if found or -1 for the absent item</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.GetIndexOrAppend``2(FastExpressionCompiler.ImTools.SmallList2{``0}@,``0,``1)">
            <summary>Returns the ref of the found item or appends the item to the end of the list, and returns ref to it</summary>
        </member>
        <member name="T:FastExpressionCompiler.ImTools.SmallList4`1">
            <summary>List with the number of first items (4) stored inside its struct and the rest in the growable array.
            Supports addition and removal (removel is without resize) only at the end of the list, aka Stack behavior</summary>
        </member>
        <member name="F:FastExpressionCompiler.ImTools.SmallList4`1.StackItemCount">
            <summary>The number of entries stored inside the map itself without moving them to array on heap</summary>
        </member>
        <member name="P:FastExpressionCompiler.ImTools.SmallList4`1.Count">
            <summary>Gets the number of items in the list</summary>
        </member>
        <member name="P:FastExpressionCompiler.ImTools.SmallList4`1.Item(System.Int32)">
            <summary>Returns surely present item by its index</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList4`1.Append(`0@)">
            <summary>Adds the item to the end of the list aka the Stack.Push</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList4`1.Add(`0@)">
            <summary>Bridge to go from the List.Add</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList4`1.AppendDefault">
            <summary>Adds the default item to the end of the list aka the Stack.Push default</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList4`1.RemoveLastSurePresentItem">
            <summary>Removes the last item from the list aka the Stack Pop. Assumes that the list is not empty!</summary>
        </member>
        <member name="T:FastExpressionCompiler.ImTools.SmallList2`1">
            <summary>List with the number of first items (2) stored inside its struct and the rest in the growable array.
            Supports addition and removal (removel is without resize) only at the end of the list, aka Stack behavior</summary>
        </member>
        <member name="F:FastExpressionCompiler.ImTools.SmallList2`1.StackItemCount">
            <summary>The number of entries stored inside the map itself without moving them to array on heap</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList2`1.InitCount(System.Int32)">
            <summary>Good stuff</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList2`1.Init(`0)">
            <summary>Good stiff</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList2`1.Init(`0,`0)">
            <summary>Good steff</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList2`1.Init(`0,`0,`0[])">
            <summary>Good staff</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList2`1.Init(`0[])">
            <summary>Good styff</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList2`1.Init``1(``0)">
            <summary>Good staff</summary>
        </member>
        <member name="P:FastExpressionCompiler.ImTools.SmallList2`1.Count">
            <summary>Gets the number of items in the list</summary>
        </member>
        <member name="P:FastExpressionCompiler.ImTools.SmallList2`1.Item(System.Int32)">
            <summary>Returns surely present item by its index</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList2`1.Append(`0@)">
            <summary>Adds the item to the end of the list aka the Stack.Push</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList2`1.Add(`0@)">
            <summary>Bridge to go from the List.Add</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList2`1.AppendDefault">
            <summary>Adds the default item to the end of the list aka the Stack.Push default</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList2`1.RemoveLastSurePresentItem">
            <summary>Removes the last item from the list aka the Stack Pop. Assumes that the list is not empty!</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList2`1.CopyToArray">
            <summary>Copy items to new the array</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList2`1.AsList">
            <summary>Exposing as list</summary>
        </member>
        <member name="T:FastExpressionCompiler.ImTools.FHashMap">
            <summary>Configiration and the tools for the FHashMap map data structure</summary>
        </member>
        <member name="F:FastExpressionCompiler.ImTools.FHashMap.GoldenRatio32">
            <summary>2^32 / phi for the Fibonacci hashing, where phi is the golden ratio ~1.61803</summary>
        </member>
        <member name="F:FastExpressionCompiler.ImTools.FHashMap.MaxProbeBits">
            <summary>Upper hash bits spent on storing the probes, e.g. 5 bits mean 31 probes max.</summary>
        </member>
        <member name="F:FastExpressionCompiler.ImTools.FHashMap.StackEntriesCount">
            <summary>The number of entries stored inside the map itself without moving them to array on heap</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.FHashMap.New``3(System.Byte)">
            <summary>Creates the map with the <see cref="T:FastExpressionCompiler.ImTools.FHashMap.SingleArrayEntries`3"/> storage</summary>
        </member>
        <member name="T:FastExpressionCompiler.ImTools.FHashMap.Entry`2">
            <summary>Holds a single entry consisting of key and value. 
            Value may be set or changed but the key is set in stone (by construction).</summary>
        </member>
        <member name="F:FastExpressionCompiler.ImTools.FHashMap.Entry`2.Key">
            <summary>The readonly key</summary>
        </member>
        <member name="F:FastExpressionCompiler.ImTools.FHashMap.Entry`2.Value">
            <summary>The mutable value</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.FHashMap.Entry`2.#ctor(`0)">
            <summary>Construct with the key and default value</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.FHashMap.Entry`2.#ctor(`0,`1)">
            <summary>Construct with the key and value</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.FHashMap.ToB(System.Int32)">
            binary reprsentation of the `int`
        </member>
        <member name="T:FastExpressionCompiler.ImTools.FHashMap.IEq`1">
            <summary>Configures removed key tombstone, equality and hash function for the FHashMap</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.FHashMap.IEq`1.GetTombstone">
            <summary>Defines the value of the key indicating the removed entry</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.FHashMap.IEq`1.Equals(`0,`0)">
            <summary>Equals keys</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.FHashMap.IEq`1.GetHashCode(`0)">
            <summary>Calculates and returns the hash of the key</summary>
        </member>
        <member name="T:FastExpressionCompiler.ImTools.FHashMap.DefaultEq`1">
            <summary>Default comparer using the `object.GetHashCode` and `object.Equals` oveloads</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.FHashMap.DefaultEq`1.GetTombstone">
            <inheritdoc />
        </member>
        <member name="M:FastExpressionCompiler.ImTools.FHashMap.DefaultEq`1.Equals(`0,`0)">
            <inheritdoc />
        </member>
        <member name="M:FastExpressionCompiler.ImTools.FHashMap.DefaultEq`1.GetHashCode(`0)">
            <inheritdoc />
        </member>
        <member name="T:FastExpressionCompiler.ImTools.FHashMap.RefEq`1">
            <summary>Uses the `object.GetHashCode` and `object.ReferenceEquals`</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.FHashMap.RefEq`1.GetTombstone">
            <inheritdoc />
        </member>
        <member name="M:FastExpressionCompiler.ImTools.FHashMap.RefEq`1.Equals(`0,`0)">
            <inheritdoc />
        </member>
        <member name="M:FastExpressionCompiler.ImTools.FHashMap.RefEq`1.GetHashCode(`0)">
            <inheritdoc />
        </member>
        <member name="T:FastExpressionCompiler.ImTools.FHashMap.RefEq`2">
            <summary>Compares via `ReferenceEquals` and gets the hash faster via `RuntimeHelpers.GetHashCode`</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.FHashMap.RefEq`2.GetTombstone">
            <inheritdoc />
        </member>
        <member name="M:FastExpressionCompiler.ImTools.FHashMap.RefEq`2.Equals(System.ValueTuple{`0,`1},System.ValueTuple{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:FastExpressionCompiler.ImTools.FHashMap.RefEq`2.GetHashCode(System.ValueTuple{`0,`1})">
            <inheritdoc />
        </member>
        <member name="T:FastExpressionCompiler.ImTools.FHashMap.RefEq`3">
            <summary>Compares via `ReferenceEquals` and gets the hash faster via `RuntimeHelpers.GetHashCode`</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.FHashMap.RefEq`3.GetTombstone">
            <inheritdoc />
        </member>
        <member name="M:FastExpressionCompiler.ImTools.FHashMap.RefEq`3.Equals(System.ValueTuple{`0,`1,`2},System.ValueTuple{`0,`1,`2})">
            <inheritdoc />
        </member>
        <member name="M:FastExpressionCompiler.ImTools.FHashMap.RefEq`3.GetHashCode(System.ValueTuple{`0,`1,`2})">
            <inheritdoc />
        </member>
        <member name="T:FastExpressionCompiler.ImTools.FHashMap.Hasher">
            <summary>Combines the hashes of 2 keys</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.FHashMap.Hasher.Combine(System.Int32,System.Int32)">
            <summary>Combines the hashes of 2 keys</summary>
        </member>
        <member name="T:FastExpressionCompiler.ImTools.FHashMap.IEntries`3">
            <summary>Abstraction to configure your own entries data structure. Check the derivitives for the examples</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.FHashMap.IEntries`3.Init(System.Byte)">
            <summary>Initializes the entries storage to the specified capacity via the number of <paramref name="capacityBitShift"/> bits in the capacity</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.FHashMap.IEntries`3.GetSurePresentEntryRef(System.Int32)">
            <summary>Returns the reference to entry by its index, index should map to the present/non-removed entry</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.FHashMap.IEntries`3.AddKeyAndGetValueRef(`0,System.Int32)">
            <summary>Adds the key at the "end" of entriesc- so the order of addition is preserved.</summary>
        </member>
        <member name="T:FastExpressionCompiler.ImTools.FHashMap.SingleArrayEntries`3">
            <summary>Stores the entries in a single dynamically reallocated array</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.FHashMap.SingleArrayEntries`3.Init(System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.FHashMap.SingleArrayEntries`3.GetSurePresentEntryRef(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.FHashMap.SingleArrayEntries`3.AddKeyAndGetValueRef(`0,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.FHashMap.TryGetValueRef``4(FastExpressionCompiler.ImTools.FHashMap{``0,``1,``2,``3}@,``0,System.Boolean@)">
            <summary>Finds the stored value by key. If found returns ref to the value it can be modified in place.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.FHashMap.GetOrAddValueRef``4(FastExpressionCompiler.ImTools.FHashMap{``0,``1,``2,``3}@,``0,System.Boolean@)">
            <summary>Gets the reference to the existing value of the provided key, or the default value to set for the newly added key.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.FHashMap.AddSureAbsentDefaultAndGetRef``4(FastExpressionCompiler.ImTools.FHashMap{``0,``1,``2,``3}@,``0)">
            <summary>Adds the sure absent key entry. 
            Provides the performance in scenarios where you look for present key, and using it, and if ABSENT then add the new one.
            So this method optimized NOT to look for the present item for the second time in SEQUENCE</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.FHashMap.GetSurePresentEntryRef``4(FastExpressionCompiler.ImTools.FHashMap{``0,``1,``2,``3}@,System.Int32)">
            <summary>Get the value ref by the entry index. Also the index corresponds to entry adding order.
            Improtant: it does not checks the index bounds, so you need to check that the index is from 0 to map.Count-1</summary>
        </member>
        <member name="T:FastExpressionCompiler.ImTools.FHashMap`4">
            <summary>
            Fast and less-allocating hash map without thread safety nets. Please measure it in your own use case before use.
            It is configurable in regard of hash calculation/equality via `TEq` type paremeter and 
            in regard of key-value storage via `TEntries` type parameter.
            
            Details:
            - Implemented as a struct so that the empty/default map does not allocate on heap
            - Hashes and key-values are the separate collections enabling better cash locality and faster performance (data-oriented design)
            - No SIMD for now to avoid complexity and costs for the smaller maps, so the map is more fit for the smaller sizes.
            - Provides the "stable" enumeration of the entries in the added order
            - The TryRemove method removes the hash but replaces the key-value entry with the tombstone key and the default value.
            For instance, for the `RefEq` the tombstone is <see langword="null"/>. You may redefine it in the `IEq{K}.GetTombstone()` implementation.
            
            </summary>
        </member>
        <member name="P:FastExpressionCompiler.ImTools.FHashMap`4.CapacityBitShift">
            <summary>Capacity bits</summary>
        </member>
        <member name="P:FastExpressionCompiler.ImTools.FHashMap`4.PackedHashesAndIndexes">
            <summary>Access to the hashes and indexes</summary>
        </member>
        <member name="P:FastExpressionCompiler.ImTools.FHashMap`4.Count">
            <summary>Number of entries in the map</summary>
        </member>
        <member name="P:FastExpressionCompiler.ImTools.FHashMap`4.Entries">
            <summary>Access to the key-value entries</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.FHashMap`4.#ctor(System.Byte)">
            <summary>Capacity calculates as `1 leftShift capacityBitShift`</summary>
        </member>
    </members>
</doc>
